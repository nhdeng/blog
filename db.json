{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/docker/container-command.png","path":"images/docker/container-command.png","modified":0,"renderable":0},{"_id":"source/images/docker/composition.png","path":"images/docker/composition.png","modified":0,"renderable":0},{"_id":"source/images/docker/container-options.png","path":"images/docker/container-options.png","modified":0,"renderable":0},{"_id":"source/images/docker/dockerfile.png","path":"images/docker/dockerfile.png","modified":0,"renderable":0},{"_id":"source/images/git/fork-remote.png","path":"images/git/fork-remote.png","modified":0,"renderable":0},{"_id":"themes/bear/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/index.js","path":"script/index.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/jquery.min.js","path":"script/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/post.js","path":"script/post.js","modified":0,"renderable":1},{"_id":"themes/bear/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/bear/source/images/check.svg","path":"images/check.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/styles/site.styl","path":"styles/site.styl","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/email.svg","path":"images/socials/email.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/facebook.svg","path":"images/socials/facebook.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/flickr.svg","path":"images/socials/flickr.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/github.svg","path":"images/socials/github.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/google.svg","path":"images/socials/google.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/instagram.svg","path":"images/socials/instagram.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/weibo.svg","path":"images/socials/weibo.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/wechat.svg","path":"images/socials/wechat.svg","modified":0,"renderable":1},{"_id":"source/images/git/微信截图_20230327103738.png","path":"images/git/微信截图_20230327103738.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe1.png","path":"images/go/pipe/pipe1.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe2.png","path":"images/go/pipe/pipe2.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe3.png","path":"images/go/pipe/pipe3.png","modified":0,"renderable":0},{"_id":"source/images/redis/key.png","path":"images/redis/key.png","modified":0,"renderable":0},{"_id":"source/images/redis/list.png","path":"images/redis/list.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/git/fork.md","hash":"e990bf2ff8a92e98eda2478f99edb1ec2220c2dc","modified":1680404635028},{"_id":"source/_posts/docker.md","hash":"ce8b0c16786890df364ac6a7acd403d73a7923c2","modified":1680404635028},{"_id":"source/_posts/go/log.md","hash":"c04451fe35360e5c61d7c3aa8dc2c50777f56432","modified":1680404635028},{"_id":"source/images/docker/dockerfile.png","hash":"43920921835d74aba2c1ed6c96c2e1ec5acbb0c3","modified":1678096841936},{"_id":"source/images/git/fork-remote.png","hash":"4fc4ff99088c23b165d4e628efd7a8e3360c306a","modified":1678414964117},{"_id":"themes/bear/.gitignore","hash":"1dd2ae02fedda3f81d3cc97d8b6a9279c34f18fb","modified":1677829317036},{"_id":"themes/bear/.DS_Store","hash":"83d7e57752db294868ca1b7c368b619f29c951ae","modified":1677829317036},{"_id":"themes/bear/README.md","hash":"df9ab18cad20f2a189ccc6c5082a9250ddbb5ee0","modified":1677829317036},{"_id":"themes/bear/_config.yml","hash":"e7cf37c67e525e34f8685b5ac772dbd24ccf1ab0","modified":1678240819358},{"_id":"themes/bear/package.json","hash":"05f5e28a3ed6ca24f34ecebb60de3c8281209be4","modified":1680524824542},{"_id":"themes/bear/_partial/aboutme.pug","hash":"f5b14bf80997bd398f746c0e7072a8ab5e1c767a","modified":1678240033568},{"_id":"themes/bear/_partial/footer.pug","hash":"b72a17a470dbe10bd291c4fd9f0545278b6599f5","modified":1677829317036},{"_id":"themes/bear/_partial/header.pug","hash":"03bf88c5654f3071a757cb817ea794e9a2e09924","modified":1678241709288},{"_id":"themes/bear/_partial/google-analytics.pug","hash":"c75e26872935030e2a7c7846f43e3bbf0b43a9ff","modified":1677829317036},{"_id":"themes/bear/_partial/layout.pug","hash":"db695bce2f7d7af9ded4818e4d183bfb26fa8dbe","modified":1678240070291},{"_id":"themes/bear/_partial/post_footer.pug","hash":"30127766cc23fcb74cc2064ab8f06df1aa3a717f","modified":1677829317036},{"_id":"themes/bear/layout/archive.pug","hash":"ac61917e785e06c9e715472f7fc58a7fb4aee7e7","modified":1678240694143},{"_id":"themes/bear/layout/index.pug","hash":"6747a6a707dcbd765f42a38b5593fe7c1384eddb","modified":1677829317036},{"_id":"themes/bear/layout/post.pug","hash":"cbe3d59af0b8486dfc63f53d3982ac4c4db307f7","modified":1677829317036},{"_id":"themes/bear/source/.DS_Store","hash":"a533b17b008db177bb92835a7fadb3012f268058","modified":1677829317036},{"_id":"themes/bear/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1677829317036},{"_id":"themes/bear/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1677829317036},{"_id":"themes/bear/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1677829317051},{"_id":"themes/bear/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1677829317051},{"_id":"themes/bear/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1677829317052},{"_id":"themes/bear/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1677829317052},{"_id":"themes/bear/source/script/index.js","hash":"6cb1c4f7bf44d8fb4a4af7fd260d39c0439daadc","modified":1677829317052},{"_id":"themes/bear/source/script/post.js","hash":"6b057a9ae5bc7d06cc67110f9651a77ed2fe8046","modified":1677829317052},{"_id":"themes/bear/source/images/check.svg","hash":"9e891aa1036fdeaf556d50854bb70a0d7175724b","modified":1677829317052},{"_id":"themes/bear/source/images/avatar.png","hash":"a7c68a10d1a1357e4ec55891fc8a22d744b653d2","modified":1677829317052},{"_id":"themes/bear/source/styles/_extend.styl","hash":"82ab5ec19935d3a1cb3022f5f5c245f6ff7efe03","modified":1677829317052},{"_id":"themes/bear/source/styles/_variables.styl","hash":"283c80570908bf83b0efd6ae1f524699eb5036a2","modified":1677829317052},{"_id":"themes/bear/source/styles/site.styl","hash":"1ff8e1d4f8777c3d918824fa134830476de79f51","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1677829317052},{"_id":"themes/bear/source/images/socials/email.svg","hash":"866629becff21ec0d0bfc5980937c0a973e04c15","modified":1677829317052},{"_id":"themes/bear/source/images/socials/facebook.svg","hash":"cc023ecafafda29e079736b2e287e9bcd32a9e0f","modified":1677829317052},{"_id":"themes/bear/source/images/socials/flickr.svg","hash":"5cb21fb6aa9295f97010ba434171d5222a706c36","modified":1677829317052},{"_id":"themes/bear/source/images/socials/github.svg","hash":"1dce3ba17c25257e195f6935d7cb227340fd3022","modified":1677829317052},{"_id":"themes/bear/source/images/socials/google.svg","hash":"47521c7f23b71fd55e1a19b81e23ab9373fc0225","modified":1677829317052},{"_id":"themes/bear/source/images/socials/instagram.svg","hash":"4cc77b3b2c2118b9e24b91a02e370dbc8456d24c","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/aboutme.styl","hash":"1622faeaa3c410878fcd1f7f9988c5230accc307","modified":1677829317052},{"_id":"themes/bear/source/images/socials/weibo.svg","hash":"afc8e42094cd45aaca15c243caaf337968ec426d","modified":1677829317052},{"_id":"themes/bear/source/images/socials/wechat.svg","hash":"5524c7d161217e60f5dab9939f5475782fa314a2","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/article.styl","hash":"961969a243fbbab4a5b6a0a908222e940b781f2a","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/archive.styl","hash":"40692d9092f7e158465a79771d04fe3a8ec4bf72","modified":1678523083600},{"_id":"themes/bear/source/styles/_partial/header.styl","hash":"d706f703001406b4991e86839b9624e7d64acd5e","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/highlight.styl","hash":"a7bd88c9fd067403f9fdfe69b0de992f364fe2e8","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/theme.styl","hash":"7d089d66ec5b05e0f0ea0a15ce09e9379818a350","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/footer.styl","hash":"480bc266846cc534bea0583a909a15cf01752c2c","modified":1677829317052},{"_id":"source/images/docker/container-options.png","hash":"73805ec4eead8fb2207f6b42260e9440d5f2a2b4","modified":1678059380567},{"_id":"source/images/docker/container-command.png","hash":"0743524fd1c2aa7e5143a199a46e548e833cc015","modified":1678060431357},{"_id":"themes/bear/source/script/jquery.min.js","hash":"745ab5d6e434cf8d321779da3c527b6d301e2b50","modified":1677829317052},{"_id":"themes/bear/package-lock.json","hash":"2333a1f3c896e122e9e039e82a92ed57fdb6ab42","modified":1677829317036},{"_id":"themes/bear/screenshot.jpg","hash":"a5a295578ab8e324257f5618e41397c91403db5a","modified":1677829317036},{"_id":"source/images/docker/composition.png","hash":"6abb4f461eeaac697f9cb09bc2cc5dc6cf94acea","modified":1677835017810},{"_id":"themes/bear/pnpm-lock.yaml","hash":"5db239a8f0479833816e5a6dfee24fdcdd8f237f","modified":1680524824543},{"_id":"themes/bear/screenshot2.jpg","hash":"56a02cf741ea2673e175254ef9a4d02ef369a1f5","modified":1677829317036},{"_id":"public/2023/03/10/go/log/index.html","hash":"279441b7dd6c62b1065c5528a75dc94a267b75f6","modified":1680133894004},{"_id":"public/2023/03/10/git/fork/index.html","hash":"2846b02fea9c0ba785c8cd9175d22495e8230479","modified":1678523100229},{"_id":"public/archives/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/archives/2023/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/archives/2023/03/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/index.html","hash":"5ac275ee13033e8015967e75d9da298eb475cce3","modified":1680698734890},{"_id":"public/tags/web/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/docker/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/git/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/fork/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/go/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/gorus/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/rotatelogs/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/ifshook/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/2023/03/03/docker/index.html","hash":"ad8e759400dbc0457b3659dd577391d92d0ed635","modified":1678523100229},{"_id":"public/images/git/fork-remote.png","hash":"4fc4ff99088c23b165d4e628efd7a8e3360c306a","modified":1678523100229},{"_id":"public/images/docker/dockerfile.png","hash":"43920921835d74aba2c1ed6c96c2e1ec5acbb0c3","modified":1678523100229},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1680698734890},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1680698734890},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1680698734890},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1680698734890},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1680698734890},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1680698734890},{"_id":"public/images/avatar.png","hash":"a7c68a10d1a1357e4ec55891fc8a22d744b653d2","modified":1680698734890},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1680698734890},{"_id":"public/images/socials/email.svg","hash":"866629becff21ec0d0bfc5980937c0a973e04c15","modified":1680698734890},{"_id":"public/images/check.svg","hash":"9e891aa1036fdeaf556d50854bb70a0d7175724b","modified":1680698734890},{"_id":"public/images/socials/facebook.svg","hash":"cc023ecafafda29e079736b2e287e9bcd32a9e0f","modified":1680698734890},{"_id":"public/images/socials/flickr.svg","hash":"5cb21fb6aa9295f97010ba434171d5222a706c36","modified":1680698734890},{"_id":"public/images/socials/github.svg","hash":"1dce3ba17c25257e195f6935d7cb227340fd3022","modified":1680698734890},{"_id":"public/images/socials/google.svg","hash":"47521c7f23b71fd55e1a19b81e23ab9373fc0225","modified":1680698734890},{"_id":"public/images/socials/instagram.svg","hash":"4cc77b3b2c2118b9e24b91a02e370dbc8456d24c","modified":1680698734890},{"_id":"public/images/socials/weibo.svg","hash":"afc8e42094cd45aaca15c243caaf337968ec426d","modified":1680698734890},{"_id":"public/images/socials/wechat.svg","hash":"5524c7d161217e60f5dab9939f5475782fa314a2","modified":1680698734890},{"_id":"public/images/docker/container-options.png","hash":"73805ec4eead8fb2207f6b42260e9440d5f2a2b4","modified":1678523100229},{"_id":"public/images/docker/composition.png","hash":"6abb4f461eeaac697f9cb09bc2cc5dc6cf94acea","modified":1678523100229},{"_id":"public/images/docker/container-command.png","hash":"0743524fd1c2aa7e5143a199a46e548e833cc015","modified":1678523100229},{"_id":"public/script/index.js","hash":"3be07c789aa4a521a31f3c59a98933ee9f8c85aa","modified":1680698734890},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1680698734890},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1680698734890},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1680698734890},{"_id":"public/script/post.js","hash":"ad6bdffb5a7f722f469e65c2061e56a434479de5","modified":1680698734890},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1680698734890},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1680698734890},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1680698734890},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1680698734890},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1680698734890},{"_id":"public/script/jquery.min.js","hash":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d","modified":1680698734890},{"_id":"public/styles/site.css","hash":"58fe37adeba5e0d30094e2770c0226caf229c100","modified":1680698734890},{"_id":"source/_posts/go/pipe.md","hash":"06018d827fae22bd83ffe45bbdc569667a8fbc17","modified":1680155837353},{"_id":"source/images/go/pipe/pipe1.png","hash":"0e88ba7c6a3d0f39d563bc877daf8505c8a0d90c","modified":1680068733330},{"_id":"source/images/go/pipe/pipe2.png","hash":"5c71c9d47d927e1ea9eb7567817c1366ceb6fb13","modified":1680070417150},{"_id":"source/images/go/pipe/pipe3.png","hash":"4f16d115f18c33bbbf9a97c25f07b28cad550c8a","modified":1680072633426},{"_id":"source/images/git/微信截图_20230327103738.png","hash":"4ea65f1b32bc8902d3ede33a308fb76376e85caa","modified":1679884660542},{"_id":"public/tags/pipe/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/channel/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/2023/03/30/go/pipe/index.html","hash":"52955b9e983c728770f62abfb77af3ddd350f38c","modified":1680698734890},{"_id":"public/images/go/pipe/pipe1.png","hash":"0e88ba7c6a3d0f39d563bc877daf8505c8a0d90c","modified":1680133894004},{"_id":"public/images/git/微信截图_20230327103738.png","hash":"4ea65f1b32bc8902d3ede33a308fb76376e85caa","modified":1680133894004},{"_id":"public/images/go/pipe/pipe3.png","hash":"4f16d115f18c33bbbf9a97c25f07b28cad550c8a","modified":1680133894004},{"_id":"public/images/go/pipe/pipe2.png","hash":"5c71c9d47d927e1ea9eb7567817c1366ceb6fb13","modified":1680133894004},{"_id":"source/_posts/redis/base.md","hash":"29fb94499925b58e805feb9fe07f5606f03c0e9a","modified":1680698911140},{"_id":"source/images/redis/key.png","hash":"e494d047a966f0b5cd58cef1be661025bf8f7d07","modified":1680478303635},{"_id":"public/2023/04/02/redis/base/index.html","hash":"5380f48a4afb2fea038cf4bc5156bfad862ae9ee","modified":1680698929364},{"_id":"public/archives/2023/04/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/redis/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/string/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/list/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/hash/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/set/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/tags/zset/index.html","hash":"fdb7cbb90ea33f2c6f4d5d2ae6f5f5ef377a5a2c","modified":1680698734890},{"_id":"public/images/redis/key.png","hash":"e494d047a966f0b5cd58cef1be661025bf8f7d07","modified":1680478327157},{"_id":"source/images/redis/list.png","hash":"63773914754e857095905d551e46587f12cdf862","modified":1680565828991},{"_id":"public/images/redis/list.png","hash":"63773914754e857095905d551e46587f12cdf862","modified":1680698734890}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"前端开发者应该掌握的docker知识","date":"2023-03-03T09:01:39.000Z","excerpt":"身为前端开发者的我们应该怎样理解、掌握docker？","_content":"身为前端开发者的我们应该怎样理解、掌握docker？\n### docker的基本组成\nDocker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。![平台架构图-基础版](/images/docker/composition.png)\n#### 镜像（image）\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。\n它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”\n#### 容器（container）\nDocker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.\n#### 仓库（respository）\n仓库（Repository）是集中存放镜像文件的场所。\n\n### 下载\n1.[官网地址](https://www.docker.com/)\n2.[仓库地址](https://hub.docker.com/)\n\n### 基本命令\n1. 启动docker\n```bash\nsystemctl start docker\n```\n2. 停止docker\n```bash\nsystemctl stop docker\n```\n3. 重启docker\n```bash\nsystemctl restart docker\n```\n4. 查看docker状态\n```bash\nsystemctl status docker\n```\n5. 开机启动\n```bash\nsystemctl enable docker\n```\n6. 查看docker概要信息\n```bash\ndocker info\n```\n7. 帮助命令\n```bash\n# 查看总体帮助\ndocker help\n# 查看具体命令帮助\ndocker 命令 --help\n```\n### 镜像常用命令\n1. 查看本地镜像\n```bash\ndocker images [options]\n\noptions:\n-a 列出本地所有镜像\n-q 只显示镜像ID\n```\n2. 查找镜像\n```bash\ndocker search [options] 镜像名称\n\noptions:\n--limit N 列出n个\n```\n3. 拉取镜像\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker pull 镜像名称[:tag] \n```\n4. 查看镜像/容器/数据卷所占的空间\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker system df\n```\n5. 镜像删除\n```bash\n# 删除某个镜像\ndocker rmi -f 镜像ID\n\n# 删除多个镜像\ndocker rmi -f 镜像名1:tag 镜像名2:tag\n\n# 删除全部\ndocker rmi -f ${docker images -qa}\n```\n6. 提交容器副本使之成为新的镜像\n```bash\ndocker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]\n```\n7. 将指定镜像保存成 tar 归档文件\n```bash\ndocker save [OPTIONS] IMAGE [IMAGE...]\n\nOPTIONS：\n-o :输出到的文件\n```\n8. 导入使用 docker save 命令导出的镜像\n```bash\ndocker load [OPTIONS]\n举例 docker load < 镜像文件名\n\nOPTIONS：\n--input , -i : 指定导入的文件，代替 STDIN\n--quiet , -q : 精简输出信息\n```\n### 容器常用命令\n1. 新建/启动容器\n```bash\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...] \n\nOPTIONS:有些是一个减号有些是两个减号\n--name=\"容器新名字\" 为容器指定一个名称\n-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)\n-i：以交互模式运行容器，通常与 -t 同时使用\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)\n-P: 随机端口映射，大写P\n-p: 指定端口映射，小写p\n```\n![container-options](/images/docker/container-options.png)\n2. 列出当前正在运行的容器\n```bash\ndocker ps [OPTIONS]\n\nOPTIONS:\n-a :列出当前所有正在运行的容器+历史上运行过的\n-l :显示最近创建的容器\n-n :显示最近n个创建的容器\n-q :静默模式，只显示容器编号\n```\n3. 退出容器\n```bash\nexit run进入exit退出 容器停止\nctrl+p+q run进入ctrl+p+q退出 容器不停止\n```\n4. 启动已停止运行的容器\n```bash\ndocker start 容器ID/容器name\n```\n5. 重启容器\n```bash\ndocker restart 容器ID/容器name\n```\n6. 停止容器\n```bash\ndocker stop 容器ID/容器name\n```\n7. 强制停止容器\n```bash\ndocker kill 容器ID/容器name\n```\n8. 删除已停止的容器\n```bash\ndocker rm 容器ID/容器name\n```\n9. 启动守护式容器（后台服务器）\n```bash\ndocker run -it -d 容器ID\n```\n10. 查看容器日志\n```bash\ndocker logs 容器ID\n#跟踪查看最近100条日志\ndocker logs -f -n100\n```\n11. 查看容器内运行的进程\n```bash\ndocker top 容器ID\n```\n12. 查看容器内部细节\n```bash\ndocker inspect 容器ID\n```\n13. 进入正在运行的容器并以命令行交互\n```bash\ndocker exec -it 容器ID /bin/bash\n```\n14. 从容器内拷贝文件到主机上\n```bash\ndocker cp 容器id:容器内路径 宿主机路径\n```\n\n15. 常用命令总结\n![container-command](/images/docker/container-command.png)\n```bash\nattach    # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     # 通过 Dockerfile 定制镜像\n\ncommit    # 提交当前容器为新的镜像\n\ncp        #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    # 创建一个新的容器，同 run，但不启动容器\n\ndiff      # 查看 docker 容器变化\n\nevents    # 从 docker 服务获取容器实时事件\n\nexec      # 在已存在的容器上运行命令\n\nexport    # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   # 展示一个镜像形成历史\n\nimages    # 列出系统当前镜像\n\nimport    # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      # 显示系统相关信息\n\ninspect   # 查看容器详细信息\n\nkill      # kill 指定 docker 容器\n\nload      # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     # 注册或者登陆一个 docker 源服务器\n\nlogout    # 从当前 Docker registry 退出\n\nlogs      # 输出当前容器日志信息\n\nport      # 查看映射端口对应的容器内部源端口\n\npause     # 暂停容器\n\nps        # 列出容器列表\n\npull      # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   # 重启运行的容器\n\nrm        # 移除一个或者多个容器\n\nrmi       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       # 创建一个新的容器并运行一个命令\n\nsave      # 保存一个镜像为一个 tar 包[对应 load]\n\nsearch    # 在 docker hub 中搜索镜像\n\nstart     # 启动容器\n\nstop      # 停止容器\n\ntag       # 给源中镜像打标签\n\ntop       # 查看容器中运行的进程信息\n\nunpause   # 取消暂停容器\n\nversion   # 查看 docker 版本号\n\nwait      # 截取容器停止时的退出状态值\n```\n\n### 容器数据卷\n将docker容器中的数据保存到宿主机的磁盘中\n```bash\n# 一定要带上--privileged=true不然没有权限\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名\n```\n\n### DockerFile\nDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n#### DockerFile基础说明\n- 每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n- 指令按照顺序，从上到下顺序执行\n- #表示注释\n- 每条指令都会创建一个新的镜像层并对镜像进行提交\n\n#### docker执行DockerFile流程\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器进行修改\n3. 执行类似docker commit的操作提交一个新的镜像层\n4. docker再基于刚提交的镜像运行一个新容器\n5. 执行docker中的下一条指令直至所有指令完成\n\n#### 常用保留字指令\n1. FROM： 基础镜像\n2. MAINTAINER： 镜像维护者姓名和邮箱\n3. RUN： docker build时需要运行的命令\n4. EXPOSE：当前容器对外暴露的端口\n5. WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\n6. USER：指定容器以什么样的用户去执行，默认root\n7. ENV：用来在构建镜像过程中设置环境变量\n8. ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包\n9. COPY：类似ADD拷贝文件和目录到镜像中\n10. VOLUME：容器数据卷用于保存数据和数据持久化\n11. CMD：指定容器启动后要干的事情\n12. ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序\n![](/images/docker/dockerfile.png)","source":"_posts/docker.md","raw":"---\ntitle: 前端开发者应该掌握的docker知识\ndate: 2023-03-03 17:01:39\ntags: ['web','docker']\nexcerpt: 身为前端开发者的我们应该怎样理解、掌握docker？\n---\n身为前端开发者的我们应该怎样理解、掌握docker？\n### docker的基本组成\nDocker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。![平台架构图-基础版](/images/docker/composition.png)\n#### 镜像（image）\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。\n它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”\n#### 容器（container）\nDocker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.\n#### 仓库（respository）\n仓库（Repository）是集中存放镜像文件的场所。\n\n### 下载\n1.[官网地址](https://www.docker.com/)\n2.[仓库地址](https://hub.docker.com/)\n\n### 基本命令\n1. 启动docker\n```bash\nsystemctl start docker\n```\n2. 停止docker\n```bash\nsystemctl stop docker\n```\n3. 重启docker\n```bash\nsystemctl restart docker\n```\n4. 查看docker状态\n```bash\nsystemctl status docker\n```\n5. 开机启动\n```bash\nsystemctl enable docker\n```\n6. 查看docker概要信息\n```bash\ndocker info\n```\n7. 帮助命令\n```bash\n# 查看总体帮助\ndocker help\n# 查看具体命令帮助\ndocker 命令 --help\n```\n### 镜像常用命令\n1. 查看本地镜像\n```bash\ndocker images [options]\n\noptions:\n-a 列出本地所有镜像\n-q 只显示镜像ID\n```\n2. 查找镜像\n```bash\ndocker search [options] 镜像名称\n\noptions:\n--limit N 列出n个\n```\n3. 拉取镜像\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker pull 镜像名称[:tag] \n```\n4. 查看镜像/容器/数据卷所占的空间\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker system df\n```\n5. 镜像删除\n```bash\n# 删除某个镜像\ndocker rmi -f 镜像ID\n\n# 删除多个镜像\ndocker rmi -f 镜像名1:tag 镜像名2:tag\n\n# 删除全部\ndocker rmi -f ${docker images -qa}\n```\n6. 提交容器副本使之成为新的镜像\n```bash\ndocker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]\n```\n7. 将指定镜像保存成 tar 归档文件\n```bash\ndocker save [OPTIONS] IMAGE [IMAGE...]\n\nOPTIONS：\n-o :输出到的文件\n```\n8. 导入使用 docker save 命令导出的镜像\n```bash\ndocker load [OPTIONS]\n举例 docker load < 镜像文件名\n\nOPTIONS：\n--input , -i : 指定导入的文件，代替 STDIN\n--quiet , -q : 精简输出信息\n```\n### 容器常用命令\n1. 新建/启动容器\n```bash\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...] \n\nOPTIONS:有些是一个减号有些是两个减号\n--name=\"容器新名字\" 为容器指定一个名称\n-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)\n-i：以交互模式运行容器，通常与 -t 同时使用\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)\n-P: 随机端口映射，大写P\n-p: 指定端口映射，小写p\n```\n![container-options](/images/docker/container-options.png)\n2. 列出当前正在运行的容器\n```bash\ndocker ps [OPTIONS]\n\nOPTIONS:\n-a :列出当前所有正在运行的容器+历史上运行过的\n-l :显示最近创建的容器\n-n :显示最近n个创建的容器\n-q :静默模式，只显示容器编号\n```\n3. 退出容器\n```bash\nexit run进入exit退出 容器停止\nctrl+p+q run进入ctrl+p+q退出 容器不停止\n```\n4. 启动已停止运行的容器\n```bash\ndocker start 容器ID/容器name\n```\n5. 重启容器\n```bash\ndocker restart 容器ID/容器name\n```\n6. 停止容器\n```bash\ndocker stop 容器ID/容器name\n```\n7. 强制停止容器\n```bash\ndocker kill 容器ID/容器name\n```\n8. 删除已停止的容器\n```bash\ndocker rm 容器ID/容器name\n```\n9. 启动守护式容器（后台服务器）\n```bash\ndocker run -it -d 容器ID\n```\n10. 查看容器日志\n```bash\ndocker logs 容器ID\n#跟踪查看最近100条日志\ndocker logs -f -n100\n```\n11. 查看容器内运行的进程\n```bash\ndocker top 容器ID\n```\n12. 查看容器内部细节\n```bash\ndocker inspect 容器ID\n```\n13. 进入正在运行的容器并以命令行交互\n```bash\ndocker exec -it 容器ID /bin/bash\n```\n14. 从容器内拷贝文件到主机上\n```bash\ndocker cp 容器id:容器内路径 宿主机路径\n```\n\n15. 常用命令总结\n![container-command](/images/docker/container-command.png)\n```bash\nattach    # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     # 通过 Dockerfile 定制镜像\n\ncommit    # 提交当前容器为新的镜像\n\ncp        #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    # 创建一个新的容器，同 run，但不启动容器\n\ndiff      # 查看 docker 容器变化\n\nevents    # 从 docker 服务获取容器实时事件\n\nexec      # 在已存在的容器上运行命令\n\nexport    # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   # 展示一个镜像形成历史\n\nimages    # 列出系统当前镜像\n\nimport    # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      # 显示系统相关信息\n\ninspect   # 查看容器详细信息\n\nkill      # kill 指定 docker 容器\n\nload      # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     # 注册或者登陆一个 docker 源服务器\n\nlogout    # 从当前 Docker registry 退出\n\nlogs      # 输出当前容器日志信息\n\nport      # 查看映射端口对应的容器内部源端口\n\npause     # 暂停容器\n\nps        # 列出容器列表\n\npull      # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   # 重启运行的容器\n\nrm        # 移除一个或者多个容器\n\nrmi       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       # 创建一个新的容器并运行一个命令\n\nsave      # 保存一个镜像为一个 tar 包[对应 load]\n\nsearch    # 在 docker hub 中搜索镜像\n\nstart     # 启动容器\n\nstop      # 停止容器\n\ntag       # 给源中镜像打标签\n\ntop       # 查看容器中运行的进程信息\n\nunpause   # 取消暂停容器\n\nversion   # 查看 docker 版本号\n\nwait      # 截取容器停止时的退出状态值\n```\n\n### 容器数据卷\n将docker容器中的数据保存到宿主机的磁盘中\n```bash\n# 一定要带上--privileged=true不然没有权限\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名\n```\n\n### DockerFile\nDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n#### DockerFile基础说明\n- 每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n- 指令按照顺序，从上到下顺序执行\n- #表示注释\n- 每条指令都会创建一个新的镜像层并对镜像进行提交\n\n#### docker执行DockerFile流程\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器进行修改\n3. 执行类似docker commit的操作提交一个新的镜像层\n4. docker再基于刚提交的镜像运行一个新容器\n5. 执行docker中的下一条指令直至所有指令完成\n\n#### 常用保留字指令\n1. FROM： 基础镜像\n2. MAINTAINER： 镜像维护者姓名和邮箱\n3. RUN： docker build时需要运行的命令\n4. EXPOSE：当前容器对外暴露的端口\n5. WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\n6. USER：指定容器以什么样的用户去执行，默认root\n7. ENV：用来在构建镜像过程中设置环境变量\n8. ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包\n9. COPY：类似ADD拷贝文件和目录到镜像中\n10. VOLUME：容器数据卷用于保存数据和数据持久化\n11. CMD：指定容器启动后要干的事情\n12. ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序\n![](/images/docker/dockerfile.png)","slug":"docker","published":1,"updated":"2023-04-02T03:03:55.028Z","_id":"clf3pbdo000007oup0pwta5mc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>身为前端开发者的我们应该怎样理解、掌握docker？</p>\n<h3 id=\"docker的基本组成\"><a href=\"#docker的基本组成\" class=\"headerlink\" title=\"docker的基本组成\"></a>docker的基本组成</h3><p>Docker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。<img src=\"/blog/images/docker/composition.png\" alt=\"平台架构图-基础版\"></p>\n<h4 id=\"镜像（image）\"><a href=\"#镜像（image）\" class=\"headerlink\" title=\"镜像（image）\"></a>镜像（image）</h4><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。<br>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”</p>\n<h4 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h4><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.</p>\n<h4 id=\"仓库（respository）\"><a href=\"#仓库（respository）\" class=\"headerlink\" title=\"仓库（respository）\"></a>仓库（respository）</h4><p>仓库（Repository）是集中存放镜像文件的场所。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>1.<a href=\"https://www.docker.com/\">官网地址</a><br>2.<a href=\"https://hub.docker.com/\">仓库地址</a></p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ol>\n<li>启动docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure></li>\n<li>停止docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop docker</span><br></pre></td></tr></table></figure></li>\n<li>重启docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker状态<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker</span><br></pre></td></tr></table></figure></li>\n<li>开机启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker概要信息<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure></li>\n<li>帮助命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看总体帮助</span></span><br><span class=\"line\">docker <span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\"># 查看具体命令帮助</span></span><br><span class=\"line\">docker 命令 --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"镜像常用命令\"><a href=\"#镜像常用命令\" class=\"headerlink\" title=\"镜像常用命令\"></a>镜像常用命令</h3><ol>\n<li>查看本地镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images [options]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-a 列出本地所有镜像</span><br><span class=\"line\">-q 只显示镜像ID</span><br></pre></td></tr></table></figure></li>\n<li>查找镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search [options] 镜像名称</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">--<span class=\"built_in\">limit</span> N 列出n个</span><br></pre></td></tr></table></figure></li>\n<li>拉取镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker pull 镜像名称[:tag] </span><br></pre></td></tr></table></figure></li>\n<li>查看镜像&#x2F;容器&#x2F;数据卷所占的空间<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker system <span class=\"built_in\">df</span></span><br></pre></td></tr></table></figure></li>\n<li>镜像删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除某个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像ID</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除多个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像名1:tag 镜像名2:tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除全部</span></span><br><span class=\"line\">docker rmi -f <span class=\"variable\">$&#123;docker images -qa&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>提交容器副本使之成为新的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure></li>\n<li>将指定镜像保存成 tar 归档文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">-o :输出到的文件</span><br></pre></td></tr></table></figure></li>\n<li>导入使用 docker save 命令导出的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load [OPTIONS]</span><br><span class=\"line\">举例 docker load &lt; 镜像文件名</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">--input , -i : 指定导入的文件，代替 STDIN</span><br><span class=\"line\">--quiet , -q : 精简输出信息</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器常用命令\"><a href=\"#容器常用命令\" class=\"headerlink\" title=\"容器常用命令\"></a>容器常用命令</h3><ol>\n<li><p>新建&#x2F;启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...] </span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:有些是一个减号有些是两个减号</span><br><span class=\"line\">--name=<span class=\"string\">&quot;容器新名字&quot;</span> 为容器指定一个名称</span><br><span class=\"line\">-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)</span><br><span class=\"line\">-i：以交互模式运行容器，通常与 -t 同时使用</span><br><span class=\"line\">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)</span><br><span class=\"line\">-P: 随机端口映射，大写P</span><br><span class=\"line\">-p: 指定端口映射，小写p</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/docker/container-options.png\" alt=\"container-options\"></p>\n</li>\n<li><p>列出当前正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:</span><br><span class=\"line\">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class=\"line\">-l :显示最近创建的容器</span><br><span class=\"line\">-n :显示最近n个创建的容器</span><br><span class=\"line\">-q :静默模式，只显示容器编号</span><br></pre></td></tr></table></figure></li>\n<li><p>退出容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exit</span> run进入<span class=\"built_in\">exit</span>退出 容器停止</span><br><span class=\"line\">ctrl+p+q run进入ctrl+p+q退出 容器不停止</span><br></pre></td></tr></table></figure></li>\n<li><p>启动已停止运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>重启容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>强制停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">kill</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>删除已停止的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>启动守护式容器（后台服务器）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -d 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker logs 容器ID</span><br><span class=\"line\"><span class=\"comment\">#跟踪查看最近100条日志</span></span><br><span class=\"line\">docker logs -f -n100</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内运行的进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker top 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内部细节</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>进入正在运行的容器并以命令行交互</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure></li>\n<li><p>从容器内拷贝文件到主机上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">cp</span> 容器<span class=\"built_in\">id</span>:容器内路径 宿主机路径</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用命令总结<br><img src=\"/blog/images/docker/container-command.png\" alt=\"container-command\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attach    <span class=\"comment\"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">build     <span class=\"comment\"># 通过 Dockerfile 定制镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit    <span class=\"comment\"># 提交当前容器为新的镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span>        <span class=\"comment\">#从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class=\"line\"></span><br><span class=\"line\">create    <span class=\"comment\"># 创建一个新的容器，同 run，但不启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">diff      <span class=\"comment\"># 查看 docker 容器变化</span></span><br><span class=\"line\"></span><br><span class=\"line\">events    <span class=\"comment\"># 从 docker 服务获取容器实时事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exec</span>      <span class=\"comment\"># 在已存在的容器上运行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span>    <span class=\"comment\"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">history</span>   <span class=\"comment\"># 展示一个镜像形成历史</span></span><br><span class=\"line\"></span><br><span class=\"line\">images    <span class=\"comment\"># 列出系统当前镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">import    <span class=\"comment\"># 从tar包中的内容创建一个新的文件系统映像[对应export]</span></span><br><span class=\"line\"></span><br><span class=\"line\">info      <span class=\"comment\"># 显示系统相关信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">inspect   <span class=\"comment\"># 查看容器详细信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span>      <span class=\"comment\"># kill 指定 docker 容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">load      <span class=\"comment\"># 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class=\"line\"></span><br><span class=\"line\">login     <span class=\"comment\"># 注册或者登陆一个 docker 源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">logout</span>    <span class=\"comment\"># 从当前 Docker registry 退出</span></span><br><span class=\"line\"></span><br><span class=\"line\">logs      <span class=\"comment\"># 输出当前容器日志信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">port      <span class=\"comment\"># 查看映射端口对应的容器内部源端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">pause     <span class=\"comment\"># 暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">ps        <span class=\"comment\"># 列出容器列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">pull      <span class=\"comment\"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">push      <span class=\"comment\"># 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\">restart   <span class=\"comment\"># 重启运行的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rm</span>        <span class=\"comment\"># 移除一个或者多个容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">rmi       <span class=\"comment\"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class=\"line\"></span><br><span class=\"line\">run       <span class=\"comment\"># 创建一个新的容器并运行一个命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">save      <span class=\"comment\"># 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class=\"line\"></span><br><span class=\"line\">search    <span class=\"comment\"># 在 docker hub 中搜索镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">start     <span class=\"comment\"># 启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">stop      <span class=\"comment\"># 停止容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">tag       <span class=\"comment\"># 给源中镜像打标签</span></span><br><span class=\"line\"></span><br><span class=\"line\">top       <span class=\"comment\"># 查看容器中运行的进程信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">unpause   <span class=\"comment\"># 取消暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">version   <span class=\"comment\"># 查看 docker 版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">wait</span>      <span class=\"comment\"># 截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h3><p>将docker容器中的数据保存到宿主机的磁盘中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一定要带上--privileged=true不然没有权限</span></span><br><span class=\"line\">docker run -it --privileged=<span class=\"literal\">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h3><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<h4 id=\"DockerFile基础说明\"><a href=\"#DockerFile基础说明\" class=\"headerlink\" title=\"DockerFile基础说明\"></a>DockerFile基础说明</h4><ul>\n<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>\n<li>指令按照顺序，从上到下顺序执行</li>\n<li>#表示注释</li>\n<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>\n</ul>\n<h4 id=\"docker执行DockerFile流程\"><a href=\"#docker执行DockerFile流程\" class=\"headerlink\" title=\"docker执行DockerFile流程\"></a>docker执行DockerFile流程</h4><ol>\n<li>docker从基础镜像运行一个容器</li>\n<li>执行一条指令并对容器进行修改</li>\n<li>执行类似docker commit的操作提交一个新的镜像层</li>\n<li>docker再基于刚提交的镜像运行一个新容器</li>\n<li>执行docker中的下一条指令直至所有指令完成</li>\n</ol>\n<h4 id=\"常用保留字指令\"><a href=\"#常用保留字指令\" class=\"headerlink\" title=\"常用保留字指令\"></a>常用保留字指令</h4><ol>\n<li>FROM： 基础镜像</li>\n<li>MAINTAINER： 镜像维护者姓名和邮箱</li>\n<li>RUN： docker build时需要运行的命令</li>\n<li>EXPOSE：当前容器对外暴露的端口</li>\n<li>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</li>\n<li>USER：指定容器以什么样的用户去执行，默认root</li>\n<li>ENV：用来在构建镜像过程中设置环境变量</li>\n<li>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li>\n<li>COPY：类似ADD拷贝文件和目录到镜像中</li>\n<li>VOLUME：容器数据卷用于保存数据和数据持久化</li>\n<li>CMD：指定容器启动后要干的事情</li>\n<li>ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序<br><img src=\"/blog/images/docker/dockerfile.png\"></li>\n</ol>\n","site":{"data":{}},"more":"<p>身为前端开发者的我们应该怎样理解、掌握docker？</p>\n<h3 id=\"docker的基本组成\"><a href=\"#docker的基本组成\" class=\"headerlink\" title=\"docker的基本组成\"></a>docker的基本组成</h3><p>Docker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。<img src=\"/blog/images/docker/composition.png\" alt=\"平台架构图-基础版\"></p>\n<h4 id=\"镜像（image）\"><a href=\"#镜像（image）\" class=\"headerlink\" title=\"镜像（image）\"></a>镜像（image）</h4><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。<br>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”</p>\n<h4 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h4><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.</p>\n<h4 id=\"仓库（respository）\"><a href=\"#仓库（respository）\" class=\"headerlink\" title=\"仓库（respository）\"></a>仓库（respository）</h4><p>仓库（Repository）是集中存放镜像文件的场所。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>1.<a href=\"https://www.docker.com/\">官网地址</a><br>2.<a href=\"https://hub.docker.com/\">仓库地址</a></p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ol>\n<li>启动docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure></li>\n<li>停止docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop docker</span><br></pre></td></tr></table></figure></li>\n<li>重启docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker状态<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker</span><br></pre></td></tr></table></figure></li>\n<li>开机启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker概要信息<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure></li>\n<li>帮助命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看总体帮助</span></span><br><span class=\"line\">docker <span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\"># 查看具体命令帮助</span></span><br><span class=\"line\">docker 命令 --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"镜像常用命令\"><a href=\"#镜像常用命令\" class=\"headerlink\" title=\"镜像常用命令\"></a>镜像常用命令</h3><ol>\n<li>查看本地镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images [options]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-a 列出本地所有镜像</span><br><span class=\"line\">-q 只显示镜像ID</span><br></pre></td></tr></table></figure></li>\n<li>查找镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search [options] 镜像名称</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">--<span class=\"built_in\">limit</span> N 列出n个</span><br></pre></td></tr></table></figure></li>\n<li>拉取镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker pull 镜像名称[:tag] </span><br></pre></td></tr></table></figure></li>\n<li>查看镜像&#x2F;容器&#x2F;数据卷所占的空间<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker system <span class=\"built_in\">df</span></span><br></pre></td></tr></table></figure></li>\n<li>镜像删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除某个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像ID</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除多个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像名1:tag 镜像名2:tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除全部</span></span><br><span class=\"line\">docker rmi -f <span class=\"variable\">$&#123;docker images -qa&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>提交容器副本使之成为新的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure></li>\n<li>将指定镜像保存成 tar 归档文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">-o :输出到的文件</span><br></pre></td></tr></table></figure></li>\n<li>导入使用 docker save 命令导出的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load [OPTIONS]</span><br><span class=\"line\">举例 docker load &lt; 镜像文件名</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">--input , -i : 指定导入的文件，代替 STDIN</span><br><span class=\"line\">--quiet , -q : 精简输出信息</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器常用命令\"><a href=\"#容器常用命令\" class=\"headerlink\" title=\"容器常用命令\"></a>容器常用命令</h3><ol>\n<li><p>新建&#x2F;启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...] </span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:有些是一个减号有些是两个减号</span><br><span class=\"line\">--name=<span class=\"string\">&quot;容器新名字&quot;</span> 为容器指定一个名称</span><br><span class=\"line\">-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)</span><br><span class=\"line\">-i：以交互模式运行容器，通常与 -t 同时使用</span><br><span class=\"line\">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)</span><br><span class=\"line\">-P: 随机端口映射，大写P</span><br><span class=\"line\">-p: 指定端口映射，小写p</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/docker/container-options.png\" alt=\"container-options\"></p>\n</li>\n<li><p>列出当前正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:</span><br><span class=\"line\">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class=\"line\">-l :显示最近创建的容器</span><br><span class=\"line\">-n :显示最近n个创建的容器</span><br><span class=\"line\">-q :静默模式，只显示容器编号</span><br></pre></td></tr></table></figure></li>\n<li><p>退出容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exit</span> run进入<span class=\"built_in\">exit</span>退出 容器停止</span><br><span class=\"line\">ctrl+p+q run进入ctrl+p+q退出 容器不停止</span><br></pre></td></tr></table></figure></li>\n<li><p>启动已停止运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>重启容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>强制停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">kill</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>删除已停止的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>启动守护式容器（后台服务器）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -d 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker logs 容器ID</span><br><span class=\"line\"><span class=\"comment\">#跟踪查看最近100条日志</span></span><br><span class=\"line\">docker logs -f -n100</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内运行的进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker top 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内部细节</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>进入正在运行的容器并以命令行交互</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure></li>\n<li><p>从容器内拷贝文件到主机上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">cp</span> 容器<span class=\"built_in\">id</span>:容器内路径 宿主机路径</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用命令总结<br><img src=\"/blog/images/docker/container-command.png\" alt=\"container-command\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attach    <span class=\"comment\"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">build     <span class=\"comment\"># 通过 Dockerfile 定制镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit    <span class=\"comment\"># 提交当前容器为新的镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span>        <span class=\"comment\">#从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class=\"line\"></span><br><span class=\"line\">create    <span class=\"comment\"># 创建一个新的容器，同 run，但不启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">diff      <span class=\"comment\"># 查看 docker 容器变化</span></span><br><span class=\"line\"></span><br><span class=\"line\">events    <span class=\"comment\"># 从 docker 服务获取容器实时事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exec</span>      <span class=\"comment\"># 在已存在的容器上运行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span>    <span class=\"comment\"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">history</span>   <span class=\"comment\"># 展示一个镜像形成历史</span></span><br><span class=\"line\"></span><br><span class=\"line\">images    <span class=\"comment\"># 列出系统当前镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">import    <span class=\"comment\"># 从tar包中的内容创建一个新的文件系统映像[对应export]</span></span><br><span class=\"line\"></span><br><span class=\"line\">info      <span class=\"comment\"># 显示系统相关信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">inspect   <span class=\"comment\"># 查看容器详细信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span>      <span class=\"comment\"># kill 指定 docker 容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">load      <span class=\"comment\"># 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class=\"line\"></span><br><span class=\"line\">login     <span class=\"comment\"># 注册或者登陆一个 docker 源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">logout</span>    <span class=\"comment\"># 从当前 Docker registry 退出</span></span><br><span class=\"line\"></span><br><span class=\"line\">logs      <span class=\"comment\"># 输出当前容器日志信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">port      <span class=\"comment\"># 查看映射端口对应的容器内部源端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">pause     <span class=\"comment\"># 暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">ps        <span class=\"comment\"># 列出容器列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">pull      <span class=\"comment\"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">push      <span class=\"comment\"># 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\">restart   <span class=\"comment\"># 重启运行的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rm</span>        <span class=\"comment\"># 移除一个或者多个容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">rmi       <span class=\"comment\"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class=\"line\"></span><br><span class=\"line\">run       <span class=\"comment\"># 创建一个新的容器并运行一个命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">save      <span class=\"comment\"># 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class=\"line\"></span><br><span class=\"line\">search    <span class=\"comment\"># 在 docker hub 中搜索镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">start     <span class=\"comment\"># 启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">stop      <span class=\"comment\"># 停止容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">tag       <span class=\"comment\"># 给源中镜像打标签</span></span><br><span class=\"line\"></span><br><span class=\"line\">top       <span class=\"comment\"># 查看容器中运行的进程信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">unpause   <span class=\"comment\"># 取消暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">version   <span class=\"comment\"># 查看 docker 版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">wait</span>      <span class=\"comment\"># 截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h3><p>将docker容器中的数据保存到宿主机的磁盘中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一定要带上--privileged=true不然没有权限</span></span><br><span class=\"line\">docker run -it --privileged=<span class=\"literal\">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h3><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<h4 id=\"DockerFile基础说明\"><a href=\"#DockerFile基础说明\" class=\"headerlink\" title=\"DockerFile基础说明\"></a>DockerFile基础说明</h4><ul>\n<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>\n<li>指令按照顺序，从上到下顺序执行</li>\n<li>#表示注释</li>\n<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>\n</ul>\n<h4 id=\"docker执行DockerFile流程\"><a href=\"#docker执行DockerFile流程\" class=\"headerlink\" title=\"docker执行DockerFile流程\"></a>docker执行DockerFile流程</h4><ol>\n<li>docker从基础镜像运行一个容器</li>\n<li>执行一条指令并对容器进行修改</li>\n<li>执行类似docker commit的操作提交一个新的镜像层</li>\n<li>docker再基于刚提交的镜像运行一个新容器</li>\n<li>执行docker中的下一条指令直至所有指令完成</li>\n</ol>\n<h4 id=\"常用保留字指令\"><a href=\"#常用保留字指令\" class=\"headerlink\" title=\"常用保留字指令\"></a>常用保留字指令</h4><ol>\n<li>FROM： 基础镜像</li>\n<li>MAINTAINER： 镜像维护者姓名和邮箱</li>\n<li>RUN： docker build时需要运行的命令</li>\n<li>EXPOSE：当前容器对外暴露的端口</li>\n<li>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</li>\n<li>USER：指定容器以什么样的用户去执行，默认root</li>\n<li>ENV：用来在构建镜像过程中设置环境变量</li>\n<li>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li>\n<li>COPY：类似ADD拷贝文件和目录到镜像中</li>\n<li>VOLUME：容器数据卷用于保存数据和数据持久化</li>\n<li>CMD：指定容器启动后要干的事情</li>\n<li>ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序<br><img src=\"/blog/images/docker/dockerfile.png\"></li>\n</ol>\n"},{"title":"fork之后的仓库如何同步源仓库的最新代码","date":"2023-03-10T01:38:28.000Z","excerpt":"git fork仓库之后， 源仓库代码进行了更新 fork后的仓库如何同步源仓库代码呢？","_content":"fork之后的仓库如何同步源仓库的最新代码\n\n1. 首先进入项目根目录运行`git remote -v`查看本地仓库的远程路径。\n2. 添加源仓库（上游仓库）的远程路径,命令格式`git remote add upstream ADDR`\n```git \ngit remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git\n```\n3. 查看源仓库（上游仓库）是否关联成功`git remote -v`。\n![git remote -v](/images/git/fork-remote.png)\n4. `git status`查看本事是否有代码没有commit，若有改动及时commit或者回滚。\n5. 执行`git fetch upstream`抓取源仓库（上游仓库）的最新代码。\n6. 执行`git merge upstream/master`命令合并master分支的代码。\n","source":"_posts/git/fork.md","raw":"---\ntitle: fork之后的仓库如何同步源仓库的最新代码\ndate: 2023-03-10 09:38:28\ntags: [\"git\", \"fork\"]\nexcerpt: git fork仓库之后， 源仓库代码进行了更新 fork后的仓库如何同步源仓库代码呢？\n---\nfork之后的仓库如何同步源仓库的最新代码\n\n1. 首先进入项目根目录运行`git remote -v`查看本地仓库的远程路径。\n2. 添加源仓库（上游仓库）的远程路径,命令格式`git remote add upstream ADDR`\n```git \ngit remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git\n```\n3. 查看源仓库（上游仓库）是否关联成功`git remote -v`。\n![git remote -v](/images/git/fork-remote.png)\n4. `git status`查看本事是否有代码没有commit，若有改动及时commit或者回滚。\n5. 执行`git fetch upstream`抓取源仓库（上游仓库）的最新代码。\n6. 执行`git merge upstream/master`命令合并master分支的代码。\n","slug":"git/fork","published":1,"updated":"2023-04-02T03:03:55.028Z","_id":"clf3pbdo800057oup2h3f97b9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>fork之后的仓库如何同步源仓库的最新代码</p>\n<ol>\n<li>首先进入项目根目录运行<code>git remote -v</code>查看本地仓库的远程路径。</li>\n<li>添加源仓库（上游仓库）的远程路径,命令格式<code>git remote add upstream ADDR</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git</span><br></pre></td></tr></table></figure></li>\n<li>查看源仓库（上游仓库）是否关联成功<code>git remote -v</code>。<br><img src=\"/blog/images/git/fork-remote.png\" alt=\"git remote -v\"></li>\n<li><code>git status</code>查看本事是否有代码没有commit，若有改动及时commit或者回滚。</li>\n<li>执行<code>git fetch upstream</code>抓取源仓库（上游仓库）的最新代码。</li>\n<li>执行<code>git merge upstream/master</code>命令合并master分支的代码。</li>\n</ol>\n","site":{"data":{}},"more":"<p>fork之后的仓库如何同步源仓库的最新代码</p>\n<ol>\n<li>首先进入项目根目录运行<code>git remote -v</code>查看本地仓库的远程路径。</li>\n<li>添加源仓库（上游仓库）的远程路径,命令格式<code>git remote add upstream ADDR</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git</span><br></pre></td></tr></table></figure></li>\n<li>查看源仓库（上游仓库）是否关联成功<code>git remote -v</code>。<br><img src=\"/blog/images/git/fork-remote.png\" alt=\"git remote -v\"></li>\n<li><code>git status</code>查看本事是否有代码没有commit，若有改动及时commit或者回滚。</li>\n<li>执行<code>git fetch upstream</code>抓取源仓库（上游仓库）的最新代码。</li>\n<li>执行<code>git merge upstream/master</code>命令合并master分支的代码。</li>\n</ol>\n"},{"title":"go 日志记录最佳实践","date":"2023-03-10T02:44:27.000Z","excerpt":"golang项目中使用gorus + rotatelogs + ifshook实现日志记录","_content":"- [logrus](https://github.com/sirupsen/logrus)是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。\n- [file-rotatelogs](https://github.com/lestrrat-go/file-rotatelogs)实现了 io.Writer 接口，并且提供了文件的切割功能。\n- [lfshook](https://github.com/rifflock/lfshook)决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT / JSON）。\n\n- 完整示例代码\n```golang\npackage pkg\n\nimport (\n\trotatelogs \"github.com/lestrrat-go/file-rotatelogs\"\n\t\"github.com/rifflock/lfshook\"\n\t\"github.com/sirupsen/logrus\"\n\t\"go-package/config\"\n\t\"os\"\n\t\"path\"\n\t\"time\"\n)\n\nvar (\n\tLogger      *logrus.Logger\n\tlogFileName string = \"server_log\"\n\tLocation, _        = time.LoadLocation(\"Asia/Shanghai\")\n)\n\nfunc InitLogger() {\n\t// 实例化logrus\n\tLogger = logrus.New()\n\t// 设置日志级别\n\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)\n\tif err != nil {\n\t\tlevel = logrus.InfoLevel\n\t}\n\tLogger.SetLevel(level)\n\n\tlogFileStat()\n\n\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)\n\t// 使用rotatelogs进行日志切割\n\tlogWriter, err := rotatelogs.New(\n\t\tfileName+\".%Y%m%d%H%M.log\",\n\t\t// 生成软链，指向最新日志文件\n\t\trotatelogs.WithLinkName(fileName),\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\tdebugWriter, err := rotatelogs.New(\n\t\tfileName+\"_debug\"+\".%Y%m%d%H%M.log\",\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\n\t// 使用lfshook设置不同类型日志进行不同的切割方式\n\twriteMap := lfshook.WriterMap{\n\t\tlogrus.InfoLevel:  logWriter,\n\t\tlogrus.FatalLevel: logWriter,\n\t\tlogrus.DebugLevel: debugWriter,\n\t\tlogrus.WarnLevel:  logWriter,\n\t\tlogrus.ErrorLevel: logWriter,\n\t\tlogrus.PanicLevel: logWriter,\n\t}\n\tLogger.AddHook(lfshook.NewHook(writeMap, &logrus.JSONFormatter{\n\t\tTimestampFormat: \"2006-01-02 15:04:05\",\n\t}))\n}\n\n/**\n * 检测日志文件是否存在\n */\nfunc logFileStat() {\n\tlogPath := path.Join(config.Cfg.Server.LogPath)\n\tif _, err := os.Stat(logPath); os.IsNotExist(err) {\n\t\tos.Mkdir(logPath, os.ModePerm)\n\t\tos.Chmod(logPath, 0755)\n\t}\n}\n```","source":"_posts/go/log.md","raw":"---\ntitle: go 日志记录最佳实践\ndate: 2023-03-10 10:44:27\ntags: [\"go\", \"gorus\", \"rotatelogs\", \"ifshook\"]\nexcerpt: golang项目中使用gorus + rotatelogs + ifshook实现日志记录\n---\n- [logrus](https://github.com/sirupsen/logrus)是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。\n- [file-rotatelogs](https://github.com/lestrrat-go/file-rotatelogs)实现了 io.Writer 接口，并且提供了文件的切割功能。\n- [lfshook](https://github.com/rifflock/lfshook)决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT / JSON）。\n\n- 完整示例代码\n```golang\npackage pkg\n\nimport (\n\trotatelogs \"github.com/lestrrat-go/file-rotatelogs\"\n\t\"github.com/rifflock/lfshook\"\n\t\"github.com/sirupsen/logrus\"\n\t\"go-package/config\"\n\t\"os\"\n\t\"path\"\n\t\"time\"\n)\n\nvar (\n\tLogger      *logrus.Logger\n\tlogFileName string = \"server_log\"\n\tLocation, _        = time.LoadLocation(\"Asia/Shanghai\")\n)\n\nfunc InitLogger() {\n\t// 实例化logrus\n\tLogger = logrus.New()\n\t// 设置日志级别\n\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)\n\tif err != nil {\n\t\tlevel = logrus.InfoLevel\n\t}\n\tLogger.SetLevel(level)\n\n\tlogFileStat()\n\n\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)\n\t// 使用rotatelogs进行日志切割\n\tlogWriter, err := rotatelogs.New(\n\t\tfileName+\".%Y%m%d%H%M.log\",\n\t\t// 生成软链，指向最新日志文件\n\t\trotatelogs.WithLinkName(fileName),\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\tdebugWriter, err := rotatelogs.New(\n\t\tfileName+\"_debug\"+\".%Y%m%d%H%M.log\",\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\n\t// 使用lfshook设置不同类型日志进行不同的切割方式\n\twriteMap := lfshook.WriterMap{\n\t\tlogrus.InfoLevel:  logWriter,\n\t\tlogrus.FatalLevel: logWriter,\n\t\tlogrus.DebugLevel: debugWriter,\n\t\tlogrus.WarnLevel:  logWriter,\n\t\tlogrus.ErrorLevel: logWriter,\n\t\tlogrus.PanicLevel: logWriter,\n\t}\n\tLogger.AddHook(lfshook.NewHook(writeMap, &logrus.JSONFormatter{\n\t\tTimestampFormat: \"2006-01-02 15:04:05\",\n\t}))\n}\n\n/**\n * 检测日志文件是否存在\n */\nfunc logFileStat() {\n\tlogPath := path.Join(config.Cfg.Server.LogPath)\n\tif _, err := os.Stat(logPath); os.IsNotExist(err) {\n\t\tos.Mkdir(logPath, os.ModePerm)\n\t\tos.Chmod(logPath, 0755)\n\t}\n}\n```","slug":"go/log","published":1,"updated":"2023-04-02T03:03:55.028Z","_id":"clf3pbdo900067oupfsl076b6","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li><p><a href=\"https://github.com/sirupsen/logrus\">logrus</a>是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。</p>\n</li>\n<li><p><a href=\"https://github.com/lestrrat-go/file-rotatelogs\">file-rotatelogs</a>实现了 io.Writer 接口，并且提供了文件的切割功能。</p>\n</li>\n<li><p><a href=\"https://github.com/rifflock/lfshook\">lfshook</a>决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT &#x2F; JSON）。</p>\n</li>\n<li><p>完整示例代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\trotatelogs <span class=\"string\">&quot;github.com/lestrrat-go/file-rotatelogs&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/rifflock/lfshook&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;go-package/config&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tLogger      *logrus.Logger</span><br><span class=\"line\">\tlogFileName <span class=\"type\">string</span> = <span class=\"string\">&quot;server_log&quot;</span></span><br><span class=\"line\">\tLocation, _        = time.LoadLocation(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitLogger</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例化logrus</span></span><br><span class=\"line\">\tLogger = logrus.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 设置日志级别</span></span><br><span class=\"line\">\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlevel = logrus.InfoLevel</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.SetLevel(level)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlogFileStat()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)</span><br><span class=\"line\">\t<span class=\"comment\">// 使用rotatelogs进行日志切割</span></span><br><span class=\"line\">\tlogWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 生成软链，指向最新日志文件</span></span><br><span class=\"line\">\t\trotatelogs.WithLinkName(fileName),</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdebugWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;_debug&quot;</span>+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用lfshook设置不同类型日志进行不同的切割方式</span></span><br><span class=\"line\">\twriteMap := lfshook.WriterMap&#123;</span><br><span class=\"line\">\t\tlogrus.InfoLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.FatalLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.DebugLevel: debugWriter,</span><br><span class=\"line\">\t\tlogrus.WarnLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.ErrorLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.PanicLevel: logWriter,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.AddHook(lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123;</span><br><span class=\"line\">\t\tTimestampFormat: <span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span>,</span><br><span class=\"line\">\t&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检测日志文件是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logFileStat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlogPath := path.Join(config.Cfg.Server.LogPath)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(logPath); os.IsNotExist(err) &#123;</span><br><span class=\"line\">\t\tos.Mkdir(logPath, os.ModePerm)</span><br><span class=\"line\">\t\tos.Chmod(logPath, <span class=\"number\">0755</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"more":"<ul>\n<li><p><a href=\"https://github.com/sirupsen/logrus\">logrus</a>是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。</p>\n</li>\n<li><p><a href=\"https://github.com/lestrrat-go/file-rotatelogs\">file-rotatelogs</a>实现了 io.Writer 接口，并且提供了文件的切割功能。</p>\n</li>\n<li><p><a href=\"https://github.com/rifflock/lfshook\">lfshook</a>决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT &#x2F; JSON）。</p>\n</li>\n<li><p>完整示例代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\trotatelogs <span class=\"string\">&quot;github.com/lestrrat-go/file-rotatelogs&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/rifflock/lfshook&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;go-package/config&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tLogger      *logrus.Logger</span><br><span class=\"line\">\tlogFileName <span class=\"type\">string</span> = <span class=\"string\">&quot;server_log&quot;</span></span><br><span class=\"line\">\tLocation, _        = time.LoadLocation(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitLogger</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例化logrus</span></span><br><span class=\"line\">\tLogger = logrus.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 设置日志级别</span></span><br><span class=\"line\">\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlevel = logrus.InfoLevel</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.SetLevel(level)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlogFileStat()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)</span><br><span class=\"line\">\t<span class=\"comment\">// 使用rotatelogs进行日志切割</span></span><br><span class=\"line\">\tlogWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 生成软链，指向最新日志文件</span></span><br><span class=\"line\">\t\trotatelogs.WithLinkName(fileName),</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdebugWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;_debug&quot;</span>+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用lfshook设置不同类型日志进行不同的切割方式</span></span><br><span class=\"line\">\twriteMap := lfshook.WriterMap&#123;</span><br><span class=\"line\">\t\tlogrus.InfoLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.FatalLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.DebugLevel: debugWriter,</span><br><span class=\"line\">\t\tlogrus.WarnLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.ErrorLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.PanicLevel: logWriter,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.AddHook(lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123;</span><br><span class=\"line\">\t\tTimestampFormat: <span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span>,</span><br><span class=\"line\">\t&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检测日志文件是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logFileStat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlogPath := path.Join(config.Cfg.Server.LogPath)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(logPath); os.IsNotExist(err) &#123;</span><br><span class=\"line\">\t\tos.Mkdir(logPath, os.ModePerm)</span><br><span class=\"line\">\t\tos.Chmod(logPath, <span class=\"number\">0755</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"go高并发模式之管道模式","date":"2023-03-29T23:48:00.000Z","excerpt":"go语言精髓之一就是高度支持并发性，以下就是结合设计模式的管道模式演绎下golang的高并发场景处理。","_content":"\n### 什么是管道模式？\n白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。\n```bash\n#Linux命令举例\ncat log.txt | grep \"hello\" | head xx\n```\n\n### go当中的管道模式形式\n举例：\n\n从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：\n\n![流程图](/images/go/pipe/pipe1.png)\n\n使用go编写类似于管道的形式的代码大概如下所示：\n```golang\nimport \"fmt\"\n\n// Events 找出偶数\nfunc Events(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        if input[i]%2 == 0 {\n        out = append(out, input[i])\n    }\n    return out\n}\n\n// M2 数字乘2\nfunc M2(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*2)\n    }\n    return out\n}\n\n// M5 数字乘5\nfunc M5(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*5)\n    }\n    return out\n}\n\n// Cmd 定义管道函数的参数类型\ntype Cmd func(list []int) (ret []int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 Cmd, f3 Cmd) []int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    res := Pipe(nums, Events, M2, M5)\n    for _, val := range res {\n        fmt.Printf(\"%d \", val)\n    }\n}\n```\n上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；\n\n### 使用channel优化\n加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：\n\n![加入chan的流程图](/images/go/pipe/pipe2.png)\n\n约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。\n```golang\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < len(input); i++ {\n            if input[i]%2 == 0 {\n                ch <- input[i]\n            }\n        }\n    }()\n    return ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 2\n        }\n    }()\n    return ch\n}\n// M5 将偶数乘以5\nfunc M5(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 5\n        }\n    }()\n    return ch\n}\n\ntype Cmd func([]int) chan int\n// PipeCmd 定义管道函数的参数类型\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 PipeCmd, f3 PipeCmd) chan int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    wg := sync.WaitGroup{}\n    res := Pipe(nums, Events, M2, M5)\n    for v := range res {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            fmt.Printf(\"%d \", v)\n        }()\n    }\n    wg.Wait()\n}\n\n```\n\n### 管道模式之多路复用\n白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：\n\n![多路复用流程图](/images/go/pipe/pipe3.png)\n\n```golang\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := 0; i < len(input); i++ {\n\t\t\tif input[i]%2 == 0 {\n\t\t\t\tch <- input[i]\n\t\t\t}\n\t\t}\n\t}()\n\treturn ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := range input {\n\t\t\ttime.Sleep(time.Second * 2)\n\t\t\tch <- i * 2\n\t\t}\n\t}()\n\treturn ch\n}\n\ntype Cmd func([]int) chan int\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, ps ...PipeCmd) chan int {\n\twg := sync.WaitGroup{}\n\tevench := f1(nums) // 找偶数\n\tout := make(chan int)\n\tfor _, p := range ps {\n\t\tgetChan := p(evench)\n\t\twg.Add(1)\n\t\tgo func(ch chan int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor c := range ch {\n\t\t\t\tout <- c\n\t\t\t}\n\t\t}(getChan)\n\t}\n\tgo func() {\n\t\tdefer close(out)\n\t\twg.Wait()\n\t}()\n\treturn out\n}\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n\tres := Pipe(nums, Events, M2, M2)\n\tfor v := range res {\n\t\tfmt.Printf(\"%d \", v)\n\t}\n}\n\n```\n\n完整代码查看：https://github.com/nhdeng/gopipe","source":"_posts/go/pipe.md","raw":"---\ntitle: go高并发模式之管道模式\ndate: 2023-03-30 07:48:00\ntags: [\"go\", \"pipe\", \"channel\"]\nexcerpt: go语言精髓之一就是高度支持并发性，以下就是结合设计模式的管道模式演绎下golang的高并发场景处理。\n---\n\n### 什么是管道模式？\n白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。\n```bash\n#Linux命令举例\ncat log.txt | grep \"hello\" | head xx\n```\n\n### go当中的管道模式形式\n举例：\n\n从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：\n\n![流程图](/images/go/pipe/pipe1.png)\n\n使用go编写类似于管道的形式的代码大概如下所示：\n```golang\nimport \"fmt\"\n\n// Events 找出偶数\nfunc Events(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        if input[i]%2 == 0 {\n        out = append(out, input[i])\n    }\n    return out\n}\n\n// M2 数字乘2\nfunc M2(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*2)\n    }\n    return out\n}\n\n// M5 数字乘5\nfunc M5(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*5)\n    }\n    return out\n}\n\n// Cmd 定义管道函数的参数类型\ntype Cmd func(list []int) (ret []int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 Cmd, f3 Cmd) []int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    res := Pipe(nums, Events, M2, M5)\n    for _, val := range res {\n        fmt.Printf(\"%d \", val)\n    }\n}\n```\n上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；\n\n### 使用channel优化\n加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：\n\n![加入chan的流程图](/images/go/pipe/pipe2.png)\n\n约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。\n```golang\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < len(input); i++ {\n            if input[i]%2 == 0 {\n                ch <- input[i]\n            }\n        }\n    }()\n    return ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 2\n        }\n    }()\n    return ch\n}\n// M5 将偶数乘以5\nfunc M5(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 5\n        }\n    }()\n    return ch\n}\n\ntype Cmd func([]int) chan int\n// PipeCmd 定义管道函数的参数类型\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 PipeCmd, f3 PipeCmd) chan int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    wg := sync.WaitGroup{}\n    res := Pipe(nums, Events, M2, M5)\n    for v := range res {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            fmt.Printf(\"%d \", v)\n        }()\n    }\n    wg.Wait()\n}\n\n```\n\n### 管道模式之多路复用\n白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：\n\n![多路复用流程图](/images/go/pipe/pipe3.png)\n\n```golang\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := 0; i < len(input); i++ {\n\t\t\tif input[i]%2 == 0 {\n\t\t\t\tch <- input[i]\n\t\t\t}\n\t\t}\n\t}()\n\treturn ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := range input {\n\t\t\ttime.Sleep(time.Second * 2)\n\t\t\tch <- i * 2\n\t\t}\n\t}()\n\treturn ch\n}\n\ntype Cmd func([]int) chan int\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, ps ...PipeCmd) chan int {\n\twg := sync.WaitGroup{}\n\tevench := f1(nums) // 找偶数\n\tout := make(chan int)\n\tfor _, p := range ps {\n\t\tgetChan := p(evench)\n\t\twg.Add(1)\n\t\tgo func(ch chan int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor c := range ch {\n\t\t\t\tout <- c\n\t\t\t}\n\t\t}(getChan)\n\t}\n\tgo func() {\n\t\tdefer close(out)\n\t\twg.Wait()\n\t}()\n\treturn out\n}\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n\tres := Pipe(nums, Events, M2, M2)\n\tfor v := range res {\n\t\tfmt.Printf(\"%d \", v)\n\t}\n}\n\n```\n\n完整代码查看：https://github.com/nhdeng/gopipe","slug":"go/pipe","published":1,"updated":"2023-03-30T05:57:17.353Z","_id":"clfuccaip000048upata61392","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是管道模式？\"><a href=\"#什么是管道模式？\" class=\"headerlink\" title=\"什么是管道模式？\"></a>什么是管道模式？</h3><p>白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Linux命令举例</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> log.txt | grep <span class=\"string\">&quot;hello&quot;</span> | <span class=\"built_in\">head</span> xx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"go当中的管道模式形式\"><a href=\"#go当中的管道模式形式\" class=\"headerlink\" title=\"go当中的管道模式形式\"></a>go当中的管道模式形式</h3><p>举例：</p>\n<p>从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe1.png\" alt=\"流程图\"></p>\n<p>使用go编写类似于管道的形式的代码大概如下所示：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 数字乘2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M5 数字乘5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">5</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(list []<span class=\"type\">int</span>)</span></span> (ret []<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 Cmd, f3 Cmd)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；</p>\n<h3 id=\"使用channel优化\"><a href=\"#使用channel优化\" class=\"headerlink\" title=\"使用channel优化\"></a>使用channel优化</h3><p>加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe2.png\" alt=\"加入chan的流程图\"></p>\n<p>约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                ch &lt;- input[i]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// M5 将偶数乘以5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">5</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"comment\">// PipeCmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 PipeCmd, f3 PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管道模式之多路复用\"><a href=\"#管道模式之多路复用\" class=\"headerlink\" title=\"管道模式之多路复用\"></a>管道模式之多路复用</h3><p>白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe3.png\" alt=\"多路复用流程图\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tch &lt;- input[i]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, ps ...PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\twg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\tevench := f1(nums) <span class=\"comment\">// 找偶数</span></span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, p := <span class=\"keyword\">range</span> ps &#123;</span><br><span class=\"line\">\t\tgetChan := p(evench)</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> c := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\t\t\t\tout &lt;- c</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;(getChan)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t\twg.Wait()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">\tres := Pipe(nums, Events, M2, M2)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完整代码查看：<a href=\"https://github.com/nhdeng/gopipe\">https://github.com/nhdeng/gopipe</a></p>\n","site":{"data":{}},"more":"<h3 id=\"什么是管道模式？\"><a href=\"#什么是管道模式？\" class=\"headerlink\" title=\"什么是管道模式？\"></a>什么是管道模式？</h3><p>白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Linux命令举例</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> log.txt | grep <span class=\"string\">&quot;hello&quot;</span> | <span class=\"built_in\">head</span> xx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"go当中的管道模式形式\"><a href=\"#go当中的管道模式形式\" class=\"headerlink\" title=\"go当中的管道模式形式\"></a>go当中的管道模式形式</h3><p>举例：</p>\n<p>从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe1.png\" alt=\"流程图\"></p>\n<p>使用go编写类似于管道的形式的代码大概如下所示：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 数字乘2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M5 数字乘5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">5</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(list []<span class=\"type\">int</span>)</span></span> (ret []<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 Cmd, f3 Cmd)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；</p>\n<h3 id=\"使用channel优化\"><a href=\"#使用channel优化\" class=\"headerlink\" title=\"使用channel优化\"></a>使用channel优化</h3><p>加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe2.png\" alt=\"加入chan的流程图\"></p>\n<p>约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                ch &lt;- input[i]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// M5 将偶数乘以5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">5</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"comment\">// PipeCmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 PipeCmd, f3 PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管道模式之多路复用\"><a href=\"#管道模式之多路复用\" class=\"headerlink\" title=\"管道模式之多路复用\"></a>管道模式之多路复用</h3><p>白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe3.png\" alt=\"多路复用流程图\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tch &lt;- input[i]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, ps ...PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\twg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\tevench := f1(nums) <span class=\"comment\">// 找偶数</span></span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, p := <span class=\"keyword\">range</span> ps &#123;</span><br><span class=\"line\">\t\tgetChan := p(evench)</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> c := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\t\t\t\tout &lt;- c</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;(getChan)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t\twg.Wait()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">\tres := Pipe(nums, Events, M2, M2)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完整代码查看：<a href=\"https://github.com/nhdeng/gopipe\">https://github.com/nhdeng/gopipe</a></p>\n"},{"title":"Redis基本数据类型及语法","date":"2023-04-02T06:06:18.000Z","excerpt":"本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。","_content":"\n# Redis基础-基本数据类型及语法\n本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n\nredis官网文档：https://redis.io\n\nredis中文文档：http://www.redis.cn\n\n## 一、docker安装redis\n1. 建立宿主机redis容器目录\n```bash\nmkdir -p /app/redis\n```\n2. 拷贝redis配置文件redis.conf到/app/redis目录下（redis配置文件官网下载地址：https://redis.io/download/）\n```bash\n# 修改redis.conf默认配置\n# 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1\n# 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败\n# 3. 【可选】开启redis数据持久化 appendonly yes \n# 4. 【可选】开启redis验证 requirepass 123456\n```\n3. 创建redis容器实例\n```bash\n# 拉取redis镜像\ndocker pull redis\n\n# 运行实例并挂载容器数据卷\ndocker run -d --name=redis -host --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf\n\n# 进入容器实例\ndocker exec -d redis /bin/bash\n\n# 执行redis-cli\n```\n## 二、redis键（key）常用命令\n1. 查看当前库所有key\n```bash\nKeys *\n```\n2. 判断某个key是否存在\n```bash\nExists key\n```\n3. 查看key类型\n```bash\nType key\n```\n3. 删除指定key\n```bash\nDel key\n```\n4. 非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作\n```bash\nUnlink key\n```\n5. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nTTL key\n```\n6. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nExpire key\n```\n\n7. 将当前数据库的 key移动到给定的数据库 db 当中\n```bash\nMove key dbIndex # dbIndex默认取证范围0-15\n```\n7. 切换数据库\n```bash\nSelect dbIndex # dbIndex默认取证范围0-15，默认为0\n```\n8. 查看当前数据局key的数量\n```bash\nDBSize\n```\n9. 清空当前库\n```bash\nFlushDB\n```\n10. 清空所有库\n```bash\nFlushAll\n```\n```bash\n# 查看具体数据类型的命令\nhelp @string \n```\n**更多命令查看官网：https://redis.io/commands/，**\n\n\n## 三、redis常用数据类型及命令\nredis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。\n### Redis字符串（String）\nString 单值单value\n1. 设置字符串\n```bash\nSet key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]\n```\nOptions说明：\n- EX seconds:以秒为单位设置过期时间；\n- PX milliseconds:以毫秒为单位设置过期时间；\n- EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；\n- PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；\n- NX:键不存在时设置键值；\n- XX:键存在时设置键值；\n- KEEPTTL:保留设置前的指定键的生存时间；\n- GET:返回指定键原本的值，若键不存在时返回nil\n\n2. 获取字符串`Get key`\n3. 同时设置获取多个键值\n```bash\nMSet key value [key value...]\nMGet key [key...]\n# 同时设置多个键值对当且仅当所有的key都不存在时\nMSetNX key value [key value...]\n```\n4. 获取指定区间范围内的值\n```bash\n# 相当于字符串的截取相当于substr，从0到-1表示全部\nGetRange name 0 2\nSetRange name 0 hello\n```\n5. 数值增减，只能是数字才能进行加减\n```bash\n# 递增数字\nIncr key\n# 增加指定的整数\nIncrBy key increment\n# 递减数字\nDecr key\n# 减少指定的整数\nDecrBy key decrement\n```\n6. 获取字符串长度和内容增加\n```bash\nStrLen key\nAppend key value\n```\n7. getset(先get再set)\n```bash\nGetSet key value\n```\n\n### Redis 列表（List）\nList 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。\n\n1. 为列表添加值\n```bash\nLPush/RPush key value [value...]\n```\n2. 查看列表指定区间元素\n```bash\n#0到-1代表查看所有元素\nLRange key start top\n```\n3. 移出并获取列表的第一个元素\n```bash\nLPop/RPop key \n```\n4. 按照索引下标获取元素\n```bash\nLIndex key index \n```\n5. 获取列表中元素的个数\n```bash\nLLen key\n```\n6. 删除N个数值等于xx的元素\n```bash\n# N为0代表指定值全部删除\nLRem key N xx\n```\n7. 截取指定Key范围内的值再指定给key\n```bash\nLTrim key start stop\n```\n8. 移除列表的最后一个元素并将该元素添加到另一个列表并返回\n```bash\nRPopLPush 源列表 目标列表\n```\n9. 通过索引设置列表元素中的值\n```bash\nLSet key index value\n```\n10. 向列表中插入新值\n```bash\nLInsert key Before/After 已有值 新值\n```\n\n### Redis 哈希（Hash）\nKV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。\n\n1. 基本操作\n```bash\nHSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]\n```\n2. 获取某个key中的键值对数量\n```bash\nHLen key\n```\n3. 查看hash指定字段是否存在\n```bash\nHExists key field\n```\n4. 查看hash中所有field或者value\n```bash\nHKeys/HVals key\n```\n5. 为hash表中的指定字段整加/浮点加\n```bash\nHIncrBy/HIncrByFloat key field value\n```\n6. 不存在就赋值，存在就无效\n```bash\nHSetNX key field value\n```\n### Redis 集合（Set）\n单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n1. 向集合中添加一个/多个元素\n```bash\nSAdd key member [member...]\n```\n2. 遍历集合key中的所有元素\n```bash\nSMembers key \n```\n3. 判断元素是否存在于集合中\n```bash\nSISMember key value \n```\n4. 移除集合中的元素\n```bash\nSRem key value \n```\n5. 获取集合中元素的个数\n```bash\nSCard key\n```\n6. 从集合中随机展现N个元素，元素不删除\n```bash\nSRandMember key N \n```\n6. 从集合中随机弹出N个元素，元素删除\n```bash\nSPop key N \n```\n6. 将集合中A中的某个值移入B集合中\n```bash\nSMove A B Avalue \n```\n7. 集合运算\n```bash\n# A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素\nSDiff key [key...]\n\n# A、B集合的并集运算\nSUnion key [key...]\n\n# A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合\nSInter key [key...]\n\n# 给定集合的交集产生的集合的基数，N代表key的个数\nSInterCard N key [key...]\n```\n\n### Redis 有序集合（ZSet）\nRedis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。\n\n1. 添加元素\n```bash \nZAdd key score member [score member...]\n```\n2. 通过索引区间返回有序集合中指定区间内的成员\n```bash \n# 按照元素分数从小到大，[withscores]是否带上分数\nZRange key start stop [withscores]\n```\n3. 通过索引区间返回有序集合中指定区间内的成员，倒序排列\n```bash \n# 按照元素分数从大到小，[withscores]是否带上分数\nZRevRange key start stop [withscores]\n```\n4. 指定分数范围内的元素\n```bash\nZRangeByScore key min max [withScores] [limit offset count]\n```\n5. 获取元素的分数\n```bash\nZScore key member\n```\n6. 获取集合中元素的数量\n```bash\nZCard key\n```\n7. 移除元素\n```bash\nZRem key member\n```\n8. 增加某个元素的分数\n```bash\nZIncrBy key increment member\n```\n9. 获取指定分数范围内的元素个数\n```bash\nZCount key min max\n```\n10. **从键名列表中的第一个**非空排序集中弹出一个或者多个元素，它们是成员分数对\n```bash\n# 从多个有序集合中弹出2个元素\nZMPop numKeys key [key...] min/max count 2\n```\n11. 获取有序集合中的元素下标值\n```bash\nZRank key values member\n```\n12. 获取有序集合中的逆序元素下标值\n```bash\nZRevRank key values member\n```\n\n## 四、基础数据类型的基本使用场景\n\n| 数据类型   | 经典使用场景                                   |\n|--------|------------------------------------------|\n| string | 抖音视频/商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id） |\n| List   | 微信公众号消息订阅；                               |\n| Hash   | 简单的购物车；                                  |\n| Set    | 抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人           |\n| ZSet   | 根据商品销售对商品进行排名                            |\n\n\n\n\n\n","source":"_posts/redis/base.md","raw":"---\ntitle: Redis基本数据类型及语法\ndate: 2023-04-02 14:06:18\ntags: [\"redis\", \"string\", \"list\", \"hash\", \"set\", \"zset\"]\nexcerpt: 本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n---\n\n# Redis基础-基本数据类型及语法\n本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n\nredis官网文档：https://redis.io\n\nredis中文文档：http://www.redis.cn\n\n## 一、docker安装redis\n1. 建立宿主机redis容器目录\n```bash\nmkdir -p /app/redis\n```\n2. 拷贝redis配置文件redis.conf到/app/redis目录下（redis配置文件官网下载地址：https://redis.io/download/）\n```bash\n# 修改redis.conf默认配置\n# 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1\n# 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败\n# 3. 【可选】开启redis数据持久化 appendonly yes \n# 4. 【可选】开启redis验证 requirepass 123456\n```\n3. 创建redis容器实例\n```bash\n# 拉取redis镜像\ndocker pull redis\n\n# 运行实例并挂载容器数据卷\ndocker run -d --name=redis -host --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf\n\n# 进入容器实例\ndocker exec -d redis /bin/bash\n\n# 执行redis-cli\n```\n## 二、redis键（key）常用命令\n1. 查看当前库所有key\n```bash\nKeys *\n```\n2. 判断某个key是否存在\n```bash\nExists key\n```\n3. 查看key类型\n```bash\nType key\n```\n3. 删除指定key\n```bash\nDel key\n```\n4. 非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作\n```bash\nUnlink key\n```\n5. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nTTL key\n```\n6. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nExpire key\n```\n\n7. 将当前数据库的 key移动到给定的数据库 db 当中\n```bash\nMove key dbIndex # dbIndex默认取证范围0-15\n```\n7. 切换数据库\n```bash\nSelect dbIndex # dbIndex默认取证范围0-15，默认为0\n```\n8. 查看当前数据局key的数量\n```bash\nDBSize\n```\n9. 清空当前库\n```bash\nFlushDB\n```\n10. 清空所有库\n```bash\nFlushAll\n```\n```bash\n# 查看具体数据类型的命令\nhelp @string \n```\n**更多命令查看官网：https://redis.io/commands/，**\n\n\n## 三、redis常用数据类型及命令\nredis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。\n### Redis字符串（String）\nString 单值单value\n1. 设置字符串\n```bash\nSet key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]\n```\nOptions说明：\n- EX seconds:以秒为单位设置过期时间；\n- PX milliseconds:以毫秒为单位设置过期时间；\n- EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；\n- PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；\n- NX:键不存在时设置键值；\n- XX:键存在时设置键值；\n- KEEPTTL:保留设置前的指定键的生存时间；\n- GET:返回指定键原本的值，若键不存在时返回nil\n\n2. 获取字符串`Get key`\n3. 同时设置获取多个键值\n```bash\nMSet key value [key value...]\nMGet key [key...]\n# 同时设置多个键值对当且仅当所有的key都不存在时\nMSetNX key value [key value...]\n```\n4. 获取指定区间范围内的值\n```bash\n# 相当于字符串的截取相当于substr，从0到-1表示全部\nGetRange name 0 2\nSetRange name 0 hello\n```\n5. 数值增减，只能是数字才能进行加减\n```bash\n# 递增数字\nIncr key\n# 增加指定的整数\nIncrBy key increment\n# 递减数字\nDecr key\n# 减少指定的整数\nDecrBy key decrement\n```\n6. 获取字符串长度和内容增加\n```bash\nStrLen key\nAppend key value\n```\n7. getset(先get再set)\n```bash\nGetSet key value\n```\n\n### Redis 列表（List）\nList 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。\n\n1. 为列表添加值\n```bash\nLPush/RPush key value [value...]\n```\n2. 查看列表指定区间元素\n```bash\n#0到-1代表查看所有元素\nLRange key start top\n```\n3. 移出并获取列表的第一个元素\n```bash\nLPop/RPop key \n```\n4. 按照索引下标获取元素\n```bash\nLIndex key index \n```\n5. 获取列表中元素的个数\n```bash\nLLen key\n```\n6. 删除N个数值等于xx的元素\n```bash\n# N为0代表指定值全部删除\nLRem key N xx\n```\n7. 截取指定Key范围内的值再指定给key\n```bash\nLTrim key start stop\n```\n8. 移除列表的最后一个元素并将该元素添加到另一个列表并返回\n```bash\nRPopLPush 源列表 目标列表\n```\n9. 通过索引设置列表元素中的值\n```bash\nLSet key index value\n```\n10. 向列表中插入新值\n```bash\nLInsert key Before/After 已有值 新值\n```\n\n### Redis 哈希（Hash）\nKV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。\n\n1. 基本操作\n```bash\nHSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]\n```\n2. 获取某个key中的键值对数量\n```bash\nHLen key\n```\n3. 查看hash指定字段是否存在\n```bash\nHExists key field\n```\n4. 查看hash中所有field或者value\n```bash\nHKeys/HVals key\n```\n5. 为hash表中的指定字段整加/浮点加\n```bash\nHIncrBy/HIncrByFloat key field value\n```\n6. 不存在就赋值，存在就无效\n```bash\nHSetNX key field value\n```\n### Redis 集合（Set）\n单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n1. 向集合中添加一个/多个元素\n```bash\nSAdd key member [member...]\n```\n2. 遍历集合key中的所有元素\n```bash\nSMembers key \n```\n3. 判断元素是否存在于集合中\n```bash\nSISMember key value \n```\n4. 移除集合中的元素\n```bash\nSRem key value \n```\n5. 获取集合中元素的个数\n```bash\nSCard key\n```\n6. 从集合中随机展现N个元素，元素不删除\n```bash\nSRandMember key N \n```\n6. 从集合中随机弹出N个元素，元素删除\n```bash\nSPop key N \n```\n6. 将集合中A中的某个值移入B集合中\n```bash\nSMove A B Avalue \n```\n7. 集合运算\n```bash\n# A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素\nSDiff key [key...]\n\n# A、B集合的并集运算\nSUnion key [key...]\n\n# A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合\nSInter key [key...]\n\n# 给定集合的交集产生的集合的基数，N代表key的个数\nSInterCard N key [key...]\n```\n\n### Redis 有序集合（ZSet）\nRedis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。\n\n1. 添加元素\n```bash \nZAdd key score member [score member...]\n```\n2. 通过索引区间返回有序集合中指定区间内的成员\n```bash \n# 按照元素分数从小到大，[withscores]是否带上分数\nZRange key start stop [withscores]\n```\n3. 通过索引区间返回有序集合中指定区间内的成员，倒序排列\n```bash \n# 按照元素分数从大到小，[withscores]是否带上分数\nZRevRange key start stop [withscores]\n```\n4. 指定分数范围内的元素\n```bash\nZRangeByScore key min max [withScores] [limit offset count]\n```\n5. 获取元素的分数\n```bash\nZScore key member\n```\n6. 获取集合中元素的数量\n```bash\nZCard key\n```\n7. 移除元素\n```bash\nZRem key member\n```\n8. 增加某个元素的分数\n```bash\nZIncrBy key increment member\n```\n9. 获取指定分数范围内的元素个数\n```bash\nZCount key min max\n```\n10. **从键名列表中的第一个**非空排序集中弹出一个或者多个元素，它们是成员分数对\n```bash\n# 从多个有序集合中弹出2个元素\nZMPop numKeys key [key...] min/max count 2\n```\n11. 获取有序集合中的元素下标值\n```bash\nZRank key values member\n```\n12. 获取有序集合中的逆序元素下标值\n```bash\nZRevRank key values member\n```\n\n## 四、基础数据类型的基本使用场景\n\n| 数据类型   | 经典使用场景                                   |\n|--------|------------------------------------------|\n| string | 抖音视频/商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id） |\n| List   | 微信公众号消息订阅；                               |\n| Hash   | 简单的购物车；                                  |\n| Set    | 抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人           |\n| ZSet   | 根据商品销售对商品进行排名                            |\n\n\n\n\n\n","slug":"redis/base","published":1,"updated":"2023-04-05T12:48:31.140Z","_id":"clg01evht00009oupho4ue7c7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Redis基础-基本数据类型及语法\"><a href=\"#Redis基础-基本数据类型及语法\" class=\"headerlink\" title=\"Redis基础-基本数据类型及语法\"></a>Redis基础-基本数据类型及语法</h1><p>本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。</p>\n<p>redis官网文档：<a href=\"https://redis.io/\">https://redis.io</a></p>\n<p>redis中文文档：<a href=\"http://www.redis.cn/\">http://www.redis.cn</a></p>\n<h2 id=\"一、docker安装redis\"><a href=\"#一、docker安装redis\" class=\"headerlink\" title=\"一、docker安装redis\"></a>一、docker安装redis</h2><ol>\n<li>建立宿主机redis容器目录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /app/redis</span><br></pre></td></tr></table></figure></li>\n<li>拷贝redis配置文件redis.conf到&#x2F;app&#x2F;redis目录下（redis配置文件官网下载地址：<a href=\"https://redis.io/download/%EF%BC%89\">https://redis.io/download/）</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改redis.conf默认配置</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 【可选】开启redis数据持久化 appendonly yes </span></span><br><span class=\"line\"><span class=\"comment\"># 4. 【可选】开启redis验证 requirepass 123456</span></span><br></pre></td></tr></table></figure></li>\n<li>创建redis容器实例<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取redis镜像</span></span><br><span class=\"line\">docker pull redis</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行实例并挂载容器数据卷</span></span><br><span class=\"line\">docker run -d --name=redis -host --privileged=<span class=\"literal\">true</span> -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器实例</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -d redis /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行redis-cli</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"二、redis键（key）常用命令\"><a href=\"#二、redis键（key）常用命令\" class=\"headerlink\" title=\"二、redis键（key）常用命令\"></a>二、redis键（key）常用命令</h2><ol>\n<li><p>查看当前库所有key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keys *</span><br></pre></td></tr></table></figure></li>\n<li><p>判断某个key是否存在</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exists key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看key类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type key</span><br></pre></td></tr></table></figure></li>\n<li><p>删除指定key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Del key</span><br></pre></td></tr></table></figure></li>\n<li><p>非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unlink key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expire key</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将当前数据库的 key移动到给定的数据库 db 当中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move key dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15</span></span><br></pre></td></tr></table></figure></li>\n<li><p>切换数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15，默认为0</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查看当前数据局key的数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBSize</span><br></pre></td></tr></table></figure></li>\n<li><p>清空当前库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushDB</span><br></pre></td></tr></table></figure></li>\n<li><p>清空所有库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushAll</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看具体数据类型的命令</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> @string </span><br></pre></td></tr></table></figure>\n<p><strong>更多命令查看官网：<a href=\"https://redis.io/commands/%EF%BC%8C\">https://redis.io/commands/，</a></strong></p>\n</li>\n</ol>\n<h2 id=\"三、redis常用数据类型及命令\"><a href=\"#三、redis常用数据类型及命令\" class=\"headerlink\" title=\"三、redis常用数据类型及命令\"></a>三、redis常用数据类型及命令</h2><p>redis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。</p>\n<h3 id=\"Redis字符串（String）\"><a href=\"#Redis字符串（String）\" class=\"headerlink\" title=\"Redis字符串（String）\"></a>Redis字符串（String）</h3><p>String 单值单value</p>\n<ol>\n<li>设置字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>\nOptions说明：</li>\n</ol>\n<ul>\n<li>EX seconds:以秒为单位设置过期时间；</li>\n<li>PX milliseconds:以毫秒为单位设置过期时间；</li>\n<li>EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；</li>\n<li>PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；</li>\n<li>NX:键不存在时设置键值；</li>\n<li>XX:键存在时设置键值；</li>\n<li>KEEPTTL:保留设置前的指定键的生存时间；</li>\n<li>GET:返回指定键原本的值，若键不存在时返回nil</li>\n</ul>\n<ol start=\"2\">\n<li>获取字符串<code>Get key</code></li>\n<li>同时设置获取多个键值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSet key value [key value...]</span><br><span class=\"line\">MGet key [key...]</span><br><span class=\"line\"><span class=\"comment\"># 同时设置多个键值对当且仅当所有的key都不存在时</span></span><br><span class=\"line\">MSetNX key value [key value...]</span><br></pre></td></tr></table></figure></li>\n<li>获取指定区间范围内的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 相当于字符串的截取相当于substr，从0到-1表示全部</span></span><br><span class=\"line\">GetRange name 0 2</span><br><span class=\"line\">SetRange name 0 hello</span><br></pre></td></tr></table></figure></li>\n<li>数值增减，只能是数字才能进行加减<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 递增数字</span></span><br><span class=\"line\">Incr key</span><br><span class=\"line\"><span class=\"comment\"># 增加指定的整数</span></span><br><span class=\"line\">IncrBy key increment</span><br><span class=\"line\"><span class=\"comment\"># 递减数字</span></span><br><span class=\"line\">Decr key</span><br><span class=\"line\"><span class=\"comment\"># 减少指定的整数</span></span><br><span class=\"line\">DecrBy key decrement</span><br></pre></td></tr></table></figure></li>\n<li>获取字符串长度和内容增加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrLen key</span><br><span class=\"line\">Append key value</span><br></pre></td></tr></table></figure></li>\n<li>getset(先get再set)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GetSet key value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-列表（List）\"><a href=\"#Redis-列表（List）\" class=\"headerlink\" title=\"Redis 列表（List）\"></a>Redis 列表（List）</h3><p>List 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p>\n<ol>\n<li>为列表添加值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPush/RPush key value [value...]</span><br></pre></td></tr></table></figure></li>\n<li>查看列表指定区间元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#0到-1代表查看所有元素</span></span><br><span class=\"line\">LRange key start top</span><br></pre></td></tr></table></figure></li>\n<li>移出并获取列表的第一个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPop/RPop key </span><br></pre></td></tr></table></figure></li>\n<li>按照索引下标获取元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIndex key index </span><br></pre></td></tr></table></figure></li>\n<li>获取列表中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LLen key</span><br></pre></td></tr></table></figure></li>\n<li>删除N个数值等于xx的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># N为0代表指定值全部删除</span></span><br><span class=\"line\">LRem key N xx</span><br></pre></td></tr></table></figure></li>\n<li>截取指定Key范围内的值再指定给key<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LTrim key start stop</span><br></pre></td></tr></table></figure></li>\n<li>移除列表的最后一个元素并将该元素添加到另一个列表并返回<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPopLPush 源列表 目标列表</span><br></pre></td></tr></table></figure></li>\n<li>通过索引设置列表元素中的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSet key index value</span><br></pre></td></tr></table></figure></li>\n<li>向列表中插入新值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LInsert key Before/After 已有值 新值</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-哈希（Hash）\"><a href=\"#Redis-哈希（Hash）\" class=\"headerlink\" title=\"Redis 哈希（Hash）\"></a>Redis 哈希（Hash）</h3><p>KV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>\n<ol>\n<li>基本操作<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]</span><br></pre></td></tr></table></figure></li>\n<li>获取某个key中的键值对数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HLen key</span><br></pre></td></tr></table></figure></li>\n<li>查看hash指定字段是否存在<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HExists key field</span><br></pre></td></tr></table></figure></li>\n<li>查看hash中所有field或者value<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HKeys/HVals key</span><br></pre></td></tr></table></figure></li>\n<li>为hash表中的指定字段整加&#x2F;浮点加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HIncrBy/HIncrByFloat key field value</span><br></pre></td></tr></table></figure></li>\n<li>不存在就赋值，存在就无效<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSetNX key field value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-集合（Set）\"><a href=\"#Redis-集合（Set）\" class=\"headerlink\" title=\"Redis 集合（Set）\"></a>Redis 集合（Set）</h3><p>单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>\n<ol>\n<li>向集合中添加一个&#x2F;多个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAdd key member [member...]</span><br></pre></td></tr></table></figure></li>\n<li>遍历集合key中的所有元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMembers key </span><br></pre></td></tr></table></figure></li>\n<li>判断元素是否存在于集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SISMember key value </span><br></pre></td></tr></table></figure></li>\n<li>移除集合中的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRem key value </span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCard key</span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机展现N个元素，元素不删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRandMember key N </span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机弹出N个元素，元素删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SPop key N </span><br></pre></td></tr></table></figure></li>\n<li>将集合中A中的某个值移入B集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMove A B Avalue </span><br></pre></td></tr></table></figure></li>\n<li>集合运算<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素</span></span><br><span class=\"line\">SDiff key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的并集运算</span></span><br><span class=\"line\">SUnion key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合</span></span><br><span class=\"line\">SInter key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给定集合的交集产生的集合的基数，N代表key的个数</span></span><br><span class=\"line\">SInterCard N key [key...]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-有序集合（ZSet）\"><a href=\"#Redis-有序集合（ZSet）\" class=\"headerlink\" title=\"Redis 有序集合（ZSet）\"></a>Redis 有序集合（ZSet）</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>\n<ol>\n<li>添加元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZAdd key score member [score member...]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从小到大，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员，倒序排列<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从大到小，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRevRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>指定分数范围内的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRangeByScore key min max [withScores] [<span class=\"built_in\">limit</span> offset count]</span><br></pre></td></tr></table></figure></li>\n<li>获取元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZScore key member</span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCard key</span><br></pre></td></tr></table></figure></li>\n<li>移除元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRem key member</span><br></pre></td></tr></table></figure></li>\n<li>增加某个元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZIncrBy key increment member</span><br></pre></td></tr></table></figure></li>\n<li>获取指定分数范围内的元素个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCount key min max</span><br></pre></td></tr></table></figure></li>\n<li><strong>从键名列表中的第一个</strong>非空排序集中弹出一个或者多个元素，它们是成员分数对<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从多个有序集合中弹出2个元素</span></span><br><span class=\"line\">ZMPop numKeys key [key...] min/max count 2</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRank key values member</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的逆序元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRevRank key values member</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"四、基础数据类型的基本使用场景\"><a href=\"#四、基础数据类型的基本使用场景\" class=\"headerlink\" title=\"四、基础数据类型的基本使用场景\"></a>四、基础数据类型的基本使用场景</h2><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>经典使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>抖音视频&#x2F;商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id）</td>\n</tr>\n<tr>\n<td>List</td>\n<td>微信公众号消息订阅；</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>简单的购物车；</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人</td>\n</tr>\n<tr>\n<td>ZSet</td>\n<td>根据商品销售对商品进行排名</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"more":"<h1 id=\"Redis基础-基本数据类型及语法\"><a href=\"#Redis基础-基本数据类型及语法\" class=\"headerlink\" title=\"Redis基础-基本数据类型及语法\"></a>Redis基础-基本数据类型及语法</h1><p>本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。</p>\n<p>redis官网文档：<a href=\"https://redis.io/\">https://redis.io</a></p>\n<p>redis中文文档：<a href=\"http://www.redis.cn/\">http://www.redis.cn</a></p>\n<h2 id=\"一、docker安装redis\"><a href=\"#一、docker安装redis\" class=\"headerlink\" title=\"一、docker安装redis\"></a>一、docker安装redis</h2><ol>\n<li>建立宿主机redis容器目录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /app/redis</span><br></pre></td></tr></table></figure></li>\n<li>拷贝redis配置文件redis.conf到&#x2F;app&#x2F;redis目录下（redis配置文件官网下载地址：<a href=\"https://redis.io/download/%EF%BC%89\">https://redis.io/download/）</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改redis.conf默认配置</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 【可选】开启redis数据持久化 appendonly yes </span></span><br><span class=\"line\"><span class=\"comment\"># 4. 【可选】开启redis验证 requirepass 123456</span></span><br></pre></td></tr></table></figure></li>\n<li>创建redis容器实例<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取redis镜像</span></span><br><span class=\"line\">docker pull redis</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行实例并挂载容器数据卷</span></span><br><span class=\"line\">docker run -d --name=redis -host --privileged=<span class=\"literal\">true</span> -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器实例</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -d redis /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行redis-cli</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"二、redis键（key）常用命令\"><a href=\"#二、redis键（key）常用命令\" class=\"headerlink\" title=\"二、redis键（key）常用命令\"></a>二、redis键（key）常用命令</h2><ol>\n<li><p>查看当前库所有key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keys *</span><br></pre></td></tr></table></figure></li>\n<li><p>判断某个key是否存在</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exists key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看key类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type key</span><br></pre></td></tr></table></figure></li>\n<li><p>删除指定key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Del key</span><br></pre></td></tr></table></figure></li>\n<li><p>非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unlink key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expire key</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将当前数据库的 key移动到给定的数据库 db 当中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move key dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15</span></span><br></pre></td></tr></table></figure></li>\n<li><p>切换数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15，默认为0</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查看当前数据局key的数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBSize</span><br></pre></td></tr></table></figure></li>\n<li><p>清空当前库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushDB</span><br></pre></td></tr></table></figure></li>\n<li><p>清空所有库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushAll</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看具体数据类型的命令</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> @string </span><br></pre></td></tr></table></figure>\n<p><strong>更多命令查看官网：<a href=\"https://redis.io/commands/%EF%BC%8C\">https://redis.io/commands/，</a></strong></p>\n</li>\n</ol>\n<h2 id=\"三、redis常用数据类型及命令\"><a href=\"#三、redis常用数据类型及命令\" class=\"headerlink\" title=\"三、redis常用数据类型及命令\"></a>三、redis常用数据类型及命令</h2><p>redis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。</p>\n<h3 id=\"Redis字符串（String）\"><a href=\"#Redis字符串（String）\" class=\"headerlink\" title=\"Redis字符串（String）\"></a>Redis字符串（String）</h3><p>String 单值单value</p>\n<ol>\n<li>设置字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>\nOptions说明：</li>\n</ol>\n<ul>\n<li>EX seconds:以秒为单位设置过期时间；</li>\n<li>PX milliseconds:以毫秒为单位设置过期时间；</li>\n<li>EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；</li>\n<li>PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；</li>\n<li>NX:键不存在时设置键值；</li>\n<li>XX:键存在时设置键值；</li>\n<li>KEEPTTL:保留设置前的指定键的生存时间；</li>\n<li>GET:返回指定键原本的值，若键不存在时返回nil</li>\n</ul>\n<ol start=\"2\">\n<li>获取字符串<code>Get key</code></li>\n<li>同时设置获取多个键值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSet key value [key value...]</span><br><span class=\"line\">MGet key [key...]</span><br><span class=\"line\"><span class=\"comment\"># 同时设置多个键值对当且仅当所有的key都不存在时</span></span><br><span class=\"line\">MSetNX key value [key value...]</span><br></pre></td></tr></table></figure></li>\n<li>获取指定区间范围内的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 相当于字符串的截取相当于substr，从0到-1表示全部</span></span><br><span class=\"line\">GetRange name 0 2</span><br><span class=\"line\">SetRange name 0 hello</span><br></pre></td></tr></table></figure></li>\n<li>数值增减，只能是数字才能进行加减<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 递增数字</span></span><br><span class=\"line\">Incr key</span><br><span class=\"line\"><span class=\"comment\"># 增加指定的整数</span></span><br><span class=\"line\">IncrBy key increment</span><br><span class=\"line\"><span class=\"comment\"># 递减数字</span></span><br><span class=\"line\">Decr key</span><br><span class=\"line\"><span class=\"comment\"># 减少指定的整数</span></span><br><span class=\"line\">DecrBy key decrement</span><br></pre></td></tr></table></figure></li>\n<li>获取字符串长度和内容增加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrLen key</span><br><span class=\"line\">Append key value</span><br></pre></td></tr></table></figure></li>\n<li>getset(先get再set)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GetSet key value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-列表（List）\"><a href=\"#Redis-列表（List）\" class=\"headerlink\" title=\"Redis 列表（List）\"></a>Redis 列表（List）</h3><p>List 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p>\n<ol>\n<li>为列表添加值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPush/RPush key value [value...]</span><br></pre></td></tr></table></figure></li>\n<li>查看列表指定区间元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#0到-1代表查看所有元素</span></span><br><span class=\"line\">LRange key start top</span><br></pre></td></tr></table></figure></li>\n<li>移出并获取列表的第一个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPop/RPop key </span><br></pre></td></tr></table></figure></li>\n<li>按照索引下标获取元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIndex key index </span><br></pre></td></tr></table></figure></li>\n<li>获取列表中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LLen key</span><br></pre></td></tr></table></figure></li>\n<li>删除N个数值等于xx的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># N为0代表指定值全部删除</span></span><br><span class=\"line\">LRem key N xx</span><br></pre></td></tr></table></figure></li>\n<li>截取指定Key范围内的值再指定给key<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LTrim key start stop</span><br></pre></td></tr></table></figure></li>\n<li>移除列表的最后一个元素并将该元素添加到另一个列表并返回<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPopLPush 源列表 目标列表</span><br></pre></td></tr></table></figure></li>\n<li>通过索引设置列表元素中的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSet key index value</span><br></pre></td></tr></table></figure></li>\n<li>向列表中插入新值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LInsert key Before/After 已有值 新值</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-哈希（Hash）\"><a href=\"#Redis-哈希（Hash）\" class=\"headerlink\" title=\"Redis 哈希（Hash）\"></a>Redis 哈希（Hash）</h3><p>KV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>\n<ol>\n<li>基本操作<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]</span><br></pre></td></tr></table></figure></li>\n<li>获取某个key中的键值对数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HLen key</span><br></pre></td></tr></table></figure></li>\n<li>查看hash指定字段是否存在<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HExists key field</span><br></pre></td></tr></table></figure></li>\n<li>查看hash中所有field或者value<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HKeys/HVals key</span><br></pre></td></tr></table></figure></li>\n<li>为hash表中的指定字段整加&#x2F;浮点加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HIncrBy/HIncrByFloat key field value</span><br></pre></td></tr></table></figure></li>\n<li>不存在就赋值，存在就无效<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSetNX key field value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-集合（Set）\"><a href=\"#Redis-集合（Set）\" class=\"headerlink\" title=\"Redis 集合（Set）\"></a>Redis 集合（Set）</h3><p>单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>\n<ol>\n<li>向集合中添加一个&#x2F;多个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAdd key member [member...]</span><br></pre></td></tr></table></figure></li>\n<li>遍历集合key中的所有元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMembers key </span><br></pre></td></tr></table></figure></li>\n<li>判断元素是否存在于集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SISMember key value </span><br></pre></td></tr></table></figure></li>\n<li>移除集合中的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRem key value </span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCard key</span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机展现N个元素，元素不删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRandMember key N </span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机弹出N个元素，元素删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SPop key N </span><br></pre></td></tr></table></figure></li>\n<li>将集合中A中的某个值移入B集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMove A B Avalue </span><br></pre></td></tr></table></figure></li>\n<li>集合运算<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素</span></span><br><span class=\"line\">SDiff key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的并集运算</span></span><br><span class=\"line\">SUnion key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合</span></span><br><span class=\"line\">SInter key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给定集合的交集产生的集合的基数，N代表key的个数</span></span><br><span class=\"line\">SInterCard N key [key...]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-有序集合（ZSet）\"><a href=\"#Redis-有序集合（ZSet）\" class=\"headerlink\" title=\"Redis 有序集合（ZSet）\"></a>Redis 有序集合（ZSet）</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>\n<ol>\n<li>添加元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZAdd key score member [score member...]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从小到大，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员，倒序排列<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从大到小，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRevRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>指定分数范围内的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRangeByScore key min max [withScores] [<span class=\"built_in\">limit</span> offset count]</span><br></pre></td></tr></table></figure></li>\n<li>获取元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZScore key member</span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCard key</span><br></pre></td></tr></table></figure></li>\n<li>移除元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRem key member</span><br></pre></td></tr></table></figure></li>\n<li>增加某个元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZIncrBy key increment member</span><br></pre></td></tr></table></figure></li>\n<li>获取指定分数范围内的元素个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCount key min max</span><br></pre></td></tr></table></figure></li>\n<li><strong>从键名列表中的第一个</strong>非空排序集中弹出一个或者多个元素，它们是成员分数对<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从多个有序集合中弹出2个元素</span></span><br><span class=\"line\">ZMPop numKeys key [key...] min/max count 2</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRank key values member</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的逆序元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRevRank key values member</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"四、基础数据类型的基本使用场景\"><a href=\"#四、基础数据类型的基本使用场景\" class=\"headerlink\" title=\"四、基础数据类型的基本使用场景\"></a>四、基础数据类型的基本使用场景</h2><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>经典使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>抖音视频&#x2F;商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id）</td>\n</tr>\n<tr>\n<td>List</td>\n<td>微信公众号消息订阅；</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>简单的购物车；</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人</td>\n</tr>\n<tr>\n<td>ZSet</td>\n<td>根据商品销售对商品进行排名</td>\n</tr>\n</tbody></table>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clf3pbdo000007oup0pwta5mc","tag_id":"clf3pbdo500017oupg2im37pd","_id":"clf3pbdo700037oupbewp7a30"},{"post_id":"clf3pbdo000007oup0pwta5mc","tag_id":"clf3pbdo600027oup1jihb3ck","_id":"clf3pbdo700047oup1kqa918r"},{"post_id":"clf3pbdo800057oup2h3f97b9","tag_id":"clf3pbdo900077oup60rk3ctn","_id":"clf3pbdoa000a7oupbawg0o4o"},{"post_id":"clf3pbdo800057oup2h3f97b9","tag_id":"clf3pbdoa00087oupgnlw6112","_id":"clf3pbdoa000b7oup5k08c6so"},{"post_id":"clf3pbdo900067oupfsl076b6","tag_id":"clf3pbdoa00097oup2dux9n2z","_id":"clf3pbdob000f7oup5wa1dq5w"},{"post_id":"clf3pbdo900067oupfsl076b6","tag_id":"clf3pbdoa000c7oup8mnwe3jp","_id":"clf3pbdob000g7oupb9sm5pfh"},{"post_id":"clf3pbdo900067oupfsl076b6","tag_id":"clf3pbdob000d7oup57k2ctto","_id":"clf3pbdob000h7oup9ssb947j"},{"post_id":"clf3pbdo900067oupfsl076b6","tag_id":"clf3pbdob000e7oup0u9i41p4","_id":"clf3pbdob000i7oup544eem83"},{"post_id":"clfuccaip000048upata61392","tag_id":"clf3pbdoa00097oup2dux9n2z","_id":"clfuccaj1000348upagm03sow"},{"post_id":"clfuccaip000048upata61392","tag_id":"clfuccaiw000148up0lik7son","_id":"clfuccaj2000448up4k4fbcng"},{"post_id":"clfuccaip000048upata61392","tag_id":"clfuccaj0000248upgqdq222o","_id":"clfuccaj2000548up1il6ff4n"},{"post_id":"clg01evht00009oupho4ue7c7","tag_id":"clg01evi000019oup4483ag5o","_id":"clg01evi400079oup3vm6dqdv"},{"post_id":"clg01evht00009oupho4ue7c7","tag_id":"clg01evi200029oupeiat8pa4","_id":"clg01evi400089oupckmrhrp3"},{"post_id":"clg01evht00009oupho4ue7c7","tag_id":"clg01evi200039oup5ur6gmo0","_id":"clg01evi400099oupbsss2193"},{"post_id":"clg01evht00009oupho4ue7c7","tag_id":"clg01evi300049oupflhv8q37","_id":"clg01evi4000a9oup21viemcr"},{"post_id":"clg01evht00009oupho4ue7c7","tag_id":"clg01evi300059oupftwxbufh","_id":"clg01evi4000b9oup3jvagpqz"},{"post_id":"clg01evht00009oupho4ue7c7","tag_id":"clg01evi300069oupbiqs5r5k","_id":"clg01evi5000c9oupf84ucvec"}],"Tag":[{"name":"web","_id":"clf3pbdo500017oupg2im37pd"},{"name":"docker","_id":"clf3pbdo600027oup1jihb3ck"},{"name":"git","_id":"clf3pbdo900077oup60rk3ctn"},{"name":"fork","_id":"clf3pbdoa00087oupgnlw6112"},{"name":"go","_id":"clf3pbdoa00097oup2dux9n2z"},{"name":"gorus","_id":"clf3pbdoa000c7oup8mnwe3jp"},{"name":"rotatelogs","_id":"clf3pbdob000d7oup57k2ctto"},{"name":"ifshook","_id":"clf3pbdob000e7oup0u9i41p4"},{"name":"pipe","_id":"clfuccaiw000148up0lik7son"},{"name":"channel","_id":"clfuccaj0000248upgqdq222o"},{"name":"redis","_id":"clg01evi000019oup4483ag5o"},{"name":"string","_id":"clg01evi200029oupeiat8pa4"},{"name":"list","_id":"clg01evi200039oup5ur6gmo0"},{"name":"hash","_id":"clg01evi300049oupflhv8q37"},{"name":"set","_id":"clg01evi300059oupftwxbufh"},{"name":"zset","_id":"clg01evi300069oupbiqs5r5k"}]}}