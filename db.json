{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/docker/container-command.png","path":"images/docker/container-command.png","modified":0,"renderable":0},{"_id":"source/images/docker/composition.png","path":"images/docker/composition.png","modified":0,"renderable":0},{"_id":"source/images/docker/dockerfile.png","path":"images/docker/dockerfile.png","modified":0,"renderable":0},{"_id":"source/images/docker/container-options.png","path":"images/docker/container-options.png","modified":0,"renderable":0},{"_id":"source/images/git/fork-remote.png","path":"images/git/fork-remote.png","modified":0,"renderable":0},{"_id":"source/images/git/微信截图_20230327103738.png","path":"images/git/微信截图_20230327103738.png","modified":0,"renderable":0},{"_id":"source/images/redis/key.png","path":"images/redis/key.png","modified":0,"renderable":0},{"_id":"source/images/redis/memory.png","path":"images/redis/memory.png","modified":0,"renderable":0},{"_id":"source/images/redis/list.png","path":"images/redis/list.png","modified":0,"renderable":0},{"_id":"source/images/go/ioc/case1.png","path":"images/go/ioc/case1.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe3.png","path":"images/go/pipe/pipe3.png","modified":0,"renderable":0},{"_id":"source/images/go/ioc/case2.png","path":"images/go/ioc/case2.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe1.png","path":"images/go/pipe/pipe1.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe2.png","path":"images/go/pipe/pipe2.png","modified":0,"renderable":0},{"_id":"themes/bear/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/images/check.svg","path":"images/check.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/index.js","path":"script/index.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/jquery.min.js","path":"script/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/post.js","path":"script/post.js","modified":0,"renderable":1},{"_id":"themes/bear/source/styles/site.styl","path":"styles/site.styl","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/email.svg","path":"images/socials/email.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/facebook.svg","path":"images/socials/facebook.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/github.svg","path":"images/socials/github.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/flickr.svg","path":"images/socials/flickr.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/instagram.svg","path":"images/socials/instagram.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/wechat.svg","path":"images/socials/wechat.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/weibo.svg","path":"images/socials/weibo.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/google.svg","path":"images/socials/google.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"source/images/linux/dhcp.png","path":"images/linux/dhcp.png","modified":0,"renderable":0},{"_id":"source/images/linux/nat.png","path":"images/linux/nat.png","modified":0,"renderable":0},{"_id":"source/images/linux/network.png","path":"images/linux/network.png","modified":0,"renderable":0},{"_id":"source/images/linux/setting.png","path":"images/linux/setting.png","modified":0,"renderable":0},{"_id":"source/images/linux/static-ip.png","path":"images/linux/static-ip.png","modified":0,"renderable":0},{"_id":"source/images/linux/vmware-1.png","path":"images/linux/vmware-1.png","modified":0,"renderable":0},{"_id":"source/images/node/framework/framework.png","path":"images/node/framework/framework.png","modified":0,"renderable":0},{"_id":"source/images/node/framework/nodejs_worker.png","path":"images/node/framework/nodejs_worker.png","modified":0,"renderable":0},{"_id":"source/images/cicd/runner-create.png","path":"images/cicd/runner-create.png","modified":0,"renderable":0},{"_id":"source/images/cicd/runner-register.png","path":"images/cicd/runner-register.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_drafts/persistence.md","hash":"bb16b827881b30808bac14434abf3c1856b9a276","modified":1685176673259},{"_id":"source/_drafts/kubernetes/base.md","hash":"c7dd3faa95f6deb6a8eaf4a40e33f04174b3f3d6","modified":1685774562007},{"_id":"source/_drafts/hexo-command.md","hash":"db7ad7987cefa219554dbe15299921a4fba50b0c","modified":1685176673259},{"_id":"source/images/docker/dockerfile.png","hash":"43920921835d74aba2c1ed6c96c2e1ec5acbb0c3","modified":1678096841936},{"_id":"source/_posts/docker.md","hash":"d81db0b888a6cda9df1e03f4a651ce301c271d8d","modified":1678241557893},{"_id":"source/images/git/fork-remote.png","hash":"4fc4ff99088c23b165d4e628efd7a8e3360c306a","modified":1678414964117},{"_id":"source/images/git/微信截图_20230327103738.png","hash":"4ea65f1b32bc8902d3ede33a308fb76376e85caa","modified":1679884660542},{"_id":"source/_posts/go/ioc.md","hash":"8e683812fc4b731d1143d9f207bb41b21217b6e9","modified":1685176673260},{"_id":"source/images/redis/list.png","hash":"63773914754e857095905d551e46587f12cdf862","modified":1680565828991},{"_id":"source/_posts/git/fork.md","hash":"e990bf2ff8a92e98eda2478f99edb1ec2220c2dc","modified":1685175005834},{"_id":"source/_posts/go/log.md","hash":"c04451fe35360e5c61d7c3aa8dc2c50777f56432","modified":1685175005834},{"_id":"source/_posts/go/pipe.md","hash":"06018d827fae22bd83ffe45bbdc569667a8fbc17","modified":1680155837353},{"_id":"source/images/go/ioc/case2.png","hash":"ca2f15145602dec4ccebb740f2268e668d140970","modified":1684461223097},{"_id":"source/images/go/ioc/case1.png","hash":"45576d7ffdfaad4440116c6536c92c30991098bf","modified":1684379937144},{"_id":"source/_posts/go/reflect.md","hash":"e9a17e02ffc6fb452218575271db876f50812157","modified":1685176673260},{"_id":"source/_posts/redis/base.md","hash":"90261adc9eeed27a548597f33a5be24d43c094c4","modified":1681885648490},{"_id":"source/images/go/pipe/pipe1.png","hash":"0e88ba7c6a3d0f39d563bc877daf8505c8a0d90c","modified":1680068733330},{"_id":"source/images/go/pipe/pipe3.png","hash":"4f16d115f18c33bbbf9a97c25f07b28cad550c8a","modified":1680072633426},{"_id":"themes/bear/_config.yml","hash":"e7cf37c67e525e34f8685b5ac772dbd24ccf1ab0","modified":1678240819358},{"_id":"themes/bear/package.json","hash":"05f5e28a3ed6ca24f34ecebb60de3c8281209be4","modified":1685176673264},{"_id":"source/images/go/pipe/pipe2.png","hash":"5c71c9d47d927e1ea9eb7567817c1366ceb6fb13","modified":1680070417150},{"_id":"themes/bear/.DS_Store","hash":"83d7e57752db294868ca1b7c368b619f29c951ae","modified":1677829317036},{"_id":"themes/bear/README.md","hash":"df9ab18cad20f2a189ccc6c5082a9250ddbb5ee0","modified":1677829317036},{"_id":"themes/bear/_partial/footer.pug","hash":"b72a17a470dbe10bd291c4fd9f0545278b6599f5","modified":1677829317036},{"_id":"themes/bear/_partial/aboutme.pug","hash":"f5b14bf80997bd398f746c0e7072a8ab5e1c767a","modified":1678240033568},{"_id":"themes/bear/_partial/google-analytics.pug","hash":"c75e26872935030e2a7c7846f43e3bbf0b43a9ff","modified":1677829317036},{"_id":"themes/bear/_partial/header.pug","hash":"03bf88c5654f3071a757cb817ea794e9a2e09924","modified":1678241709288},{"_id":"themes/bear/layout/archive.pug","hash":"ac61917e785e06c9e715472f7fc58a7fb4aee7e7","modified":1678240694143},{"_id":"themes/bear/_partial/post_footer.pug","hash":"30127766cc23fcb74cc2064ab8f06df1aa3a717f","modified":1677829317036},{"_id":"themes/bear/_partial/layout.pug","hash":"db695bce2f7d7af9ded4818e4d183bfb26fa8dbe","modified":1678240070291},{"_id":"themes/bear/layout/index.pug","hash":"6747a6a707dcbd765f42a38b5593fe7c1384eddb","modified":1677829317036},{"_id":"themes/bear/layout/post.pug","hash":"cbe3d59af0b8486dfc63f53d3982ac4c4db307f7","modified":1677829317036},{"_id":"themes/bear/source/images/avatar.png","hash":"a7c68a10d1a1357e4ec55891fc8a22d744b653d2","modified":1677829317052},{"_id":"themes/bear/source/.DS_Store","hash":"a533b17b008db177bb92835a7fadb3012f268058","modified":1677829317036},{"_id":"themes/bear/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1677829317051},{"_id":"themes/bear/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1677829317036},{"_id":"themes/bear/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1677829317036},{"_id":"themes/bear/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1677829317051},{"_id":"themes/bear/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1677829317052},{"_id":"themes/bear/source/script/index.js","hash":"6cb1c4f7bf44d8fb4a4af7fd260d39c0439daadc","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1677829317052},{"_id":"themes/bear/source/script/post.js","hash":"6b057a9ae5bc7d06cc67110f9651a77ed2fe8046","modified":1677829317052},{"_id":"themes/bear/source/styles/_extend.styl","hash":"82ab5ec19935d3a1cb3022f5f5c245f6ff7efe03","modified":1677829317052},{"_id":"themes/bear/source/styles/site.styl","hash":"1ff8e1d4f8777c3d918824fa134830476de79f51","modified":1677829317052},{"_id":"themes/bear/source/styles/_variables.styl","hash":"283c80570908bf83b0efd6ae1f524699eb5036a2","modified":1677829317052},{"_id":"themes/bear/source/images/socials/email.svg","hash":"866629becff21ec0d0bfc5980937c0a973e04c15","modified":1677829317052},{"_id":"themes/bear/source/images/check.svg","hash":"9e891aa1036fdeaf556d50854bb70a0d7175724b","modified":1677829317052},{"_id":"themes/bear/source/images/socials/github.svg","hash":"1dce3ba17c25257e195f6935d7cb227340fd3022","modified":1677829317052},{"_id":"themes/bear/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1677829317052},{"_id":"themes/bear/source/images/socials/instagram.svg","hash":"4cc77b3b2c2118b9e24b91a02e370dbc8456d24c","modified":1677829317052},{"_id":"themes/bear/source/images/socials/flickr.svg","hash":"5cb21fb6aa9295f97010ba434171d5222a706c36","modified":1677829317052},{"_id":"themes/bear/source/images/socials/wechat.svg","hash":"5524c7d161217e60f5dab9939f5475782fa314a2","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1677829317052},{"_id":"themes/bear/source/images/socials/facebook.svg","hash":"cc023ecafafda29e079736b2e287e9bcd32a9e0f","modified":1677829317052},{"_id":"themes/bear/source/images/socials/google.svg","hash":"47521c7f23b71fd55e1a19b81e23ab9373fc0225","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/aboutme.styl","hash":"1622faeaa3c410878fcd1f7f9988c5230accc307","modified":1677829317052},{"_id":"themes/bear/source/images/socials/weibo.svg","hash":"afc8e42094cd45aaca15c243caaf337968ec426d","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/archive.styl","hash":"40692d9092f7e158465a79771d04fe3a8ec4bf72","modified":1678523083600},{"_id":"themes/bear/source/styles/_partial/article.styl","hash":"961969a243fbbab4a5b6a0a908222e940b781f2a","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/footer.styl","hash":"480bc266846cc534bea0583a909a15cf01752c2c","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/header.styl","hash":"d706f703001406b4991e86839b9624e7d64acd5e","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/highlight.styl","hash":"a7bd88c9fd067403f9fdfe69b0de992f364fe2e8","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/theme.styl","hash":"7d089d66ec5b05e0f0ea0a15ce09e9379818a350","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1677829317052},{"_id":"source/images/docker/container-command.png","hash":"0743524fd1c2aa7e5143a199a46e548e833cc015","modified":1678060431357},{"_id":"source/images/docker/container-options.png","hash":"73805ec4eead8fb2207f6b42260e9440d5f2a2b4","modified":1678059380567},{"_id":"source/images/docker/composition.png","hash":"6abb4f461eeaac697f9cb09bc2cc5dc6cf94acea","modified":1677835017810},{"_id":"source/images/redis/memory.png","hash":"972e3bd9eff09d9a7d7da822c6cdf195654ae6b9","modified":1680604190250},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1677829317052},{"_id":"themes/bear/pnpm-lock.yaml","hash":"5db239a8f0479833816e5a6dfee24fdcdd8f237f","modified":1685176673264},{"_id":"themes/bear/source/script/jquery.min.js","hash":"745ab5d6e434cf8d321779da3c527b6d301e2b50","modified":1677829317052},{"_id":"source/images/redis/key.png","hash":"e494d047a966f0b5cd58cef1be661025bf8f7d07","modified":1680478303635},{"_id":"themes/bear/package-lock.json","hash":"2333a1f3c896e122e9e039e82a92ed57fdb6ab42","modified":1677829317036},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1677829317052},{"_id":"themes/bear/screenshot.jpg","hash":"a5a295578ab8e324257f5618e41397c91403db5a","modified":1677829317036},{"_id":"themes/bear/screenshot2.jpg","hash":"56a02cf741ea2673e175254ef9a4d02ef369a1f5","modified":1677829317036},{"_id":"public/2023/05/17/go/reflect/index.html","hash":"742fd7115496ddeba9cee0a5ad536adf3a843bd2","modified":1688192645107},{"_id":"public/2023/03/10/go/log/index.html","hash":"279441b7dd6c62b1065c5528a75dc94a267b75f6","modified":1688192645107},{"_id":"public/2023/03/10/git/fork/index.html","hash":"8ca3ebf338d687e88b1226c17c3e55513610519c","modified":1688192645107},{"_id":"public/archives/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/archives/2023/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/archives/2023/03/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/archives/2023/04/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/archives/2023/05/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/web/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/docker/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/git/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/fork/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/go/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/ioc/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/控制反转/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/依赖注入/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/reflect/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/gorus/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/rotatelogs/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/ifshook/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/pipe/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/channel/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/redis/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/string/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/list/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/hash/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/set/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/zset/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/index.html","hash":"e8fbc0d9d31b50486646d156757d6c73dcb64918","modified":1693580844967},{"_id":"public/2023/05/19/go/ioc/index.html","hash":"a645f84d392898795ac8ce5dd2da9a3d7606240f","modified":1688192645107},{"_id":"public/2023/04/02/redis/base/index.html","hash":"cebd3d5ec3501077c7ff1bb5357f9261a3dcba75","modified":1688192645107},{"_id":"public/2023/03/30/go/pipe/index.html","hash":"52955b9e983c728770f62abfb77af3ddd350f38c","modified":1688192645107},{"_id":"public/2023/03/03/docker/index.html","hash":"ad8e759400dbc0457b3659dd577391d92d0ed635","modified":1684476364864},{"_id":"public/images/git/fork-remote.png","hash":"4fc4ff99088c23b165d4e628efd7a8e3360c306a","modified":1688192645107},{"_id":"public/images/docker/dockerfile.png","hash":"43920921835d74aba2c1ed6c96c2e1ec5acbb0c3","modified":1688192645107},{"_id":"public/images/git/微信截图_20230327103738.png","hash":"4ea65f1b32bc8902d3ede33a308fb76376e85caa","modified":1688192645107},{"_id":"public/images/redis/list.png","hash":"63773914754e857095905d551e46587f12cdf862","modified":1688192645107},{"_id":"public/images/go/ioc/case1.png","hash":"45576d7ffdfaad4440116c6536c92c30991098bf","modified":1688192645107},{"_id":"public/images/go/pipe/pipe3.png","hash":"4f16d115f18c33bbbf9a97c25f07b28cad550c8a","modified":1688192645107},{"_id":"public/images/go/ioc/case2.png","hash":"ca2f15145602dec4ccebb740f2268e668d140970","modified":1688192645107},{"_id":"public/images/go/pipe/pipe2.png","hash":"5c71c9d47d927e1ea9eb7567817c1366ceb6fb13","modified":1688192645107},{"_id":"public/images/go/pipe/pipe1.png","hash":"0e88ba7c6a3d0f39d563bc877daf8505c8a0d90c","modified":1688192645107},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1688192645107},{"_id":"public/images/avatar.png","hash":"a7c68a10d1a1357e4ec55891fc8a22d744b653d2","modified":1688192645107},{"_id":"public/images/check.svg","hash":"9e891aa1036fdeaf556d50854bb70a0d7175724b","modified":1688192645107},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1688192645107},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1688192645107},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1688192645107},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1688192645107},{"_id":"public/images/socials/email.svg","hash":"866629becff21ec0d0bfc5980937c0a973e04c15","modified":1688192645107},{"_id":"public/images/socials/facebook.svg","hash":"cc023ecafafda29e079736b2e287e9bcd32a9e0f","modified":1688192645107},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1688192645107},{"_id":"public/images/socials/github.svg","hash":"1dce3ba17c25257e195f6935d7cb227340fd3022","modified":1688192645107},{"_id":"public/images/socials/flickr.svg","hash":"5cb21fb6aa9295f97010ba434171d5222a706c36","modified":1688192645107},{"_id":"public/images/socials/wechat.svg","hash":"5524c7d161217e60f5dab9939f5475782fa314a2","modified":1688192645107},{"_id":"public/images/socials/instagram.svg","hash":"4cc77b3b2c2118b9e24b91a02e370dbc8456d24c","modified":1688192645107},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1688192645107},{"_id":"public/images/socials/weibo.svg","hash":"afc8e42094cd45aaca15c243caaf337968ec426d","modified":1688192645107},{"_id":"public/images/socials/google.svg","hash":"47521c7f23b71fd55e1a19b81e23ab9373fc0225","modified":1688192645107},{"_id":"public/images/docker/container-command.png","hash":"0743524fd1c2aa7e5143a199a46e548e833cc015","modified":1688192645107},{"_id":"public/images/docker/composition.png","hash":"6abb4f461eeaac697f9cb09bc2cc5dc6cf94acea","modified":1688192645107},{"_id":"public/images/docker/container-options.png","hash":"73805ec4eead8fb2207f6b42260e9440d5f2a2b4","modified":1688192645107},{"_id":"public/images/redis/memory.png","hash":"972e3bd9eff09d9a7d7da822c6cdf195654ae6b9","modified":1688192645107},{"_id":"public/script/index.js","hash":"3be07c789aa4a521a31f3c59a98933ee9f8c85aa","modified":1688192645107},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1688192645107},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1688192645107},{"_id":"public/script/post.js","hash":"ad6bdffb5a7f722f469e65c2061e56a434479de5","modified":1688192645107},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1688192645107},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1688192645107},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1688192645107},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1688192645107},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1688192645107},{"_id":"public/styles/site.css","hash":"58fe37adeba5e0d30094e2770c0226caf229c100","modified":1688192645107},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1688192645107},{"_id":"public/script/jquery.min.js","hash":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d","modified":1688192645107},{"_id":"public/images/redis/key.png","hash":"e494d047a966f0b5cd58cef1be661025bf8f7d07","modified":1688192645107},{"_id":"source/_posts/docker/docker.md","hash":"645da19eef86c93a183de9070057f1719a31f01d","modified":1685176673260},{"_id":"source/_drafts/go-limit.md","hash":"fab945e469a2547d1f0e264343f5df4866c6cb49","modified":1685176673259},{"_id":"source/_drafts/grpc.md","hash":"9c0c6caef7ed6de8adc6d12d95610e5b5121a484","modified":1684914343068},{"_id":"public/2023/03/03/docker/docker/index.html","hash":"53b652b813a25c6c884b68e7e5f97d8ae8eeb1a5","modified":1688192645107},{"_id":"source/_posts/go/grpc.md","hash":"13901d4bb6f5714c2513b68559e2621a6b7c1396","modified":1685712002560},{"_id":"public/tags/grpc/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/2023/05/25/go/grpc/index.html","hash":"3925f5b6c1d4d126390b9be50da8da8318ac0393","modified":1688192645107},{"_id":"source/images/linux/dhcp.png","hash":"ade267312ec674daa41df0a3dc1c8ba90a6578fc","modified":1685431348706},{"_id":"source/images/linux/nat.png","hash":"f02664ac31fbddf939e8c8d8e3cde7a244e42b0b","modified":1685431348710},{"_id":"source/_posts/linux/centos-core-up.md","hash":"fde37fd15cf140613ef833d517b69632731441bd","modified":1685431828523},{"_id":"source/images/linux/network.png","hash":"6888b2753383db6fa3474c54df7f5f51c70e8baa","modified":1685431348720},{"_id":"source/images/linux/setting.png","hash":"4ef0a59e200862794f3b41cf30c0d98c1b2a7fba","modified":1685431348725},{"_id":"source/images/linux/vmware-1.png","hash":"fd3a9d1b450b5c0aefdc33f0b13edb48edb3888e","modified":1685431348743},{"_id":"source/_posts/linux/vmware-network.md","hash":"eb93397be2ff923fc1f9d0dabc448d2b503c0a39","modified":1685432303528},{"_id":"source/images/linux/static-ip.png","hash":"8814db089395725190d7ac5121c6379e0bad85f1","modified":1685431348738},{"_id":"public/2023/05/30/linux/vmware-network/index.html","hash":"1dcd4d8581bfd0e35102005eb781b0fcfffde64c","modified":1688192645107},{"_id":"public/2023/05/30/linux/centos-core-up/index.html","hash":"38e404960956826991bf92409ac143072f74eaea","modified":1688192645107},{"_id":"public/tags/linux/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/centos/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/vmware/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/network/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/images/linux/dhcp.png","hash":"ade267312ec674daa41df0a3dc1c8ba90a6578fc","modified":1688192645107},{"_id":"public/images/linux/nat.png","hash":"f02664ac31fbddf939e8c8d8e3cde7a244e42b0b","modified":1688192645107},{"_id":"public/images/linux/vmware-1.png","hash":"fd3a9d1b450b5c0aefdc33f0b13edb48edb3888e","modified":1688192645107},{"_id":"public/images/linux/network.png","hash":"6888b2753383db6fa3474c54df7f5f51c70e8baa","modified":1688192645107},{"_id":"public/images/linux/setting.png","hash":"4ef0a59e200862794f3b41cf30c0d98c1b2a7fba","modified":1688192645107},{"_id":"public/images/linux/static-ip.png","hash":"8814db089395725190d7ac5121c6379e0bad85f1","modified":1688192645107},{"_id":"source/_posts/node/framework.md","hash":"b623b83e43decc3c223637bdff1e9edb69e1b602","modified":1688230606125},{"_id":"source/images/node/framework/framework.png","hash":"3c524b66419802da8b24b97a1acb0f2cffaea5c7","modified":1688215402274},{"_id":"source/_drafts/kubernetes/rancher2.md","hash":"d253e61e67e0a6e5373f93405ce2da6c581db5d3","modified":1685788831153},{"_id":"public/2023/07/01/node/framework/index.html","hash":"b1316e82e2581fa73ca316e1e1736a9a53bec955","modified":1693580844967},{"_id":"public/page/2/index.html","hash":"e8fbc0d9d31b50486646d156757d6c73dcb64918","modified":1693580844967},{"_id":"public/tags/nodejs/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/framework/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/archives/page/2/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/archives/2023/page/2/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/archives/2023/07/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/images/node/framework/framework.png","hash":"3c524b66419802da8b24b97a1acb0f2cffaea5c7","modified":1688230614996},{"_id":"source/images/node/framework/nodejs_worker.png","hash":"81262e0077ac7f5d0c60e556c7a751c7cb37fef6","modified":1688230529210},{"_id":"public/images/node/framework/nodejs_worker.png","hash":"81262e0077ac7f5d0c60e556c7a751c7cb37fef6","modified":1688230614996},{"_id":"source/_drafts/linux-base.md","hash":"a385e8273016d876636e25a8039df20f30d689e3","modified":1693580587962},{"_id":"source/_posts/cicd/gitlab.md","hash":"1fb33e5568f647e8e56a72d4428d1f67e61e2f36","modified":1689389260002},{"_id":"source/images/cicd/runner-create.png","hash":"6e7b1e07047065b6bb42202ae0c9fe9af2f99c40","modified":1689389106450},{"_id":"source/images/cicd/runner-register.png","hash":"bba1267b0072fb54836aa16e6988586020f5e62d","modified":1689389299687},{"_id":"public/2023/07/15/cicd/gitlab/index.html","hash":"263cb7f9590150d5a3e8f9b38ceee56dd8318fe7","modified":1693580844967},{"_id":"public/tags/ci/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/cd/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/tags/gitlab/index.html","hash":"b331ee39c347994d3f5d82978a3e32989b05aea7","modified":1693580844967},{"_id":"public/images/cicd/runner-create.png","hash":"6e7b1e07047065b6bb42202ae0c9fe9af2f99c40","modified":1693580844967},{"_id":"public/images/cicd/runner-register.png","hash":"bba1267b0072fb54836aa16e6988586020f5e62d","modified":1693580844967}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"hexo-command","_content":"\n### 基本命令\n\n```bash\n# 生成静态文件\nhexo g \n# 启动本地服务\nhexo s\n# 提交到gitee\nhexo d\n# 清除缓存\nhexo clean\n\n# 通过模板生成文章\nhexo new page --path \"redis/base\"\n\n# 创建草稿\nhexo new draft <filename>\n\n# 本机预览草稿\nhexo S --draft\n\n# 草稿发布为正式文章\nhexo P <filename>\n```","source":"_drafts/hexo-command.md","raw":"---\ntitle: hexo-command\ntags: [\"hexo\"]\n---\n\n### 基本命令\n\n```bash\n# 生成静态文件\nhexo g \n# 启动本地服务\nhexo s\n# 提交到gitee\nhexo d\n# 清除缓存\nhexo clean\n\n# 通过模板生成文章\nhexo new page --path \"redis/base\"\n\n# 创建草稿\nhexo new draft <filename>\n\n# 本机预览草稿\nhexo S --draft\n\n# 草稿发布为正式文章\nhexo P <filename>\n```","slug":"hexo-command","published":0,"date":"2023-05-27T08:37:53.259Z","updated":"2023-05-27T08:37:53.259Z","_id":"clhu5qi4d00026oupfnqb8o9w","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成静态文件</span></span><br><span class=\"line\">hexo g </span><br><span class=\"line\"><span class=\"comment\"># 启动本地服务</span></span><br><span class=\"line\">hexo s</span><br><span class=\"line\"><span class=\"comment\"># 提交到gitee</span></span><br><span class=\"line\">hexo d</span><br><span class=\"line\"><span class=\"comment\"># 清除缓存</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过模板生成文章</span></span><br><span class=\"line\">hexo new page --path <span class=\"string\">&quot;redis/base&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建草稿</span></span><br><span class=\"line\">hexo new draft &lt;filename&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本机预览草稿</span></span><br><span class=\"line\">hexo S --draft</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 草稿发布为正式文章</span></span><br><span class=\"line\">hexo P &lt;filename&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成静态文件</span></span><br><span class=\"line\">hexo g </span><br><span class=\"line\"><span class=\"comment\"># 启动本地服务</span></span><br><span class=\"line\">hexo s</span><br><span class=\"line\"><span class=\"comment\"># 提交到gitee</span></span><br><span class=\"line\">hexo d</span><br><span class=\"line\"><span class=\"comment\"># 清除缓存</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过模板生成文章</span></span><br><span class=\"line\">hexo new page --path <span class=\"string\">&quot;redis/base&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建草稿</span></span><br><span class=\"line\">hexo new draft &lt;filename&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本机预览草稿</span></span><br><span class=\"line\">hexo S --draft</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 草稿发布为正式文章</span></span><br><span class=\"line\">hexo P &lt;filename&gt;</span><br></pre></td></tr></table></figure>"},{"title":"K8s","date":"2023-05-09T13:46:14.000Z","excerpt":"k8s集群环境搭建","_content":"## 集群环境搭建\n一台master主机，2台node节点机器，都是采用虚拟机系统都是centos7，linux内核6.x，配置都是4核4G 100G磁盘，请自行安装虚拟机\n\n### Linux系统设置\n\n#### 设置系统主机名以及 Host 文件的相互解析\n1. 设置系统主机名\n```bash\n# 设置系统主机名\nhostnamectl set-hostname k8s-master01\nhostnamectl set-hostname k8s-node01\nhostnamectl set-hostname k8s-node02\n```\n2. 配置Host 文件的相互解析\n```bash\nvim /etc/hosts\n\n# 根据自己的网络ip地址自行配置host解析\n192.168.150.130 k8s-master01\n192.168.150.131 k8s-node01\n192.168.150.132 k8s-node02\n# 将host配置拷贝到node节点\nscp /etc/hosts root@k8s-node01:/etc/hosts\nscp /etc/hosts root@k8s-node02:/etc/hosts\n```\n\n#### 安装依赖包\n```bash\nyum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git\n```\n\n#### 设置防火墙为 Iptables 并设置空规则\n```bash\nsystemctl stop firewalld && systemctl disable firewalld\n\nyum -y install iptables-services && systemctl start iptables && systemctl enable iptables && iptables -F && service iptables save\n```\n\n#### 关闭 SELINUX\n```bash\nswapoff -a && sed -i '/ swap / s/^\\(.*\\)$/#\\1/g' /etc/fstab\n\nsetenforce 0 && sed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config\n```\n\n#### 调整内核参数，对于 K8S\n```bash\ncat > kubernetes.conf <<EOF\nnet.bridge.bridge-nf-call-iptables=1\nnet.bridge.bridge-nf-call-ip6tables=1\nnet.ipv4.ip_forward=1\nnet.ipv4.tcp_tw_recycle=0\nvm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它\nvm.overcommit_memory=1 # 不检查物理内存是否够用\nvm.panic_on_oom=0 # 开启 OOM\nfs.inotify.max_user_instances=8192\nfs.inotify.max_user_watches=1048576\nfs.file-max=52706963\nfs.nr_open=52706963\nnet.ipv6.conf.all.disable_ipv6=1\nnet.netfilter.nf_conntrack_max=2310720\nEOF\n\ncp kubernetes.conf /etc/sysctl.d/kubernetes.conf\n\nsysctl -p /etc/sysctl.d/kubernetes.conf\n```\n\n#### 调整系统时区\n```bash\n# 设置系统时区为 中国/上海\ntimedatectl set-timezone Asia/Shanghai\n# 将当前的 UTC 时间写入硬件时钟\ntimedatectl set-local-rtc 0\n# 重启依赖于系统时间的服务\nsystemctl restart rsyslog\nsystemctl restart crond\n```\n\n#### 关闭系统不需要服务\n```bash\nsystemctl stop postfix && systemctl disable postfix\n```\n\n#### 设置 rsyslogd 和 systemd journald\n```bash\nmkdir /var/log/journal # 持久化保存日志的目录\n\nmkdir /etc/systemd/journald.conf.d\n\ncat > /etc/systemd/journald.conf.d/99-prophet.conf <<EOF\n[Journal]\n# 持久化保存到磁盘\nStorage=persistent\n# 压缩历史日志\nCompress=yes\nSyncIntervalSec=5m\nRateLimitInterval=30s\nRateLimitBurst=1000\n# 最大占用空间 10G\nSystemMaxUse=10G\n# 单日志文件最大 200M\nSystemMaxFileSize=200M\n# 日志保存时间 2 周\nMaxRetentionSec=2week\n# 不将日志转发到 syslog\nForwardToSyslog=no\nEOF\n\nsystemctl restart systemd-journald\n```\n\n#### 升级系统内核为 4.44\nCentOS 7.x 系统自带的 3.10.x 内核存在一些 Bugs，导致运行的 Docker、Kubernetes 不稳定，例如： rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\n```bash\nrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\n# 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次！\nyum --enablerepo=elrepo-kernel install -y kernel-lt\n# 设置开机从新内核启动\ngrub2-set-default 'CentOS Linux (4.4.189-1.el7.elrepo.x86_64) 7 (Core)'\n```\n\n\n### Kubeadm部署安装\n\n#### kube-proxy开启ipvs的前置条件\n```bash\nmodprobe br_netfilter\n\ncat > /etc/sysconfig/modules/ipvs.modules <<EOF\n#!/bin/bash\nmodprobe -- ip_vs\nmodprobe -- ip_vs_rr\nmodprobe -- ip_vs_wrr\nmodprobe -- ip_vs_sh\nmodprobe -- nf_conntrack\nEOF\n\nchmod 755 /etc/sysconfig/modules/ipvs.modules && bash /etc/sysconfig/modules/ipvs.modules && lsmod | grep -e ip_vs -e nf_conntrack\n```\n\n#### 安装 Docker 软件\n```bash\nyum install -y yum-utils device-mapper-persistent-data lvm2\n\nyum-config-manager \\\n--add-repo \\\nhttp://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\nyum update -y && yum install -y docker-ce\n\n#安装完成后重启机器\nreboot\n\n# 启动docker并设置开机自启\nsystemctl start docker && systemctl enable docker\n\n## 创建 /etc/docker 目录\nmkdir /etc/docker\n\n# 配置 daemon.\ncat > /etc/docker/daemon.json <<EOF\n{\n\"exec-opts\": [\"native.cgroupdriver=systemd\"],\n\"log-driver\": \"json-file\",\n\"log-opts\": {\n\"max-size\": \"100m\"\n}\n}\nEOF\n\nmkdir -p /etc/systemd/system/docker.service.d\n\n# 重启docker服务\nsystemctl daemon-reload && systemctl restart docker && systemctl enable docker\n```\n\n#### 安装 Kubeadm （主从配置）\n```bash\ncat <<EOF > /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64\nenabled=1\ngpgcheck=0\nrepo_gpgcheck=0\ngpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\nhttp://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n\nyum -y install kubeadm-1.15.1 kubectl-1.15.1 kubelet-1.15.1\n\nsystemctl enable kubelet.service\n```\n\n#### 初始化主节点\n\n```bash\nkubeadm config print init-defaults > kubeadm-config.yaml\nlocalAPIEndpoint:\nadvertiseAddress: 192.168.66.10\nkubernetesVersion: v1.15.1\nnetworking:\npodSubnet: \"10.244.0.0/16\"\nserviceSubnet: 10.96.0.0/12\n---\napiVersion: kubeproxy.config.k8s.io/v1alpha1\nkind: KubeProxyConfiguration\nfeatureGates:\nSupportIPVSProxyMode: true\nmode: ipvs\nkubeadm init --config=kubeadm-config.yaml --experimental-upload-certs | tee kubeadm-init.log\n```","source":"_drafts/kubernetes/base.md","raw":"---\ntitle: K8s\ndate: 2023-05-09 21:46:14\ntags: [\"k8s\", \"架构\", \"集群\", \"运开\"]\nexcerpt: k8s集群环境搭建\n---\n## 集群环境搭建\n一台master主机，2台node节点机器，都是采用虚拟机系统都是centos7，linux内核6.x，配置都是4核4G 100G磁盘，请自行安装虚拟机\n\n### Linux系统设置\n\n#### 设置系统主机名以及 Host 文件的相互解析\n1. 设置系统主机名\n```bash\n# 设置系统主机名\nhostnamectl set-hostname k8s-master01\nhostnamectl set-hostname k8s-node01\nhostnamectl set-hostname k8s-node02\n```\n2. 配置Host 文件的相互解析\n```bash\nvim /etc/hosts\n\n# 根据自己的网络ip地址自行配置host解析\n192.168.150.130 k8s-master01\n192.168.150.131 k8s-node01\n192.168.150.132 k8s-node02\n# 将host配置拷贝到node节点\nscp /etc/hosts root@k8s-node01:/etc/hosts\nscp /etc/hosts root@k8s-node02:/etc/hosts\n```\n\n#### 安装依赖包\n```bash\nyum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git\n```\n\n#### 设置防火墙为 Iptables 并设置空规则\n```bash\nsystemctl stop firewalld && systemctl disable firewalld\n\nyum -y install iptables-services && systemctl start iptables && systemctl enable iptables && iptables -F && service iptables save\n```\n\n#### 关闭 SELINUX\n```bash\nswapoff -a && sed -i '/ swap / s/^\\(.*\\)$/#\\1/g' /etc/fstab\n\nsetenforce 0 && sed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config\n```\n\n#### 调整内核参数，对于 K8S\n```bash\ncat > kubernetes.conf <<EOF\nnet.bridge.bridge-nf-call-iptables=1\nnet.bridge.bridge-nf-call-ip6tables=1\nnet.ipv4.ip_forward=1\nnet.ipv4.tcp_tw_recycle=0\nvm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它\nvm.overcommit_memory=1 # 不检查物理内存是否够用\nvm.panic_on_oom=0 # 开启 OOM\nfs.inotify.max_user_instances=8192\nfs.inotify.max_user_watches=1048576\nfs.file-max=52706963\nfs.nr_open=52706963\nnet.ipv6.conf.all.disable_ipv6=1\nnet.netfilter.nf_conntrack_max=2310720\nEOF\n\ncp kubernetes.conf /etc/sysctl.d/kubernetes.conf\n\nsysctl -p /etc/sysctl.d/kubernetes.conf\n```\n\n#### 调整系统时区\n```bash\n# 设置系统时区为 中国/上海\ntimedatectl set-timezone Asia/Shanghai\n# 将当前的 UTC 时间写入硬件时钟\ntimedatectl set-local-rtc 0\n# 重启依赖于系统时间的服务\nsystemctl restart rsyslog\nsystemctl restart crond\n```\n\n#### 关闭系统不需要服务\n```bash\nsystemctl stop postfix && systemctl disable postfix\n```\n\n#### 设置 rsyslogd 和 systemd journald\n```bash\nmkdir /var/log/journal # 持久化保存日志的目录\n\nmkdir /etc/systemd/journald.conf.d\n\ncat > /etc/systemd/journald.conf.d/99-prophet.conf <<EOF\n[Journal]\n# 持久化保存到磁盘\nStorage=persistent\n# 压缩历史日志\nCompress=yes\nSyncIntervalSec=5m\nRateLimitInterval=30s\nRateLimitBurst=1000\n# 最大占用空间 10G\nSystemMaxUse=10G\n# 单日志文件最大 200M\nSystemMaxFileSize=200M\n# 日志保存时间 2 周\nMaxRetentionSec=2week\n# 不将日志转发到 syslog\nForwardToSyslog=no\nEOF\n\nsystemctl restart systemd-journald\n```\n\n#### 升级系统内核为 4.44\nCentOS 7.x 系统自带的 3.10.x 内核存在一些 Bugs，导致运行的 Docker、Kubernetes 不稳定，例如： rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\n```bash\nrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\n# 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次！\nyum --enablerepo=elrepo-kernel install -y kernel-lt\n# 设置开机从新内核启动\ngrub2-set-default 'CentOS Linux (4.4.189-1.el7.elrepo.x86_64) 7 (Core)'\n```\n\n\n### Kubeadm部署安装\n\n#### kube-proxy开启ipvs的前置条件\n```bash\nmodprobe br_netfilter\n\ncat > /etc/sysconfig/modules/ipvs.modules <<EOF\n#!/bin/bash\nmodprobe -- ip_vs\nmodprobe -- ip_vs_rr\nmodprobe -- ip_vs_wrr\nmodprobe -- ip_vs_sh\nmodprobe -- nf_conntrack\nEOF\n\nchmod 755 /etc/sysconfig/modules/ipvs.modules && bash /etc/sysconfig/modules/ipvs.modules && lsmod | grep -e ip_vs -e nf_conntrack\n```\n\n#### 安装 Docker 软件\n```bash\nyum install -y yum-utils device-mapper-persistent-data lvm2\n\nyum-config-manager \\\n--add-repo \\\nhttp://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\nyum update -y && yum install -y docker-ce\n\n#安装完成后重启机器\nreboot\n\n# 启动docker并设置开机自启\nsystemctl start docker && systemctl enable docker\n\n## 创建 /etc/docker 目录\nmkdir /etc/docker\n\n# 配置 daemon.\ncat > /etc/docker/daemon.json <<EOF\n{\n\"exec-opts\": [\"native.cgroupdriver=systemd\"],\n\"log-driver\": \"json-file\",\n\"log-opts\": {\n\"max-size\": \"100m\"\n}\n}\nEOF\n\nmkdir -p /etc/systemd/system/docker.service.d\n\n# 重启docker服务\nsystemctl daemon-reload && systemctl restart docker && systemctl enable docker\n```\n\n#### 安装 Kubeadm （主从配置）\n```bash\ncat <<EOF > /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64\nenabled=1\ngpgcheck=0\nrepo_gpgcheck=0\ngpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\nhttp://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n\nyum -y install kubeadm-1.15.1 kubectl-1.15.1 kubelet-1.15.1\n\nsystemctl enable kubelet.service\n```\n\n#### 初始化主节点\n\n```bash\nkubeadm config print init-defaults > kubeadm-config.yaml\nlocalAPIEndpoint:\nadvertiseAddress: 192.168.66.10\nkubernetesVersion: v1.15.1\nnetworking:\npodSubnet: \"10.244.0.0/16\"\nserviceSubnet: 10.96.0.0/12\n---\napiVersion: kubeproxy.config.k8s.io/v1alpha1\nkind: KubeProxyConfiguration\nfeatureGates:\nSupportIPVSProxyMode: true\nmode: ipvs\nkubeadm init --config=kubeadm-config.yaml --experimental-upload-certs | tee kubeadm-init.log\n```","slug":"kubernetes/base","published":0,"updated":"2023-06-03T06:42:42.007Z","_id":"clhu5qi4h00046oupcq8ccshp","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"集群环境搭建\"><a href=\"#集群环境搭建\" class=\"headerlink\" title=\"集群环境搭建\"></a>集群环境搭建</h2><p>一台master主机，2台node节点机器，都是采用虚拟机系统都是centos7，linux内核6.x，配置都是4核4G 100G磁盘，请自行安装虚拟机</p>\n<h3 id=\"Linux系统设置\"><a href=\"#Linux系统设置\" class=\"headerlink\" title=\"Linux系统设置\"></a>Linux系统设置</h3><h4 id=\"设置系统主机名以及-Host-文件的相互解析\"><a href=\"#设置系统主机名以及-Host-文件的相互解析\" class=\"headerlink\" title=\"设置系统主机名以及 Host 文件的相互解析\"></a>设置系统主机名以及 Host 文件的相互解析</h4><ol>\n<li>设置系统主机名<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置系统主机名</span></span><br><span class=\"line\">hostnamectl set-hostname k8s-master01</span><br><span class=\"line\">hostnamectl set-hostname k8s-node01</span><br><span class=\"line\">hostnamectl set-hostname k8s-node02</span><br></pre></td></tr></table></figure></li>\n<li>配置Host 文件的相互解析<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/hosts</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据自己的网络ip地址自行配置host解析</span></span><br><span class=\"line\">192.168.150.130 k8s-master01</span><br><span class=\"line\">192.168.150.131 k8s-node01</span><br><span class=\"line\">192.168.150.132 k8s-node02</span><br><span class=\"line\"><span class=\"comment\"># 将host配置拷贝到node节点</span></span><br><span class=\"line\">scp /etc/hosts root@k8s-node01:/etc/hosts</span><br><span class=\"line\">scp /etc/hosts root@k8s-node02:/etc/hosts</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置防火墙为-Iptables-并设置空规则\"><a href=\"#设置防火墙为-Iptables-并设置空规则\" class=\"headerlink\" title=\"设置防火墙为 Iptables 并设置空规则\"></a>设置防火墙为 Iptables 并设置空规则</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld &amp;&amp; systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"></span><br><span class=\"line\">yum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl <span class=\"built_in\">enable</span> iptables &amp;&amp; iptables -F &amp;&amp; service iptables save</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关闭-SELINUX\"><a href=\"#关闭-SELINUX\" class=\"headerlink\" title=\"关闭 SELINUX\"></a>关闭 SELINUX</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swapoff -a &amp;&amp; sed -i <span class=\"string\">&#x27;/ swap / s/^\\(.*\\)$/#\\1/g&#x27;</span> /etc/fstab</span><br><span class=\"line\"></span><br><span class=\"line\">setenforce 0 &amp;&amp; sed -i <span class=\"string\">&#x27;s/^SELINUX=.*/SELINUX=disabled/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调整内核参数，对于-K8S\"><a href=\"#调整内核参数，对于-K8S\" class=\"headerlink\" title=\"调整内核参数，对于 K8S\"></a>调整内核参数，对于 K8S</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; kubernetes.conf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-iptables=1</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-ip6tables=1</span></span><br><span class=\"line\"><span class=\"string\">net.ipv4.ip_forward=1</span></span><br><span class=\"line\"><span class=\"string\">net.ipv4.tcp_tw_recycle=0</span></span><br><span class=\"line\"><span class=\"string\">vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它</span></span><br><span class=\"line\"><span class=\"string\">vm.overcommit_memory=1 # 不检查物理内存是否够用</span></span><br><span class=\"line\"><span class=\"string\">vm.panic_on_oom=0 # 开启 OOM</span></span><br><span class=\"line\"><span class=\"string\">fs.inotify.max_user_instances=8192</span></span><br><span class=\"line\"><span class=\"string\">fs.inotify.max_user_watches=1048576</span></span><br><span class=\"line\"><span class=\"string\">fs.file-max=52706963</span></span><br><span class=\"line\"><span class=\"string\">fs.nr_open=52706963</span></span><br><span class=\"line\"><span class=\"string\">net.ipv6.conf.all.disable_ipv6=1</span></span><br><span class=\"line\"><span class=\"string\">net.netfilter.nf_conntrack_max=2310720</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span> kubernetes.conf /etc/sysctl.d/kubernetes.conf</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -p /etc/sysctl.d/kubernetes.conf</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调整系统时区\"><a href=\"#调整系统时区\" class=\"headerlink\" title=\"调整系统时区\"></a>调整系统时区</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置系统时区为 中国/上海</span></span><br><span class=\"line\">timedatectl set-timezone Asia/Shanghai</span><br><span class=\"line\"><span class=\"comment\"># 将当前的 UTC 时间写入硬件时钟</span></span><br><span class=\"line\">timedatectl set-local-rtc 0</span><br><span class=\"line\"><span class=\"comment\"># 重启依赖于系统时间的服务</span></span><br><span class=\"line\">systemctl restart rsyslog</span><br><span class=\"line\">systemctl restart crond</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关闭系统不需要服务\"><a href=\"#关闭系统不需要服务\" class=\"headerlink\" title=\"关闭系统不需要服务\"></a>关闭系统不需要服务</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop postfix &amp;&amp; systemctl <span class=\"built_in\">disable</span> postfix</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置-rsyslogd-和-systemd-journald\"><a href=\"#设置-rsyslogd-和-systemd-journald\" class=\"headerlink\" title=\"设置 rsyslogd 和 systemd journald\"></a>设置 rsyslogd 和 systemd journald</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /var/log/journal <span class=\"comment\"># 持久化保存日志的目录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /etc/systemd/journald.conf.d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/systemd/journald.conf.d/99-prophet.conf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Journal]</span></span><br><span class=\"line\"><span class=\"string\"># 持久化保存到磁盘</span></span><br><span class=\"line\"><span class=\"string\">Storage=persistent</span></span><br><span class=\"line\"><span class=\"string\"># 压缩历史日志</span></span><br><span class=\"line\"><span class=\"string\">Compress=yes</span></span><br><span class=\"line\"><span class=\"string\">SyncIntervalSec=5m</span></span><br><span class=\"line\"><span class=\"string\">RateLimitInterval=30s</span></span><br><span class=\"line\"><span class=\"string\">RateLimitBurst=1000</span></span><br><span class=\"line\"><span class=\"string\"># 最大占用空间 10G</span></span><br><span class=\"line\"><span class=\"string\">SystemMaxUse=10G</span></span><br><span class=\"line\"><span class=\"string\"># 单日志文件最大 200M</span></span><br><span class=\"line\"><span class=\"string\">SystemMaxFileSize=200M</span></span><br><span class=\"line\"><span class=\"string\"># 日志保存时间 2 周</span></span><br><span class=\"line\"><span class=\"string\">MaxRetentionSec=2week</span></span><br><span class=\"line\"><span class=\"string\"># 不将日志转发到 syslog</span></span><br><span class=\"line\"><span class=\"string\">ForwardToSyslog=no</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">systemctl restart systemd-journald</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"升级系统内核为-4-44\"><a href=\"#升级系统内核为-4-44\" class=\"headerlink\" title=\"升级系统内核为 4.44\"></a>升级系统内核为 4.44</h4><p>CentOS 7.x 系统自带的 3.10.x 内核存在一些 Bugs，导致运行的 Docker、Kubernetes 不稳定，例如： rpm -Uvh <a href=\"http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\">http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br><span class=\"line\"><span class=\"comment\"># 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次！</span></span><br><span class=\"line\">yum --enablerepo=elrepo-kernel install -y kernel-lt</span><br><span class=\"line\"><span class=\"comment\"># 设置开机从新内核启动</span></span><br><span class=\"line\">grub2-set-default <span class=\"string\">&#x27;CentOS Linux (4.4.189-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Kubeadm部署安装\"><a href=\"#Kubeadm部署安装\" class=\"headerlink\" title=\"Kubeadm部署安装\"></a>Kubeadm部署安装</h3><h4 id=\"kube-proxy开启ipvs的前置条件\"><a href=\"#kube-proxy开启ipvs的前置条件\" class=\"headerlink\" title=\"kube-proxy开启ipvs的前置条件\"></a>kube-proxy开启ipvs的前置条件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modprobe br_netfilter</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- ip_vs</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- ip_vs_rr</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- ip_vs_wrr</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- ip_vs_sh</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- nf_conntrack</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装-Docker-软件\"><a href=\"#安装-Docker-软件\" class=\"headerlink\" title=\"安装 Docker 软件\"></a>安装 Docker 软件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"></span><br><span class=\"line\">yum-config-manager \\</span><br><span class=\"line\">--add-repo \\</span><br><span class=\"line\">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\">yum update -y &amp;&amp; yum install -y docker-ce</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#安装完成后重启机器</span></span><br><span class=\"line\">reboot</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动docker并设置开机自启</span></span><br><span class=\"line\">systemctl start docker &amp;&amp; systemctl <span class=\"built_in\">enable</span> docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 创建 /etc/docker 目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /etc/docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置 daemon.</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/docker/daemon.json &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class=\"line\"><span class=\"string\">&quot;log-driver&quot;: &quot;json-file&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&quot;log-opts&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">&quot;max-size&quot;: &quot;100m&quot;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启docker服务</span></span><br><span class=\"line\">systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装-Kubeadm-（主从配置）\"><a href=\"#安装-Kubeadm-（主从配置）\" class=\"headerlink\" title=\"安装 Kubeadm （主从配置）\"></a>安装 Kubeadm （主从配置）</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=Kubernetes</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">repo_gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class=\"line\"><span class=\"string\">http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">yum -y install kubeadm-1.15.1 kubectl-1.15.1 kubelet-1.15.1</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> kubelet.service</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化主节点\"><a href=\"#初始化主节点\" class=\"headerlink\" title=\"初始化主节点\"></a>初始化主节点</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubeadm config <span class=\"built_in\">print</span> init-defaults &gt; kubeadm-config.yaml</span><br><span class=\"line\">localAPIEndpoint:</span><br><span class=\"line\">advertiseAddress: 192.168.66.10</span><br><span class=\"line\">kubernetesVersion: v1.15.1</span><br><span class=\"line\">networking:</span><br><span class=\"line\">podSubnet: <span class=\"string\">&quot;10.244.0.0/16&quot;</span></span><br><span class=\"line\">serviceSubnet: 10.96.0.0/12</span><br><span class=\"line\">---</span><br><span class=\"line\">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class=\"line\">kind: KubeProxyConfiguration</span><br><span class=\"line\">featureGates:</span><br><span class=\"line\">SupportIPVSProxyMode: <span class=\"literal\">true</span></span><br><span class=\"line\">mode: ipvs</span><br><span class=\"line\">kubeadm init --config=kubeadm-config.yaml --experimental-upload-certs | <span class=\"built_in\">tee</span> kubeadm-init.log</span><br></pre></td></tr></table></figure>","site":{"data":{}},"more":"<h2 id=\"集群环境搭建\"><a href=\"#集群环境搭建\" class=\"headerlink\" title=\"集群环境搭建\"></a>集群环境搭建</h2><p>一台master主机，2台node节点机器，都是采用虚拟机系统都是centos7，linux内核6.x，配置都是4核4G 100G磁盘，请自行安装虚拟机</p>\n<h3 id=\"Linux系统设置\"><a href=\"#Linux系统设置\" class=\"headerlink\" title=\"Linux系统设置\"></a>Linux系统设置</h3><h4 id=\"设置系统主机名以及-Host-文件的相互解析\"><a href=\"#设置系统主机名以及-Host-文件的相互解析\" class=\"headerlink\" title=\"设置系统主机名以及 Host 文件的相互解析\"></a>设置系统主机名以及 Host 文件的相互解析</h4><ol>\n<li>设置系统主机名<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置系统主机名</span></span><br><span class=\"line\">hostnamectl set-hostname k8s-master01</span><br><span class=\"line\">hostnamectl set-hostname k8s-node01</span><br><span class=\"line\">hostnamectl set-hostname k8s-node02</span><br></pre></td></tr></table></figure></li>\n<li>配置Host 文件的相互解析<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/hosts</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 根据自己的网络ip地址自行配置host解析</span></span><br><span class=\"line\">192.168.150.130 k8s-master01</span><br><span class=\"line\">192.168.150.131 k8s-node01</span><br><span class=\"line\">192.168.150.132 k8s-node02</span><br><span class=\"line\"><span class=\"comment\"># 将host配置拷贝到node节点</span></span><br><span class=\"line\">scp /etc/hosts root@k8s-node01:/etc/hosts</span><br><span class=\"line\">scp /etc/hosts root@k8s-node02:/etc/hosts</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget vim net-tools git</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置防火墙为-Iptables-并设置空规则\"><a href=\"#设置防火墙为-Iptables-并设置空规则\" class=\"headerlink\" title=\"设置防火墙为 Iptables 并设置空规则\"></a>设置防火墙为 Iptables 并设置空规则</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld &amp;&amp; systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"></span><br><span class=\"line\">yum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl <span class=\"built_in\">enable</span> iptables &amp;&amp; iptables -F &amp;&amp; service iptables save</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关闭-SELINUX\"><a href=\"#关闭-SELINUX\" class=\"headerlink\" title=\"关闭 SELINUX\"></a>关闭 SELINUX</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swapoff -a &amp;&amp; sed -i <span class=\"string\">&#x27;/ swap / s/^\\(.*\\)$/#\\1/g&#x27;</span> /etc/fstab</span><br><span class=\"line\"></span><br><span class=\"line\">setenforce 0 &amp;&amp; sed -i <span class=\"string\">&#x27;s/^SELINUX=.*/SELINUX=disabled/&#x27;</span> /etc/selinux/config</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调整内核参数，对于-K8S\"><a href=\"#调整内核参数，对于-K8S\" class=\"headerlink\" title=\"调整内核参数，对于 K8S\"></a>调整内核参数，对于 K8S</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &gt; kubernetes.conf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-iptables=1</span></span><br><span class=\"line\"><span class=\"string\">net.bridge.bridge-nf-call-ip6tables=1</span></span><br><span class=\"line\"><span class=\"string\">net.ipv4.ip_forward=1</span></span><br><span class=\"line\"><span class=\"string\">net.ipv4.tcp_tw_recycle=0</span></span><br><span class=\"line\"><span class=\"string\">vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它</span></span><br><span class=\"line\"><span class=\"string\">vm.overcommit_memory=1 # 不检查物理内存是否够用</span></span><br><span class=\"line\"><span class=\"string\">vm.panic_on_oom=0 # 开启 OOM</span></span><br><span class=\"line\"><span class=\"string\">fs.inotify.max_user_instances=8192</span></span><br><span class=\"line\"><span class=\"string\">fs.inotify.max_user_watches=1048576</span></span><br><span class=\"line\"><span class=\"string\">fs.file-max=52706963</span></span><br><span class=\"line\"><span class=\"string\">fs.nr_open=52706963</span></span><br><span class=\"line\"><span class=\"string\">net.ipv6.conf.all.disable_ipv6=1</span></span><br><span class=\"line\"><span class=\"string\">net.netfilter.nf_conntrack_max=2310720</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span> kubernetes.conf /etc/sysctl.d/kubernetes.conf</span><br><span class=\"line\"></span><br><span class=\"line\">sysctl -p /etc/sysctl.d/kubernetes.conf</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调整系统时区\"><a href=\"#调整系统时区\" class=\"headerlink\" title=\"调整系统时区\"></a>调整系统时区</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 设置系统时区为 中国/上海</span></span><br><span class=\"line\">timedatectl set-timezone Asia/Shanghai</span><br><span class=\"line\"><span class=\"comment\"># 将当前的 UTC 时间写入硬件时钟</span></span><br><span class=\"line\">timedatectl set-local-rtc 0</span><br><span class=\"line\"><span class=\"comment\"># 重启依赖于系统时间的服务</span></span><br><span class=\"line\">systemctl restart rsyslog</span><br><span class=\"line\">systemctl restart crond</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关闭系统不需要服务\"><a href=\"#关闭系统不需要服务\" class=\"headerlink\" title=\"关闭系统不需要服务\"></a>关闭系统不需要服务</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop postfix &amp;&amp; systemctl <span class=\"built_in\">disable</span> postfix</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置-rsyslogd-和-systemd-journald\"><a href=\"#设置-rsyslogd-和-systemd-journald\" class=\"headerlink\" title=\"设置 rsyslogd 和 systemd journald\"></a>设置 rsyslogd 和 systemd journald</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> /var/log/journal <span class=\"comment\"># 持久化保存日志的目录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /etc/systemd/journald.conf.d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/systemd/journald.conf.d/99-prophet.conf &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">[Journal]</span></span><br><span class=\"line\"><span class=\"string\"># 持久化保存到磁盘</span></span><br><span class=\"line\"><span class=\"string\">Storage=persistent</span></span><br><span class=\"line\"><span class=\"string\"># 压缩历史日志</span></span><br><span class=\"line\"><span class=\"string\">Compress=yes</span></span><br><span class=\"line\"><span class=\"string\">SyncIntervalSec=5m</span></span><br><span class=\"line\"><span class=\"string\">RateLimitInterval=30s</span></span><br><span class=\"line\"><span class=\"string\">RateLimitBurst=1000</span></span><br><span class=\"line\"><span class=\"string\"># 最大占用空间 10G</span></span><br><span class=\"line\"><span class=\"string\">SystemMaxUse=10G</span></span><br><span class=\"line\"><span class=\"string\"># 单日志文件最大 200M</span></span><br><span class=\"line\"><span class=\"string\">SystemMaxFileSize=200M</span></span><br><span class=\"line\"><span class=\"string\"># 日志保存时间 2 周</span></span><br><span class=\"line\"><span class=\"string\">MaxRetentionSec=2week</span></span><br><span class=\"line\"><span class=\"string\"># 不将日志转发到 syslog</span></span><br><span class=\"line\"><span class=\"string\">ForwardToSyslog=no</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">systemctl restart systemd-journald</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"升级系统内核为-4-44\"><a href=\"#升级系统内核为-4-44\" class=\"headerlink\" title=\"升级系统内核为 4.44\"></a>升级系统内核为 4.44</h4><p>CentOS 7.x 系统自带的 3.10.x 内核存在一些 Bugs，导致运行的 Docker、Kubernetes 不稳定，例如： rpm -Uvh <a href=\"http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm\">http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br><span class=\"line\"><span class=\"comment\"># 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次！</span></span><br><span class=\"line\">yum --enablerepo=elrepo-kernel install -y kernel-lt</span><br><span class=\"line\"><span class=\"comment\"># 设置开机从新内核启动</span></span><br><span class=\"line\">grub2-set-default <span class=\"string\">&#x27;CentOS Linux (4.4.189-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Kubeadm部署安装\"><a href=\"#Kubeadm部署安装\" class=\"headerlink\" title=\"Kubeadm部署安装\"></a>Kubeadm部署安装</h3><h4 id=\"kube-proxy开启ipvs的前置条件\"><a href=\"#kube-proxy开启ipvs的前置条件\" class=\"headerlink\" title=\"kube-proxy开启ipvs的前置条件\"></a>kube-proxy开启ipvs的前置条件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modprobe br_netfilter</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- ip_vs</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- ip_vs_rr</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- ip_vs_wrr</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- ip_vs_sh</span></span><br><span class=\"line\"><span class=\"string\">modprobe -- nf_conntrack</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装-Docker-软件\"><a href=\"#安装-Docker-软件\" class=\"headerlink\" title=\"安装 Docker 软件\"></a>安装 Docker 软件</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class=\"line\"></span><br><span class=\"line\">yum-config-manager \\</span><br><span class=\"line\">--add-repo \\</span><br><span class=\"line\">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class=\"line\"></span><br><span class=\"line\">yum update -y &amp;&amp; yum install -y docker-ce</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#安装完成后重启机器</span></span><br><span class=\"line\">reboot</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动docker并设置开机自启</span></span><br><span class=\"line\">systemctl start docker &amp;&amp; systemctl <span class=\"built_in\">enable</span> docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 创建 /etc/docker 目录</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> /etc/docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置 daemon.</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> &gt; /etc/docker/daemon.json &lt;&lt;<span class=\"string\">EOF</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class=\"line\"><span class=\"string\">&quot;log-driver&quot;: &quot;json-file&quot;,</span></span><br><span class=\"line\"><span class=\"string\">&quot;log-opts&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">&quot;max-size&quot;: &quot;100m&quot;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /etc/systemd/system/docker.service.d</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启docker服务</span></span><br><span class=\"line\">systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装-Kubeadm-（主从配置）\"><a href=\"#安装-Kubeadm-（主从配置）\" class=\"headerlink\" title=\"安装 Kubeadm （主从配置）\"></a>安装 Kubeadm （主从配置）</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> &lt;&lt;<span class=\"string\">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class=\"line\"><span class=\"string\">[kubernetes]</span></span><br><span class=\"line\"><span class=\"string\">name=Kubernetes</span></span><br><span class=\"line\"><span class=\"string\">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class=\"line\"><span class=\"string\">enabled=1</span></span><br><span class=\"line\"><span class=\"string\">gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">repo_gpgcheck=0</span></span><br><span class=\"line\"><span class=\"string\">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class=\"line\"><span class=\"string\">http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class=\"line\"><span class=\"string\">EOF</span></span><br><span class=\"line\"></span><br><span class=\"line\">yum -y install kubeadm-1.15.1 kubectl-1.15.1 kubelet-1.15.1</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> kubelet.service</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化主节点\"><a href=\"#初始化主节点\" class=\"headerlink\" title=\"初始化主节点\"></a>初始化主节点</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubeadm config <span class=\"built_in\">print</span> init-defaults &gt; kubeadm-config.yaml</span><br><span class=\"line\">localAPIEndpoint:</span><br><span class=\"line\">advertiseAddress: 192.168.66.10</span><br><span class=\"line\">kubernetesVersion: v1.15.1</span><br><span class=\"line\">networking:</span><br><span class=\"line\">podSubnet: <span class=\"string\">&quot;10.244.0.0/16&quot;</span></span><br><span class=\"line\">serviceSubnet: 10.96.0.0/12</span><br><span class=\"line\">---</span><br><span class=\"line\">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class=\"line\">kind: KubeProxyConfiguration</span><br><span class=\"line\">featureGates:</span><br><span class=\"line\">SupportIPVSProxyMode: <span class=\"literal\">true</span></span><br><span class=\"line\">mode: ipvs</span><br><span class=\"line\">kubeadm init --config=kubeadm-config.yaml --experimental-upload-certs | <span class=\"built_in\">tee</span> kubeadm-init.log</span><br></pre></td></tr></table></figure>"},{"title":"fork之后的仓库如何同步源仓库的最新代码","date":"2023-03-10T01:38:28.000Z","excerpt":"git fork仓库之后， 源仓库代码进行了更新 fork后的仓库如何同步源仓库代码呢？","_content":"fork之后的仓库如何同步源仓库的最新代码\n\n1. 首先进入项目根目录运行`git remote -v`查看本地仓库的远程路径。\n2. 添加源仓库（上游仓库）的远程路径,命令格式`git remote add upstream ADDR`\n```git \ngit remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git\n```\n3. 查看源仓库（上游仓库）是否关联成功`git remote -v`。\n![git remote -v](/images/git/fork-remote.png)\n4. `git status`查看本事是否有代码没有commit，若有改动及时commit或者回滚。\n5. 执行`git fetch upstream`抓取源仓库（上游仓库）的最新代码。\n6. 执行`git merge upstream/master`命令合并master分支的代码。\n","source":"_posts/git/fork.md","raw":"---\ntitle: fork之后的仓库如何同步源仓库的最新代码\ndate: 2023-03-10 09:38:28\ntags: [\"git\", \"fork\"]\nexcerpt: git fork仓库之后， 源仓库代码进行了更新 fork后的仓库如何同步源仓库代码呢？\n---\nfork之后的仓库如何同步源仓库的最新代码\n\n1. 首先进入项目根目录运行`git remote -v`查看本地仓库的远程路径。\n2. 添加源仓库（上游仓库）的远程路径,命令格式`git remote add upstream ADDR`\n```git \ngit remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git\n```\n3. 查看源仓库（上游仓库）是否关联成功`git remote -v`。\n![git remote -v](/images/git/fork-remote.png)\n4. `git status`查看本事是否有代码没有commit，若有改动及时commit或者回滚。\n5. 执行`git fetch upstream`抓取源仓库（上游仓库）的最新代码。\n6. 执行`git merge upstream/master`命令合并master分支的代码。\n","slug":"git/fork","published":1,"updated":"2023-05-27T08:10:05.834Z","_id":"clhu5qi4j00056oup2vnfbwb7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>fork之后的仓库如何同步源仓库的最新代码</p>\n<ol>\n<li>首先进入项目根目录运行<code>git remote -v</code>查看本地仓库的远程路径。</li>\n<li>添加源仓库（上游仓库）的远程路径,命令格式<code>git remote add upstream ADDR</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git</span><br></pre></td></tr></table></figure></li>\n<li>查看源仓库（上游仓库）是否关联成功<code>git remote -v</code>。<br><img src=\"/blog/images/git/fork-remote.png\" alt=\"git remote -v\"></li>\n<li><code>git status</code>查看本事是否有代码没有commit，若有改动及时commit或者回滚。</li>\n<li>执行<code>git fetch upstream</code>抓取源仓库（上游仓库）的最新代码。</li>\n<li>执行<code>git merge upstream/master</code>命令合并master分支的代码。</li>\n</ol>\n","site":{"data":{}},"more":"<p>fork之后的仓库如何同步源仓库的最新代码</p>\n<ol>\n<li>首先进入项目根目录运行<code>git remote -v</code>查看本地仓库的远程路径。</li>\n<li>添加源仓库（上游仓库）的远程路径,命令格式<code>git remote add upstream ADDR</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git</span><br></pre></td></tr></table></figure></li>\n<li>查看源仓库（上游仓库）是否关联成功<code>git remote -v</code>。<br><img src=\"/blog/images/git/fork-remote.png\" alt=\"git remote -v\"></li>\n<li><code>git status</code>查看本事是否有代码没有commit，若有改动及时commit或者回滚。</li>\n<li>执行<code>git fetch upstream</code>抓取源仓库（上游仓库）的最新代码。</li>\n<li>执行<code>git merge upstream/master</code>命令合并master分支的代码。</li>\n</ol>\n"},{"title":"go实现IoC容器","excerpt":"使用go写一个简单好用IoC容器的方法，主要演示的是思路及封装","date":"2023-05-19T06:00:18.000Z","_content":"\n## IoC\n控制反转（Inversion of Control，IoC）是一种软件设计原则，用于实现松耦合的组件之间的交互。它的核心思想是将控制权从调用者转移到外部容器或框架，由容器负责创建和管理对象的生命周期以及它们之间的依赖关系，而不是由调用者直接控制。\n所谓的容器在go里面就是map对象或者切片。\n\n## 设计\n设计Ioc初步雏形：基于类型的存储。使用map来充当容器key:reflect.Type value:reflect.value\n\n```golang\ntype BeanMapper map[reflect.Type]reflect.Value\n```\n1. 容器定义\n```golang\npackage injector\n\nimport \"reflect\"\n// 定义容器类型 key使用仿射类型 value使用反射值\ntype BeanMapper map[reflect.Type]reflect.Value\n\n// 往容器中添加元素\nfunc (this BeanMapper) add(bean interface{}) {\n\tt := reflect.TypeOf(bean)\n\tif t.Kind() != reflect.Ptr {\n\t\tpanic(\"require ptr object\")\n\t}\n\tthis[t] = reflect.ValueOf(bean)\n}\n\n// 获取容器中的bean\nfunc (this BeanMapper) get(bean interface{}) reflect.Value {\n\tvar t reflect.Type\n\tif bt, ok := bean.(reflect.Type); ok {\n\t\tt = bt\n\t} else {\n\t\tt = reflect.TypeOf(bean)\n\t}\n\tif value, ok := this[t]; ok {\n\t\treturn value\n\t}\n\t// 处理接口继承（接口方式注入） service主要实现了接口就返回\n\t// FIXME 容器中如果有多个元素实现了该接口，这里只会返回容器中匹配到的第一个元素\n\tfmt.Println(t.Kind())\n\tfmt.Println(t)\n\tfor k, v := range this {\n\t\tif t.Kind() == reflect.Interface && k.Implements(t) {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn reflect.Value{}\n}\n```\n\n2. 创建一个BeanFactory文件负责往容器中添加bean、获取bean以及依赖注入\n```golang\npackage injector\n\nimport (\n\t\"github.com/shenyisyn/goft-expr/src/expr\"\n\t\"log\"\n\t\"reflect\"\n)\n\nvar BeanFactory *BeanFactoryImpl\n\n// 引用文件的时候初始化BeanFactory\nfunc init() {\n\tBeanFactory = NewBeanFactory()\n}\n\ntype BeanFactoryImpl struct {\n\tbeanMapper BeanMapper\n\t// 字符串表达式解析\n\tExprMap map[string]interface{}\n}\n\n// NewBeanFactory 初始化容器BeanMapper对象 初始化字符串表达式映射\nfunc NewBeanFactory() *BeanFactoryImpl {\n\treturn &BeanFactoryImpl{beanMapper: make(BeanMapper), ExprMap: make(map[string]interface{})}\n}\n\nfunc (this *BeanFactoryImpl) Set(beans ...interface{}) {\n\tif beans == nil || len(beans) == 0 {\n\t\treturn\n\t}\n\tfor _, bean := range beans {\n\t\tthis.beanMapper.add(bean)\n\t}\n}\n\nfunc (this *BeanFactoryImpl) Get(val interface{}) interface{} {\n\tif val == nil {\n\t\treturn nil\n\t}\n\tgetVal := this.beanMapper.get(val)\n\tif getVal.IsValid() {\n\t\treturn getVal.Interface()\n\t}\n\treturn nil\n}\n```\n\n2. 处理依赖注入，动态注入bean（BeanFactory.go）\n![case](/images/go/ioc/case1.png)\n```golang\n// Apply 处理依赖注入 根据tag名inject以及元素类型进行注入\nfunc (this *BeanFactoryImpl) Apply(bean interface{}) {\n\tif bean == nil {\n\t\treturn\n\t}\n\tv := reflect.ValueOf(bean)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.Kind() != reflect.Struct {\n\t\treturn\n\t}\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tfield := v.Type().Field(i)\n\t\t// 判断bean首字母是否为大写，并且拥有inject标签且不能为空字符\n\t\tif v.Field(i).CanSet() && field.Tag.Get(\"inject\") != \"\" {\n\t\t\tif field.Tag.Get(\"inject\") != \"-\" {\n\t\t\t\t// 多例模式\n\t\t\t\t// 表达式方式注入\n\t\t\t\t// 字符串表达式解析执行\n\t\t\t\tlog.Println(\"使用了表达式的方式\")\n\t\t\t\t// expr用来解析执行字符串\n\t\t\t\tret := expr.BeanExpr(field.Tag.Get(\"inject\"), this.ExprMap)\n\t\t\t\tif ret != nil && !ret.IsEmpty() {\n\t\t\t\t\tretValue := ret[0]\n\t\t\t\t\tif retValue != nil {\n\t\t\t\t\t\t//this.Set(retValue)\n\t\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(retValue))\n\t\t\t\t\t\t// 递归执行依赖注入\n\t\t\t\t\t\tthis.Apply(retValue)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 单例模式\n\t\t\t\t// 兼容直接Set单个实例对象方式注入，比如Set(NewOrderService())\n\t\t\t\tif val := this.Get(field.Type); val != nil {\n\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(val))\n\t\t\t\t\t// 递归执行依赖注入\n\t\t\t\t\tthis.Apply(val)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n3. 容器初始化\n如果容器初始化bean很多，使用set方法创建bean，手动写很麻烦，如何优雅进行容器bean的加载？使用一个ConfigService.go文件用来配置所有的bean，再解析这个文件的方法，具体看如下的代码\n![case](/images/go/ioc/case2.png)\n```golang\npackage config\n\nimport \"go-ioc/src/services\"\n\ntype ServiceConfig struct {\n}\n\nfunc NewServiceConfig() *ServiceConfig {\n\treturn &ServiceConfig{}\n}\n\nfunc (this *ServiceConfig) OrderService() *services.OrderService {\n\treturn services.NewOrderService()\n}\nfunc (this *ServiceConfig) DBService() *services.DBService {\n\treturn services.NewDBService()\n}\n```\n\n加载ConfigService.go文件，容器加载所有config文件中配置的bean\n\n```golang\nfunc (this *BeanFactoryImpl) Config(cfgs ...interface{}) {\n\tfor _, cfg := range cfgs {\n\t\tt := reflect.TypeOf(cfg)\n\t\tif t.Kind() != reflect.Ptr {\n\t\t\tpanic(\"require ptr object\")\n\t\t}\n\t\tthis.Set(cfg)                       // config本身加入容器\n\t\tthis.ExprMap[t.Elem().Name()] = cfg // 自动构建ExprMap\n\n\t\tv := reflect.ValueOf(cfg)\n\t\tfor i := 0; i < v.NumMethod(); i++ {\n\t\t\tmethod := v.Method(i)\n\t\t\tcallRet := method.Call(nil)\n\t\t\tif callRet != nil && len(callRet) == 1 {\n\t\t\t\tthis.Set(callRet[0].Interface())\n\t\t\t}\n\t\t}\n\t}\n}\n```","source":"_posts/go/ioc.md","raw":"---\ntitle: go实现IoC容器\ntags:\n  - go\n  - ioc\n  - 控制反转\n  - 依赖注入\n  - reflect\nexcerpt: 使用go写一个简单好用IoC容器的方法，主要演示的是思路及封装\ndate: 2023-05-19 14:00:18\n---\n\n## IoC\n控制反转（Inversion of Control，IoC）是一种软件设计原则，用于实现松耦合的组件之间的交互。它的核心思想是将控制权从调用者转移到外部容器或框架，由容器负责创建和管理对象的生命周期以及它们之间的依赖关系，而不是由调用者直接控制。\n所谓的容器在go里面就是map对象或者切片。\n\n## 设计\n设计Ioc初步雏形：基于类型的存储。使用map来充当容器key:reflect.Type value:reflect.value\n\n```golang\ntype BeanMapper map[reflect.Type]reflect.Value\n```\n1. 容器定义\n```golang\npackage injector\n\nimport \"reflect\"\n// 定义容器类型 key使用仿射类型 value使用反射值\ntype BeanMapper map[reflect.Type]reflect.Value\n\n// 往容器中添加元素\nfunc (this BeanMapper) add(bean interface{}) {\n\tt := reflect.TypeOf(bean)\n\tif t.Kind() != reflect.Ptr {\n\t\tpanic(\"require ptr object\")\n\t}\n\tthis[t] = reflect.ValueOf(bean)\n}\n\n// 获取容器中的bean\nfunc (this BeanMapper) get(bean interface{}) reflect.Value {\n\tvar t reflect.Type\n\tif bt, ok := bean.(reflect.Type); ok {\n\t\tt = bt\n\t} else {\n\t\tt = reflect.TypeOf(bean)\n\t}\n\tif value, ok := this[t]; ok {\n\t\treturn value\n\t}\n\t// 处理接口继承（接口方式注入） service主要实现了接口就返回\n\t// FIXME 容器中如果有多个元素实现了该接口，这里只会返回容器中匹配到的第一个元素\n\tfmt.Println(t.Kind())\n\tfmt.Println(t)\n\tfor k, v := range this {\n\t\tif t.Kind() == reflect.Interface && k.Implements(t) {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn reflect.Value{}\n}\n```\n\n2. 创建一个BeanFactory文件负责往容器中添加bean、获取bean以及依赖注入\n```golang\npackage injector\n\nimport (\n\t\"github.com/shenyisyn/goft-expr/src/expr\"\n\t\"log\"\n\t\"reflect\"\n)\n\nvar BeanFactory *BeanFactoryImpl\n\n// 引用文件的时候初始化BeanFactory\nfunc init() {\n\tBeanFactory = NewBeanFactory()\n}\n\ntype BeanFactoryImpl struct {\n\tbeanMapper BeanMapper\n\t// 字符串表达式解析\n\tExprMap map[string]interface{}\n}\n\n// NewBeanFactory 初始化容器BeanMapper对象 初始化字符串表达式映射\nfunc NewBeanFactory() *BeanFactoryImpl {\n\treturn &BeanFactoryImpl{beanMapper: make(BeanMapper), ExprMap: make(map[string]interface{})}\n}\n\nfunc (this *BeanFactoryImpl) Set(beans ...interface{}) {\n\tif beans == nil || len(beans) == 0 {\n\t\treturn\n\t}\n\tfor _, bean := range beans {\n\t\tthis.beanMapper.add(bean)\n\t}\n}\n\nfunc (this *BeanFactoryImpl) Get(val interface{}) interface{} {\n\tif val == nil {\n\t\treturn nil\n\t}\n\tgetVal := this.beanMapper.get(val)\n\tif getVal.IsValid() {\n\t\treturn getVal.Interface()\n\t}\n\treturn nil\n}\n```\n\n2. 处理依赖注入，动态注入bean（BeanFactory.go）\n![case](/images/go/ioc/case1.png)\n```golang\n// Apply 处理依赖注入 根据tag名inject以及元素类型进行注入\nfunc (this *BeanFactoryImpl) Apply(bean interface{}) {\n\tif bean == nil {\n\t\treturn\n\t}\n\tv := reflect.ValueOf(bean)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.Kind() != reflect.Struct {\n\t\treturn\n\t}\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tfield := v.Type().Field(i)\n\t\t// 判断bean首字母是否为大写，并且拥有inject标签且不能为空字符\n\t\tif v.Field(i).CanSet() && field.Tag.Get(\"inject\") != \"\" {\n\t\t\tif field.Tag.Get(\"inject\") != \"-\" {\n\t\t\t\t// 多例模式\n\t\t\t\t// 表达式方式注入\n\t\t\t\t// 字符串表达式解析执行\n\t\t\t\tlog.Println(\"使用了表达式的方式\")\n\t\t\t\t// expr用来解析执行字符串\n\t\t\t\tret := expr.BeanExpr(field.Tag.Get(\"inject\"), this.ExprMap)\n\t\t\t\tif ret != nil && !ret.IsEmpty() {\n\t\t\t\t\tretValue := ret[0]\n\t\t\t\t\tif retValue != nil {\n\t\t\t\t\t\t//this.Set(retValue)\n\t\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(retValue))\n\t\t\t\t\t\t// 递归执行依赖注入\n\t\t\t\t\t\tthis.Apply(retValue)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 单例模式\n\t\t\t\t// 兼容直接Set单个实例对象方式注入，比如Set(NewOrderService())\n\t\t\t\tif val := this.Get(field.Type); val != nil {\n\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(val))\n\t\t\t\t\t// 递归执行依赖注入\n\t\t\t\t\tthis.Apply(val)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n3. 容器初始化\n如果容器初始化bean很多，使用set方法创建bean，手动写很麻烦，如何优雅进行容器bean的加载？使用一个ConfigService.go文件用来配置所有的bean，再解析这个文件的方法，具体看如下的代码\n![case](/images/go/ioc/case2.png)\n```golang\npackage config\n\nimport \"go-ioc/src/services\"\n\ntype ServiceConfig struct {\n}\n\nfunc NewServiceConfig() *ServiceConfig {\n\treturn &ServiceConfig{}\n}\n\nfunc (this *ServiceConfig) OrderService() *services.OrderService {\n\treturn services.NewOrderService()\n}\nfunc (this *ServiceConfig) DBService() *services.DBService {\n\treturn services.NewDBService()\n}\n```\n\n加载ConfigService.go文件，容器加载所有config文件中配置的bean\n\n```golang\nfunc (this *BeanFactoryImpl) Config(cfgs ...interface{}) {\n\tfor _, cfg := range cfgs {\n\t\tt := reflect.TypeOf(cfg)\n\t\tif t.Kind() != reflect.Ptr {\n\t\t\tpanic(\"require ptr object\")\n\t\t}\n\t\tthis.Set(cfg)                       // config本身加入容器\n\t\tthis.ExprMap[t.Elem().Name()] = cfg // 自动构建ExprMap\n\n\t\tv := reflect.ValueOf(cfg)\n\t\tfor i := 0; i < v.NumMethod(); i++ {\n\t\t\tmethod := v.Method(i)\n\t\t\tcallRet := method.Call(nil)\n\t\t\tif callRet != nil && len(callRet) == 1 {\n\t\t\t\tthis.Set(callRet[0].Interface())\n\t\t\t}\n\t\t}\n\t}\n}\n```","slug":"go/ioc","published":1,"updated":"2023-05-27T08:37:53.260Z","_id":"clhu5qi4k00066oup9rkrfugu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h2><p>控制反转（Inversion of Control，IoC）是一种软件设计原则，用于实现松耦合的组件之间的交互。它的核心思想是将控制权从调用者转移到外部容器或框架，由容器负责创建和管理对象的生命周期以及它们之间的依赖关系，而不是由调用者直接控制。<br>所谓的容器在go里面就是map对象或者切片。</p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p>设计Ioc初步雏形：基于类型的存储。使用map来充当容器key:reflect.Type value:reflect.value</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BeanMapper <span class=\"keyword\">map</span>[reflect.Type]reflect.Value</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>容器定义</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> injector</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 定义容器类型 key使用仿射类型 value使用反射值</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> BeanMapper <span class=\"keyword\">map</span>[reflect.Type]reflect.Value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 往容器中添加元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this BeanMapper)</span></span> add(bean <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\tt := reflect.TypeOf(bean)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;require ptr object&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis[t] = reflect.ValueOf(bean)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取容器中的bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this BeanMapper)</span></span> get(bean <span class=\"keyword\">interface</span>&#123;&#125;) reflect.Value &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t reflect.Type</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bt, ok := bean.(reflect.Type); ok &#123;</span><br><span class=\"line\">\t\tt = bt</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tt = reflect.TypeOf(bean)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> value, ok := this[t]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> value</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理接口继承（接口方式注入） service主要实现了接口就返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// FIXME 容器中如果有多个元素实现了该接口，这里只会返回容器中匹配到的第一个元素</span></span><br><span class=\"line\">\tfmt.Println(t.Kind())</span><br><span class=\"line\">\tfmt.Println(t)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> this &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Kind() == reflect.Interface &amp;&amp; k.Implements(t) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> reflect.Value&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个BeanFactory文件负责往容器中添加bean、获取bean以及依赖注入</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> injector</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/shenyisyn/goft-expr/src/expr&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> BeanFactory *BeanFactoryImpl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用文件的时候初始化BeanFactory</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tBeanFactory = NewBeanFactory()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> BeanFactoryImpl <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbeanMapper BeanMapper</span><br><span class=\"line\">\t<span class=\"comment\">// 字符串表达式解析</span></span><br><span class=\"line\">\tExprMap <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewBeanFactory 初始化容器BeanMapper对象 初始化字符串表达式映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBeanFactory</span><span class=\"params\">()</span></span> *BeanFactoryImpl &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;BeanFactoryImpl&#123;beanMapper: <span class=\"built_in\">make</span>(BeanMapper), ExprMap: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Set(beans ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> beans == <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(beans) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, bean := <span class=\"keyword\">range</span> beans &#123;</span><br><span class=\"line\">\t\tthis.beanMapper.add(bean)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Get(val <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> val == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetVal := this.beanMapper.get(val)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> getVal.IsValid() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> getVal.Interface()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理依赖注入，动态注入bean（BeanFactory.go）<br><img src=\"/blog/images/go/ioc/case1.png\" alt=\"case\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Apply 处理依赖注入 根据tag名inject以及元素类型进行注入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Apply(bean <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bean == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tv := reflect.ValueOf(bean)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">\t\tv = v.Elem()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v.Kind() != reflect.Struct &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class=\"line\">\t\tfield := v.Type().Field(i)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断bean首字母是否为大写，并且拥有inject标签且不能为空字符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v.Field(i).CanSet() &amp;&amp; field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>) != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>) != <span class=\"string\">&quot;-&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 多例模式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 表达式方式注入</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 字符串表达式解析执行</span></span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;使用了表达式的方式&quot;</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// expr用来解析执行字符串</span></span><br><span class=\"line\">\t\t\t\tret := expr.BeanExpr(field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>), this.ExprMap)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ret != <span class=\"literal\">nil</span> &amp;&amp; !ret.IsEmpty() &#123;</span><br><span class=\"line\">\t\t\t\t\tretValue := ret[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> retValue != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//this.Set(retValue)</span></span><br><span class=\"line\">\t\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(retValue))</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 递归执行依赖注入</span></span><br><span class=\"line\">\t\t\t\t\t\tthis.Apply(retValue)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 单例模式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 兼容直接Set单个实例对象方式注入，比如Set(NewOrderService())</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> val := this.Get(field.Type); val != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(val))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 递归执行依赖注入</span></span><br><span class=\"line\">\t\t\t\t\tthis.Apply(val)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>容器初始化<br>如果容器初始化bean很多，使用set方法创建bean，手动写很麻烦，如何优雅进行容器bean的加载？使用一个ConfigService.go文件用来配置所有的bean，再解析这个文件的方法，具体看如下的代码<br><img src=\"/blog/images/go/ioc/case2.png\" alt=\"case\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;go-ioc/src/services&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ServiceConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServiceConfig</span><span class=\"params\">()</span></span> *ServiceConfig &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ServiceConfig&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ServiceConfig)</span></span> OrderService() *services.OrderService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> services.NewOrderService()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ServiceConfig)</span></span> DBService() *services.DBService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> services.NewDBService()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>加载ConfigService.go文件，容器加载所有config文件中配置的bean</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Config(cfgs ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cfg := <span class=\"keyword\">range</span> cfgs &#123;</span><br><span class=\"line\">\t\tt := reflect.TypeOf(cfg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;require ptr object&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthis.Set(cfg)                       <span class=\"comment\">// config本身加入容器</span></span><br><span class=\"line\">\t\tthis.ExprMap[t.Elem().Name()] = cfg <span class=\"comment\">// 自动构建ExprMap</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tv := reflect.ValueOf(cfg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class=\"line\">\t\t\tmethod := v.Method(i)</span><br><span class=\"line\">\t\t\tcallRet := method.Call(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> callRet != <span class=\"literal\">nil</span> &amp;&amp; <span class=\"built_in\">len</span>(callRet) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\tthis.Set(callRet[<span class=\"number\">0</span>].Interface())</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"more":"<h2 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h2><p>控制反转（Inversion of Control，IoC）是一种软件设计原则，用于实现松耦合的组件之间的交互。它的核心思想是将控制权从调用者转移到外部容器或框架，由容器负责创建和管理对象的生命周期以及它们之间的依赖关系，而不是由调用者直接控制。<br>所谓的容器在go里面就是map对象或者切片。</p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p>设计Ioc初步雏形：基于类型的存储。使用map来充当容器key:reflect.Type value:reflect.value</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BeanMapper <span class=\"keyword\">map</span>[reflect.Type]reflect.Value</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>容器定义</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> injector</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 定义容器类型 key使用仿射类型 value使用反射值</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> BeanMapper <span class=\"keyword\">map</span>[reflect.Type]reflect.Value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 往容器中添加元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this BeanMapper)</span></span> add(bean <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\tt := reflect.TypeOf(bean)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;require ptr object&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis[t] = reflect.ValueOf(bean)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取容器中的bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this BeanMapper)</span></span> get(bean <span class=\"keyword\">interface</span>&#123;&#125;) reflect.Value &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t reflect.Type</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bt, ok := bean.(reflect.Type); ok &#123;</span><br><span class=\"line\">\t\tt = bt</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tt = reflect.TypeOf(bean)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> value, ok := this[t]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> value</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理接口继承（接口方式注入） service主要实现了接口就返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// FIXME 容器中如果有多个元素实现了该接口，这里只会返回容器中匹配到的第一个元素</span></span><br><span class=\"line\">\tfmt.Println(t.Kind())</span><br><span class=\"line\">\tfmt.Println(t)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> this &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Kind() == reflect.Interface &amp;&amp; k.Implements(t) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> reflect.Value&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个BeanFactory文件负责往容器中添加bean、获取bean以及依赖注入</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> injector</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/shenyisyn/goft-expr/src/expr&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> BeanFactory *BeanFactoryImpl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用文件的时候初始化BeanFactory</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tBeanFactory = NewBeanFactory()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> BeanFactoryImpl <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbeanMapper BeanMapper</span><br><span class=\"line\">\t<span class=\"comment\">// 字符串表达式解析</span></span><br><span class=\"line\">\tExprMap <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewBeanFactory 初始化容器BeanMapper对象 初始化字符串表达式映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBeanFactory</span><span class=\"params\">()</span></span> *BeanFactoryImpl &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;BeanFactoryImpl&#123;beanMapper: <span class=\"built_in\">make</span>(BeanMapper), ExprMap: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Set(beans ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> beans == <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(beans) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, bean := <span class=\"keyword\">range</span> beans &#123;</span><br><span class=\"line\">\t\tthis.beanMapper.add(bean)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Get(val <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> val == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetVal := this.beanMapper.get(val)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> getVal.IsValid() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> getVal.Interface()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理依赖注入，动态注入bean（BeanFactory.go）<br><img src=\"/blog/images/go/ioc/case1.png\" alt=\"case\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Apply 处理依赖注入 根据tag名inject以及元素类型进行注入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Apply(bean <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bean == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tv := reflect.ValueOf(bean)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">\t\tv = v.Elem()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v.Kind() != reflect.Struct &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class=\"line\">\t\tfield := v.Type().Field(i)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断bean首字母是否为大写，并且拥有inject标签且不能为空字符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v.Field(i).CanSet() &amp;&amp; field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>) != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>) != <span class=\"string\">&quot;-&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 多例模式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 表达式方式注入</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 字符串表达式解析执行</span></span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;使用了表达式的方式&quot;</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// expr用来解析执行字符串</span></span><br><span class=\"line\">\t\t\t\tret := expr.BeanExpr(field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>), this.ExprMap)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ret != <span class=\"literal\">nil</span> &amp;&amp; !ret.IsEmpty() &#123;</span><br><span class=\"line\">\t\t\t\t\tretValue := ret[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> retValue != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//this.Set(retValue)</span></span><br><span class=\"line\">\t\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(retValue))</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 递归执行依赖注入</span></span><br><span class=\"line\">\t\t\t\t\t\tthis.Apply(retValue)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 单例模式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 兼容直接Set单个实例对象方式注入，比如Set(NewOrderService())</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> val := this.Get(field.Type); val != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(val))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 递归执行依赖注入</span></span><br><span class=\"line\">\t\t\t\t\tthis.Apply(val)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>容器初始化<br>如果容器初始化bean很多，使用set方法创建bean，手动写很麻烦，如何优雅进行容器bean的加载？使用一个ConfigService.go文件用来配置所有的bean，再解析这个文件的方法，具体看如下的代码<br><img src=\"/blog/images/go/ioc/case2.png\" alt=\"case\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;go-ioc/src/services&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ServiceConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServiceConfig</span><span class=\"params\">()</span></span> *ServiceConfig &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ServiceConfig&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ServiceConfig)</span></span> OrderService() *services.OrderService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> services.NewOrderService()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ServiceConfig)</span></span> DBService() *services.DBService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> services.NewDBService()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>加载ConfigService.go文件，容器加载所有config文件中配置的bean</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Config(cfgs ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cfg := <span class=\"keyword\">range</span> cfgs &#123;</span><br><span class=\"line\">\t\tt := reflect.TypeOf(cfg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;require ptr object&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthis.Set(cfg)                       <span class=\"comment\">// config本身加入容器</span></span><br><span class=\"line\">\t\tthis.ExprMap[t.Elem().Name()] = cfg <span class=\"comment\">// 自动构建ExprMap</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tv := reflect.ValueOf(cfg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class=\"line\">\t\t\tmethod := v.Method(i)</span><br><span class=\"line\">\t\t\tcallRet := method.Call(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> callRet != <span class=\"literal\">nil</span> &amp;&amp; <span class=\"built_in\">len</span>(callRet) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\tthis.Set(callRet[<span class=\"number\">0</span>].Interface())</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"go 日志记录最佳实践","date":"2023-03-10T02:44:27.000Z","excerpt":"golang项目中使用gorus + rotatelogs + ifshook实现日志记录","_content":"- [logrus](https://github.com/sirupsen/logrus)是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。\n- [file-rotatelogs](https://github.com/lestrrat-go/file-rotatelogs)实现了 io.Writer 接口，并且提供了文件的切割功能。\n- [lfshook](https://github.com/rifflock/lfshook)决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT / JSON）。\n\n- 完整示例代码\n```golang\npackage pkg\n\nimport (\n\trotatelogs \"github.com/lestrrat-go/file-rotatelogs\"\n\t\"github.com/rifflock/lfshook\"\n\t\"github.com/sirupsen/logrus\"\n\t\"go-package/config\"\n\t\"os\"\n\t\"path\"\n\t\"time\"\n)\n\nvar (\n\tLogger      *logrus.Logger\n\tlogFileName string = \"server_log\"\n\tLocation, _        = time.LoadLocation(\"Asia/Shanghai\")\n)\n\nfunc InitLogger() {\n\t// 实例化logrus\n\tLogger = logrus.New()\n\t// 设置日志级别\n\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)\n\tif err != nil {\n\t\tlevel = logrus.InfoLevel\n\t}\n\tLogger.SetLevel(level)\n\n\tlogFileStat()\n\n\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)\n\t// 使用rotatelogs进行日志切割\n\tlogWriter, err := rotatelogs.New(\n\t\tfileName+\".%Y%m%d%H%M.log\",\n\t\t// 生成软链，指向最新日志文件\n\t\trotatelogs.WithLinkName(fileName),\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\tdebugWriter, err := rotatelogs.New(\n\t\tfileName+\"_debug\"+\".%Y%m%d%H%M.log\",\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\n\t// 使用lfshook设置不同类型日志进行不同的切割方式\n\twriteMap := lfshook.WriterMap{\n\t\tlogrus.InfoLevel:  logWriter,\n\t\tlogrus.FatalLevel: logWriter,\n\t\tlogrus.DebugLevel: debugWriter,\n\t\tlogrus.WarnLevel:  logWriter,\n\t\tlogrus.ErrorLevel: logWriter,\n\t\tlogrus.PanicLevel: logWriter,\n\t}\n\tLogger.AddHook(lfshook.NewHook(writeMap, &logrus.JSONFormatter{\n\t\tTimestampFormat: \"2006-01-02 15:04:05\",\n\t}))\n}\n\n/**\n * 检测日志文件是否存在\n */\nfunc logFileStat() {\n\tlogPath := path.Join(config.Cfg.Server.LogPath)\n\tif _, err := os.Stat(logPath); os.IsNotExist(err) {\n\t\tos.Mkdir(logPath, os.ModePerm)\n\t\tos.Chmod(logPath, 0755)\n\t}\n}\n```","source":"_posts/go/log.md","raw":"---\ntitle: go 日志记录最佳实践\ndate: 2023-03-10 10:44:27\ntags: [\"go\", \"gorus\", \"rotatelogs\", \"ifshook\"]\nexcerpt: golang项目中使用gorus + rotatelogs + ifshook实现日志记录\n---\n- [logrus](https://github.com/sirupsen/logrus)是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。\n- [file-rotatelogs](https://github.com/lestrrat-go/file-rotatelogs)实现了 io.Writer 接口，并且提供了文件的切割功能。\n- [lfshook](https://github.com/rifflock/lfshook)决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT / JSON）。\n\n- 完整示例代码\n```golang\npackage pkg\n\nimport (\n\trotatelogs \"github.com/lestrrat-go/file-rotatelogs\"\n\t\"github.com/rifflock/lfshook\"\n\t\"github.com/sirupsen/logrus\"\n\t\"go-package/config\"\n\t\"os\"\n\t\"path\"\n\t\"time\"\n)\n\nvar (\n\tLogger      *logrus.Logger\n\tlogFileName string = \"server_log\"\n\tLocation, _        = time.LoadLocation(\"Asia/Shanghai\")\n)\n\nfunc InitLogger() {\n\t// 实例化logrus\n\tLogger = logrus.New()\n\t// 设置日志级别\n\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)\n\tif err != nil {\n\t\tlevel = logrus.InfoLevel\n\t}\n\tLogger.SetLevel(level)\n\n\tlogFileStat()\n\n\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)\n\t// 使用rotatelogs进行日志切割\n\tlogWriter, err := rotatelogs.New(\n\t\tfileName+\".%Y%m%d%H%M.log\",\n\t\t// 生成软链，指向最新日志文件\n\t\trotatelogs.WithLinkName(fileName),\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\tdebugWriter, err := rotatelogs.New(\n\t\tfileName+\"_debug\"+\".%Y%m%d%H%M.log\",\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\n\t// 使用lfshook设置不同类型日志进行不同的切割方式\n\twriteMap := lfshook.WriterMap{\n\t\tlogrus.InfoLevel:  logWriter,\n\t\tlogrus.FatalLevel: logWriter,\n\t\tlogrus.DebugLevel: debugWriter,\n\t\tlogrus.WarnLevel:  logWriter,\n\t\tlogrus.ErrorLevel: logWriter,\n\t\tlogrus.PanicLevel: logWriter,\n\t}\n\tLogger.AddHook(lfshook.NewHook(writeMap, &logrus.JSONFormatter{\n\t\tTimestampFormat: \"2006-01-02 15:04:05\",\n\t}))\n}\n\n/**\n * 检测日志文件是否存在\n */\nfunc logFileStat() {\n\tlogPath := path.Join(config.Cfg.Server.LogPath)\n\tif _, err := os.Stat(logPath); os.IsNotExist(err) {\n\t\tos.Mkdir(logPath, os.ModePerm)\n\t\tos.Chmod(logPath, 0755)\n\t}\n}\n```","slug":"go/log","published":1,"updated":"2023-05-27T08:10:05.834Z","_id":"clhu5qi4l00086oup4lzp3qn0","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li><p><a href=\"https://github.com/sirupsen/logrus\">logrus</a>是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。</p>\n</li>\n<li><p><a href=\"https://github.com/lestrrat-go/file-rotatelogs\">file-rotatelogs</a>实现了 io.Writer 接口，并且提供了文件的切割功能。</p>\n</li>\n<li><p><a href=\"https://github.com/rifflock/lfshook\">lfshook</a>决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT &#x2F; JSON）。</p>\n</li>\n<li><p>完整示例代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\trotatelogs <span class=\"string\">&quot;github.com/lestrrat-go/file-rotatelogs&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/rifflock/lfshook&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;go-package/config&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tLogger      *logrus.Logger</span><br><span class=\"line\">\tlogFileName <span class=\"type\">string</span> = <span class=\"string\">&quot;server_log&quot;</span></span><br><span class=\"line\">\tLocation, _        = time.LoadLocation(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitLogger</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例化logrus</span></span><br><span class=\"line\">\tLogger = logrus.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 设置日志级别</span></span><br><span class=\"line\">\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlevel = logrus.InfoLevel</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.SetLevel(level)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlogFileStat()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)</span><br><span class=\"line\">\t<span class=\"comment\">// 使用rotatelogs进行日志切割</span></span><br><span class=\"line\">\tlogWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 生成软链，指向最新日志文件</span></span><br><span class=\"line\">\t\trotatelogs.WithLinkName(fileName),</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdebugWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;_debug&quot;</span>+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用lfshook设置不同类型日志进行不同的切割方式</span></span><br><span class=\"line\">\twriteMap := lfshook.WriterMap&#123;</span><br><span class=\"line\">\t\tlogrus.InfoLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.FatalLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.DebugLevel: debugWriter,</span><br><span class=\"line\">\t\tlogrus.WarnLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.ErrorLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.PanicLevel: logWriter,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.AddHook(lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123;</span><br><span class=\"line\">\t\tTimestampFormat: <span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span>,</span><br><span class=\"line\">\t&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检测日志文件是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logFileStat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlogPath := path.Join(config.Cfg.Server.LogPath)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(logPath); os.IsNotExist(err) &#123;</span><br><span class=\"line\">\t\tos.Mkdir(logPath, os.ModePerm)</span><br><span class=\"line\">\t\tos.Chmod(logPath, <span class=\"number\">0755</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"more":"<ul>\n<li><p><a href=\"https://github.com/sirupsen/logrus\">logrus</a>是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。</p>\n</li>\n<li><p><a href=\"https://github.com/lestrrat-go/file-rotatelogs\">file-rotatelogs</a>实现了 io.Writer 接口，并且提供了文件的切割功能。</p>\n</li>\n<li><p><a href=\"https://github.com/rifflock/lfshook\">lfshook</a>决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT &#x2F; JSON）。</p>\n</li>\n<li><p>完整示例代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\trotatelogs <span class=\"string\">&quot;github.com/lestrrat-go/file-rotatelogs&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/rifflock/lfshook&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;go-package/config&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tLogger      *logrus.Logger</span><br><span class=\"line\">\tlogFileName <span class=\"type\">string</span> = <span class=\"string\">&quot;server_log&quot;</span></span><br><span class=\"line\">\tLocation, _        = time.LoadLocation(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitLogger</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例化logrus</span></span><br><span class=\"line\">\tLogger = logrus.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 设置日志级别</span></span><br><span class=\"line\">\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlevel = logrus.InfoLevel</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.SetLevel(level)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlogFileStat()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)</span><br><span class=\"line\">\t<span class=\"comment\">// 使用rotatelogs进行日志切割</span></span><br><span class=\"line\">\tlogWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 生成软链，指向最新日志文件</span></span><br><span class=\"line\">\t\trotatelogs.WithLinkName(fileName),</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdebugWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;_debug&quot;</span>+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用lfshook设置不同类型日志进行不同的切割方式</span></span><br><span class=\"line\">\twriteMap := lfshook.WriterMap&#123;</span><br><span class=\"line\">\t\tlogrus.InfoLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.FatalLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.DebugLevel: debugWriter,</span><br><span class=\"line\">\t\tlogrus.WarnLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.ErrorLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.PanicLevel: logWriter,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.AddHook(lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123;</span><br><span class=\"line\">\t\tTimestampFormat: <span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span>,</span><br><span class=\"line\">\t&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检测日志文件是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logFileStat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlogPath := path.Join(config.Cfg.Server.LogPath)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(logPath); os.IsNotExist(err) &#123;</span><br><span class=\"line\">\t\tos.Mkdir(logPath, os.ModePerm)</span><br><span class=\"line\">\t\tos.Chmod(logPath, <span class=\"number\">0755</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"go高并发模式之管道模式","date":"2023-03-29T23:48:00.000Z","excerpt":"go语言精髓之一就是高度支持并发性，以下就是结合设计模式的管道模式演绎下golang的高并发场景处理。","_content":"\n### 什么是管道模式？\n白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。\n```bash\n#Linux命令举例\ncat log.txt | grep \"hello\" | head xx\n```\n\n### go当中的管道模式形式\n举例：\n\n从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：\n\n![流程图](/images/go/pipe/pipe1.png)\n\n使用go编写类似于管道的形式的代码大概如下所示：\n```golang\nimport \"fmt\"\n\n// Events 找出偶数\nfunc Events(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        if input[i]%2 == 0 {\n        out = append(out, input[i])\n    }\n    return out\n}\n\n// M2 数字乘2\nfunc M2(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*2)\n    }\n    return out\n}\n\n// M5 数字乘5\nfunc M5(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*5)\n    }\n    return out\n}\n\n// Cmd 定义管道函数的参数类型\ntype Cmd func(list []int) (ret []int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 Cmd, f3 Cmd) []int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    res := Pipe(nums, Events, M2, M5)\n    for _, val := range res {\n        fmt.Printf(\"%d \", val)\n    }\n}\n```\n上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；\n\n### 使用channel优化\n加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：\n\n![加入chan的流程图](/images/go/pipe/pipe2.png)\n\n约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。\n```golang\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < len(input); i++ {\n            if input[i]%2 == 0 {\n                ch <- input[i]\n            }\n        }\n    }()\n    return ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 2\n        }\n    }()\n    return ch\n}\n// M5 将偶数乘以5\nfunc M5(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 5\n        }\n    }()\n    return ch\n}\n\ntype Cmd func([]int) chan int\n// PipeCmd 定义管道函数的参数类型\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 PipeCmd, f3 PipeCmd) chan int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    wg := sync.WaitGroup{}\n    res := Pipe(nums, Events, M2, M5)\n    for v := range res {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            fmt.Printf(\"%d \", v)\n        }()\n    }\n    wg.Wait()\n}\n\n```\n\n### 管道模式之多路复用\n白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：\n\n![多路复用流程图](/images/go/pipe/pipe3.png)\n\n```golang\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := 0; i < len(input); i++ {\n\t\t\tif input[i]%2 == 0 {\n\t\t\t\tch <- input[i]\n\t\t\t}\n\t\t}\n\t}()\n\treturn ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := range input {\n\t\t\ttime.Sleep(time.Second * 2)\n\t\t\tch <- i * 2\n\t\t}\n\t}()\n\treturn ch\n}\n\ntype Cmd func([]int) chan int\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, ps ...PipeCmd) chan int {\n\twg := sync.WaitGroup{}\n\tevench := f1(nums) // 找偶数\n\tout := make(chan int)\n\tfor _, p := range ps {\n\t\tgetChan := p(evench)\n\t\twg.Add(1)\n\t\tgo func(ch chan int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor c := range ch {\n\t\t\t\tout <- c\n\t\t\t}\n\t\t}(getChan)\n\t}\n\tgo func() {\n\t\tdefer close(out)\n\t\twg.Wait()\n\t}()\n\treturn out\n}\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n\tres := Pipe(nums, Events, M2, M2)\n\tfor v := range res {\n\t\tfmt.Printf(\"%d \", v)\n\t}\n}\n\n```\n\n完整代码查看：https://github.com/nhdeng/gopipe","source":"_posts/go/pipe.md","raw":"---\ntitle: go高并发模式之管道模式\ndate: 2023-03-30 07:48:00\ntags: [\"go\", \"pipe\", \"channel\"]\nexcerpt: go语言精髓之一就是高度支持并发性，以下就是结合设计模式的管道模式演绎下golang的高并发场景处理。\n---\n\n### 什么是管道模式？\n白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。\n```bash\n#Linux命令举例\ncat log.txt | grep \"hello\" | head xx\n```\n\n### go当中的管道模式形式\n举例：\n\n从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：\n\n![流程图](/images/go/pipe/pipe1.png)\n\n使用go编写类似于管道的形式的代码大概如下所示：\n```golang\nimport \"fmt\"\n\n// Events 找出偶数\nfunc Events(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        if input[i]%2 == 0 {\n        out = append(out, input[i])\n    }\n    return out\n}\n\n// M2 数字乘2\nfunc M2(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*2)\n    }\n    return out\n}\n\n// M5 数字乘5\nfunc M5(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*5)\n    }\n    return out\n}\n\n// Cmd 定义管道函数的参数类型\ntype Cmd func(list []int) (ret []int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 Cmd, f3 Cmd) []int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    res := Pipe(nums, Events, M2, M5)\n    for _, val := range res {\n        fmt.Printf(\"%d \", val)\n    }\n}\n```\n上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；\n\n### 使用channel优化\n加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：\n\n![加入chan的流程图](/images/go/pipe/pipe2.png)\n\n约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。\n```golang\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < len(input); i++ {\n            if input[i]%2 == 0 {\n                ch <- input[i]\n            }\n        }\n    }()\n    return ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 2\n        }\n    }()\n    return ch\n}\n// M5 将偶数乘以5\nfunc M5(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 5\n        }\n    }()\n    return ch\n}\n\ntype Cmd func([]int) chan int\n// PipeCmd 定义管道函数的参数类型\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 PipeCmd, f3 PipeCmd) chan int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    wg := sync.WaitGroup{}\n    res := Pipe(nums, Events, M2, M5)\n    for v := range res {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            fmt.Printf(\"%d \", v)\n        }()\n    }\n    wg.Wait()\n}\n\n```\n\n### 管道模式之多路复用\n白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：\n\n![多路复用流程图](/images/go/pipe/pipe3.png)\n\n```golang\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := 0; i < len(input); i++ {\n\t\t\tif input[i]%2 == 0 {\n\t\t\t\tch <- input[i]\n\t\t\t}\n\t\t}\n\t}()\n\treturn ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := range input {\n\t\t\ttime.Sleep(time.Second * 2)\n\t\t\tch <- i * 2\n\t\t}\n\t}()\n\treturn ch\n}\n\ntype Cmd func([]int) chan int\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, ps ...PipeCmd) chan int {\n\twg := sync.WaitGroup{}\n\tevench := f1(nums) // 找偶数\n\tout := make(chan int)\n\tfor _, p := range ps {\n\t\tgetChan := p(evench)\n\t\twg.Add(1)\n\t\tgo func(ch chan int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor c := range ch {\n\t\t\t\tout <- c\n\t\t\t}\n\t\t}(getChan)\n\t}\n\tgo func() {\n\t\tdefer close(out)\n\t\twg.Wait()\n\t}()\n\treturn out\n}\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n\tres := Pipe(nums, Events, M2, M2)\n\tfor v := range res {\n\t\tfmt.Printf(\"%d \", v)\n\t}\n}\n\n```\n\n完整代码查看：https://github.com/nhdeng/gopipe","slug":"go/pipe","published":1,"updated":"2023-03-30T05:57:17.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi4m00096ouph3gy79jw","content":"<h3 id=\"什么是管道模式？\"><a href=\"#什么是管道模式？\" class=\"headerlink\" title=\"什么是管道模式？\"></a>什么是管道模式？</h3><p>白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Linux命令举例</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> log.txt | grep <span class=\"string\">&quot;hello&quot;</span> | <span class=\"built_in\">head</span> xx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"go当中的管道模式形式\"><a href=\"#go当中的管道模式形式\" class=\"headerlink\" title=\"go当中的管道模式形式\"></a>go当中的管道模式形式</h3><p>举例：</p>\n<p>从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe1.png\" alt=\"流程图\"></p>\n<p>使用go编写类似于管道的形式的代码大概如下所示：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 数字乘2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M5 数字乘5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">5</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(list []<span class=\"type\">int</span>)</span></span> (ret []<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 Cmd, f3 Cmd)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；</p>\n<h3 id=\"使用channel优化\"><a href=\"#使用channel优化\" class=\"headerlink\" title=\"使用channel优化\"></a>使用channel优化</h3><p>加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe2.png\" alt=\"加入chan的流程图\"></p>\n<p>约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                ch &lt;- input[i]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// M5 将偶数乘以5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">5</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"comment\">// PipeCmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 PipeCmd, f3 PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管道模式之多路复用\"><a href=\"#管道模式之多路复用\" class=\"headerlink\" title=\"管道模式之多路复用\"></a>管道模式之多路复用</h3><p>白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe3.png\" alt=\"多路复用流程图\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tch &lt;- input[i]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, ps ...PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\twg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\tevench := f1(nums) <span class=\"comment\">// 找偶数</span></span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, p := <span class=\"keyword\">range</span> ps &#123;</span><br><span class=\"line\">\t\tgetChan := p(evench)</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> c := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\t\t\t\tout &lt;- c</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;(getChan)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t\twg.Wait()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">\tres := Pipe(nums, Events, M2, M2)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完整代码查看：<a href=\"https://github.com/nhdeng/gopipe\">https://github.com/nhdeng/gopipe</a></p>\n","site":{"data":{}},"more":"<h3 id=\"什么是管道模式？\"><a href=\"#什么是管道模式？\" class=\"headerlink\" title=\"什么是管道模式？\"></a>什么是管道模式？</h3><p>白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Linux命令举例</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> log.txt | grep <span class=\"string\">&quot;hello&quot;</span> | <span class=\"built_in\">head</span> xx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"go当中的管道模式形式\"><a href=\"#go当中的管道模式形式\" class=\"headerlink\" title=\"go当中的管道模式形式\"></a>go当中的管道模式形式</h3><p>举例：</p>\n<p>从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe1.png\" alt=\"流程图\"></p>\n<p>使用go编写类似于管道的形式的代码大概如下所示：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 数字乘2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M5 数字乘5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">5</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(list []<span class=\"type\">int</span>)</span></span> (ret []<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 Cmd, f3 Cmd)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；</p>\n<h3 id=\"使用channel优化\"><a href=\"#使用channel优化\" class=\"headerlink\" title=\"使用channel优化\"></a>使用channel优化</h3><p>加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe2.png\" alt=\"加入chan的流程图\"></p>\n<p>约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                ch &lt;- input[i]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// M5 将偶数乘以5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">5</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"comment\">// PipeCmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 PipeCmd, f3 PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管道模式之多路复用\"><a href=\"#管道模式之多路复用\" class=\"headerlink\" title=\"管道模式之多路复用\"></a>管道模式之多路复用</h3><p>白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe3.png\" alt=\"多路复用流程图\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tch &lt;- input[i]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, ps ...PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\twg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\tevench := f1(nums) <span class=\"comment\">// 找偶数</span></span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, p := <span class=\"keyword\">range</span> ps &#123;</span><br><span class=\"line\">\t\tgetChan := p(evench)</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> c := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\t\t\t\tout &lt;- c</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;(getChan)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t\twg.Wait()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">\tres := Pipe(nums, Events, M2, M2)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完整代码查看：<a href=\"https://github.com/nhdeng/gopipe\">https://github.com/nhdeng/gopipe</a></p>\n"},{"title":"go仿射","date":"2023-05-17T06:16:26.000Z","excerpt":"在 Go 中，可以使用 reflect 包来实现反射。reflect 提供了一组函数和类型，可以在运行时获取对象的类型信息、字段值、调用方法等。","_content":"## reflect\n在**运行时**动态获取或设置变量的各种信息，比如变量的类型（type），类别（kind），值（value）\n\n## 典型方法\n- reflect.TypeOf(变量)：专门用来处理类型，用于获取给定值的类型信息\n- reflect.ValueOf(变量)：专门用来处理值，用于获取给定值的反射值对象\n- t.NumField()：用来获取结构体（不能是结构体指针）的属性的个数\n- t.ELem()用来获取指针指向的内容\n- t.Kind()：用来获取变量的类型是int/string/array/func/ptr/struct\n- t.Set(变量)：给仿射对象设置值\n\n## 示例\n1. 仿射实体 获取仿射struct所有属性\n```golang\ntype User struct {\n\tUserId   int  \n\tUserName string\n}\n\nu := Object.User{}\nt := reflect.TypeOf(u)\nfor i:= 0; i < t.NumField(); i ++ {\n    fmt.Println(t.Field(i).Name, t.Field(i).Type)\n} \n```\n2. 仿射指针 获取仿射struct所有属性\n```golang\ntype User struct {\n    UserId int \n    Username string\n}\nu := &User{}\nt := reflect.TypeOf(u)\n// 使用Kind()方法判断当前变量是否为指针\nif t.Kind() == reflect.Ptr {\n    // 如果是指针使用Elem()方法获取当前指针指向的内容  \n    t = t.Elem()\n}\nfor i := 0; i < t.NumField(); i++ {\n    fmt.Println(t.Field(i).Name, t.Field(i).Type)    \n}\n```\n3. 将切片映射为struct\n```golang\ntype User struct {\n    UserId int\n    Username string\n}\nvalues := []interface{}{1, \"dengnanhao\"}\nu := &User{}\nt := reflect.TypeOf(u)\nt = t.Elem()\nfor i:=0; i<t.NumField();i++ {\n    if t.Field(i).Kind() == reflect.ValueOf(values[i]).Kind() {\n        t.Field(i).Set(reflect.ValueOf(values[i]))\n    }\n}\n```\n4. 将map映射为struct\n```golang\ntype User struct {\n    UserId int \n    Username string\n    Age1 int `name:\"age\"`\n}\n\nm := map[string]interface{}{\n    Id: 1,\n    UserId: 10,\n    Username: \"dengnanhao\",\n    Age: \"20\"\n}\n// 将map转化为struct\nfunc Map2Struct(m map[string]interface{}, u interface{}) {\n    u1 := reflec.ValueOf(u)\n    // 判断u是否为指针\n    if u1.Kind() == reflect.Ptr {\n        u1 := u1.Elem()\n        // 判断u是否为结构体\n        if u1.Kind() == reflect.Struct {\n            findFromMap := func(key string, tag string) interface{} {\n                for k, v := range map {\n                    if k == key || key == tag {\n                        return v\n                    }\n                }\n                return nil\n            }\n            for i:=0; i < u1.NumField(); i ++ {\n                // 将ValueOf与TypeOf进行转换\n                // map的key匹配结构体的属性或者name标签，任意一个匹配上就进行返回，主要匹配属性\n                val := findFromMap(u1.Type().Field(i).Name, u1.Type().Field(i).Tag.Get(\"name\"))\n                if val != nil && reflect.ValueOf(val).Kind() == u1.Field(i).Kind() {\n                    u1.Field(i).Set(reflect.ValueOf(val))\n                }\n            }\n        } else {\n            panic(\"u must struce\")\n        }\n    } else {\n        panic(\"u must pointer\")\n    }\n}\n\n```","source":"_posts/go/reflect.md","raw":"---\ntitle: go仿射\ndate: 2023-05-17 14:16:26\ntags: [\"go\", \"reflect\"]\nexcerpt: 在 Go 中，可以使用 reflect 包来实现反射。reflect 提供了一组函数和类型，可以在运行时获取对象的类型信息、字段值、调用方法等。\n---\n## reflect\n在**运行时**动态获取或设置变量的各种信息，比如变量的类型（type），类别（kind），值（value）\n\n## 典型方法\n- reflect.TypeOf(变量)：专门用来处理类型，用于获取给定值的类型信息\n- reflect.ValueOf(变量)：专门用来处理值，用于获取给定值的反射值对象\n- t.NumField()：用来获取结构体（不能是结构体指针）的属性的个数\n- t.ELem()用来获取指针指向的内容\n- t.Kind()：用来获取变量的类型是int/string/array/func/ptr/struct\n- t.Set(变量)：给仿射对象设置值\n\n## 示例\n1. 仿射实体 获取仿射struct所有属性\n```golang\ntype User struct {\n\tUserId   int  \n\tUserName string\n}\n\nu := Object.User{}\nt := reflect.TypeOf(u)\nfor i:= 0; i < t.NumField(); i ++ {\n    fmt.Println(t.Field(i).Name, t.Field(i).Type)\n} \n```\n2. 仿射指针 获取仿射struct所有属性\n```golang\ntype User struct {\n    UserId int \n    Username string\n}\nu := &User{}\nt := reflect.TypeOf(u)\n// 使用Kind()方法判断当前变量是否为指针\nif t.Kind() == reflect.Ptr {\n    // 如果是指针使用Elem()方法获取当前指针指向的内容  \n    t = t.Elem()\n}\nfor i := 0; i < t.NumField(); i++ {\n    fmt.Println(t.Field(i).Name, t.Field(i).Type)    \n}\n```\n3. 将切片映射为struct\n```golang\ntype User struct {\n    UserId int\n    Username string\n}\nvalues := []interface{}{1, \"dengnanhao\"}\nu := &User{}\nt := reflect.TypeOf(u)\nt = t.Elem()\nfor i:=0; i<t.NumField();i++ {\n    if t.Field(i).Kind() == reflect.ValueOf(values[i]).Kind() {\n        t.Field(i).Set(reflect.ValueOf(values[i]))\n    }\n}\n```\n4. 将map映射为struct\n```golang\ntype User struct {\n    UserId int \n    Username string\n    Age1 int `name:\"age\"`\n}\n\nm := map[string]interface{}{\n    Id: 1,\n    UserId: 10,\n    Username: \"dengnanhao\",\n    Age: \"20\"\n}\n// 将map转化为struct\nfunc Map2Struct(m map[string]interface{}, u interface{}) {\n    u1 := reflec.ValueOf(u)\n    // 判断u是否为指针\n    if u1.Kind() == reflect.Ptr {\n        u1 := u1.Elem()\n        // 判断u是否为结构体\n        if u1.Kind() == reflect.Struct {\n            findFromMap := func(key string, tag string) interface{} {\n                for k, v := range map {\n                    if k == key || key == tag {\n                        return v\n                    }\n                }\n                return nil\n            }\n            for i:=0; i < u1.NumField(); i ++ {\n                // 将ValueOf与TypeOf进行转换\n                // map的key匹配结构体的属性或者name标签，任意一个匹配上就进行返回，主要匹配属性\n                val := findFromMap(u1.Type().Field(i).Name, u1.Type().Field(i).Tag.Get(\"name\"))\n                if val != nil && reflect.ValueOf(val).Kind() == u1.Field(i).Kind() {\n                    u1.Field(i).Set(reflect.ValueOf(val))\n                }\n            }\n        } else {\n            panic(\"u must struce\")\n        }\n    } else {\n        panic(\"u must pointer\")\n    }\n}\n\n```","slug":"go/reflect","published":1,"updated":"2023-05-27T08:37:53.260Z","_id":"clhu5qi4o000b6oup4yp3fdcf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h2><p>在<strong>运行时</strong>动态获取或设置变量的各种信息，比如变量的类型（type），类别（kind），值（value）</p>\n<h2 id=\"典型方法\"><a href=\"#典型方法\" class=\"headerlink\" title=\"典型方法\"></a>典型方法</h2><ul>\n<li>reflect.TypeOf(变量)：专门用来处理类型，用于获取给定值的类型信息</li>\n<li>reflect.ValueOf(变量)：专门用来处理值，用于获取给定值的反射值对象</li>\n<li>t.NumField()：用来获取结构体（不能是结构体指针）的属性的个数</li>\n<li>t.ELem()用来获取指针指向的内容</li>\n<li>t.Kind()：用来获取变量的类型是int&#x2F;string&#x2F;array&#x2F;func&#x2F;ptr&#x2F;struct</li>\n<li>t.Set(变量)：给仿射对象设置值</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><ol>\n<li>仿射实体 获取仿射struct所有属性<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tUserId   <span class=\"type\">int</span>  </span><br><span class=\"line\">\tUserName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">u := Object.User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; t.NumField(); i ++ &#123;</span><br><span class=\"line\">    fmt.Println(t.Field(i).Name, t.Field(i).Type)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></li>\n<li>仿射指针 获取仿射struct所有属性<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span> </span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u := &amp;User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\"><span class=\"comment\">// 使用Kind()方法判断当前变量是否为指针</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是指针使用Elem()方法获取当前指针指向的内容  </span></span><br><span class=\"line\">    t = t.Elem()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class=\"line\">    fmt.Println(t.Field(i).Name, t.Field(i).Type)    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将切片映射为struct<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span></span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">values := []<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;dengnanhao&quot;</span>&#125;</span><br><span class=\"line\">u := &amp;User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\">t = t.Elem()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;t.NumField();i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.Field(i).Kind() == reflect.ValueOf(values[i]).Kind() &#123;</span><br><span class=\"line\">        t.Field(i).Set(reflect.ValueOf(values[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将map映射为struct<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span> </span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">    Age1 <span class=\"type\">int</span> <span class=\"string\">`name:&quot;age&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    Id: <span class=\"number\">1</span>,</span><br><span class=\"line\">    UserId: <span class=\"number\">10</span>,</span><br><span class=\"line\">    Username: <span class=\"string\">&quot;dengnanhao&quot;</span>,</span><br><span class=\"line\">    Age: <span class=\"string\">&quot;20&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将map转化为struct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Map2Struct</span><span class=\"params\">(m <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;, u <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    u1 := reflec.ValueOf(u)</span><br><span class=\"line\">    <span class=\"comment\">// 判断u是否为指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> u1.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">        u1 := u1.Elem()</span><br><span class=\"line\">        <span class=\"comment\">// 判断u是否为结构体</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> u1.Kind() == reflect.Struct &#123;</span><br><span class=\"line\">            findFromMap := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"type\">string</span>, tag <span class=\"type\">string</span>)</span></span> <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> <span class=\"keyword\">map</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> k == key || key == tag &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> v</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; u1.NumField(); i ++ &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将ValueOf与TypeOf进行转换</span></span><br><span class=\"line\">                <span class=\"comment\">// map的key匹配结构体的属性或者name标签，任意一个匹配上就进行返回，主要匹配属性</span></span><br><span class=\"line\">                val := findFromMap(u1.Type().Field(i).Name, u1.Type().Field(i).Tag.Get(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val != <span class=\"literal\">nil</span> &amp;&amp; reflect.ValueOf(val).Kind() == u1.Field(i).Kind() &#123;</span><br><span class=\"line\">                    u1.Field(i).Set(reflect.ValueOf(val))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;u must struce&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;u must pointer&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"more":"<h2 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h2><p>在<strong>运行时</strong>动态获取或设置变量的各种信息，比如变量的类型（type），类别（kind），值（value）</p>\n<h2 id=\"典型方法\"><a href=\"#典型方法\" class=\"headerlink\" title=\"典型方法\"></a>典型方法</h2><ul>\n<li>reflect.TypeOf(变量)：专门用来处理类型，用于获取给定值的类型信息</li>\n<li>reflect.ValueOf(变量)：专门用来处理值，用于获取给定值的反射值对象</li>\n<li>t.NumField()：用来获取结构体（不能是结构体指针）的属性的个数</li>\n<li>t.ELem()用来获取指针指向的内容</li>\n<li>t.Kind()：用来获取变量的类型是int&#x2F;string&#x2F;array&#x2F;func&#x2F;ptr&#x2F;struct</li>\n<li>t.Set(变量)：给仿射对象设置值</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><ol>\n<li>仿射实体 获取仿射struct所有属性<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tUserId   <span class=\"type\">int</span>  </span><br><span class=\"line\">\tUserName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">u := Object.User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; t.NumField(); i ++ &#123;</span><br><span class=\"line\">    fmt.Println(t.Field(i).Name, t.Field(i).Type)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></li>\n<li>仿射指针 获取仿射struct所有属性<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span> </span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u := &amp;User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\"><span class=\"comment\">// 使用Kind()方法判断当前变量是否为指针</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是指针使用Elem()方法获取当前指针指向的内容  </span></span><br><span class=\"line\">    t = t.Elem()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class=\"line\">    fmt.Println(t.Field(i).Name, t.Field(i).Type)    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将切片映射为struct<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span></span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">values := []<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;dengnanhao&quot;</span>&#125;</span><br><span class=\"line\">u := &amp;User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\">t = t.Elem()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;t.NumField();i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.Field(i).Kind() == reflect.ValueOf(values[i]).Kind() &#123;</span><br><span class=\"line\">        t.Field(i).Set(reflect.ValueOf(values[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将map映射为struct<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span> </span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">    Age1 <span class=\"type\">int</span> <span class=\"string\">`name:&quot;age&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    Id: <span class=\"number\">1</span>,</span><br><span class=\"line\">    UserId: <span class=\"number\">10</span>,</span><br><span class=\"line\">    Username: <span class=\"string\">&quot;dengnanhao&quot;</span>,</span><br><span class=\"line\">    Age: <span class=\"string\">&quot;20&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将map转化为struct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Map2Struct</span><span class=\"params\">(m <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;, u <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    u1 := reflec.ValueOf(u)</span><br><span class=\"line\">    <span class=\"comment\">// 判断u是否为指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> u1.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">        u1 := u1.Elem()</span><br><span class=\"line\">        <span class=\"comment\">// 判断u是否为结构体</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> u1.Kind() == reflect.Struct &#123;</span><br><span class=\"line\">            findFromMap := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"type\">string</span>, tag <span class=\"type\">string</span>)</span></span> <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> <span class=\"keyword\">map</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> k == key || key == tag &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> v</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; u1.NumField(); i ++ &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将ValueOf与TypeOf进行转换</span></span><br><span class=\"line\">                <span class=\"comment\">// map的key匹配结构体的属性或者name标签，任意一个匹配上就进行返回，主要匹配属性</span></span><br><span class=\"line\">                val := findFromMap(u1.Type().Field(i).Name, u1.Type().Field(i).Tag.Get(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val != <span class=\"literal\">nil</span> &amp;&amp; reflect.ValueOf(val).Kind() == u1.Field(i).Kind() &#123;</span><br><span class=\"line\">                    u1.Field(i).Set(reflect.ValueOf(val))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;u must struce&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;u must pointer&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Redis基本数据类型及语法","date":"2023-04-02T06:06:18.000Z","excerpt":"本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。","_content":"\n# Redis基础-基本数据类型及语法\n本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n\nredis官网文档：https://redis.io\n\nredis中文文档：http://www.redis.cn\n\n## 一、docker安装redis\n1. 建立宿主机redis容器目录\n```bash\nmkdir -p /app/redis\n```\n2. 拷贝redis配置文件redis.conf到/app/redis目录下（redis配置文件官网下载地址：https://redis.io/download/）\n```bash\n# 修改redis.conf默认配置\n# 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1\n# 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败\n# 3. 【可选】开启redis数据持久化 appendonly yes \n# 4. 【可选】开启redis验证 requirepass 123456\n```\n3. 创建redis容器实例\n```bash\n# 拉取redis镜像\ndocker pull redis\n\n# 运行实例并挂载容器数据卷\ndocker run -d --name=redis --network=host --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf\n\n# 进入容器实例\ndocker exec -d redis /bin/bash\n\n# 执行redis-cli\n```\n## 二、redis键（key）常用命令\n1. 查看当前库所有key\n```bash\nKeys *\n```\n2. 判断某个key是否存在\n```bash\nExists key\n```\n3. 查看key类型\n```bash\nType key\n```\n3. 删除指定key\n```bash\nDel key\n```\n4. 非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作\n```bash\nUnlink key\n```\n5. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nTTL key\n```\n6. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nExpire key\n```\n\n7. 将当前数据库的 key移动到给定的数据库 db 当中\n```bash\nMove key dbIndex # dbIndex默认取证范围0-15\n```\n7. 切换数据库\n```bash\nSelect dbIndex # dbIndex默认取证范围0-15，默认为0\n```\n8. 查看当前数据局key的数量\n```bash\nDBSize\n```\n9. 清空当前库\n```bash\nFlushDB\n```\n10. 清空所有库\n```bash\nFlushAll\n```\n```bash\n# 查看具体数据类型的命令\nhelp @string \n```\n**更多命令查看官网：https://redis.io/commands/，**\n\n\n## 三、redis常用数据类型及命令\nredis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。\n### Redis字符串（String）\nString 单值单value\n1. 设置字符串\n```bash\nSet key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]\n```\nOptions说明：\n- EX seconds:以秒为单位设置过期时间；\n- PX milliseconds:以毫秒为单位设置过期时间；\n- EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；\n- PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；\n- NX:键不存在时设置键值；\n- XX:键存在时设置键值；\n- KEEPTTL:保留设置前的指定键的生存时间；\n- GET:返回指定键原本的值，若键不存在时返回nil\n\n2. 获取字符串`Get key`\n3. 同时设置获取多个键值\n```bash\nMSet key value [key value...]\nMGet key [key...]\n# 同时设置多个键值对当且仅当所有的key都不存在时\nMSetNX key value [key value...]\n```\n4. 获取指定区间范围内的值\n```bash\n# 相当于字符串的截取相当于substr，从0到-1表示全部\nGetRange name 0 2\nSetRange name 0 hello\n```\n5. 数值增减，只能是数字才能进行加减\n```bash\n# 递增数字\nIncr key\n# 增加指定的整数\nIncrBy key increment\n# 递减数字\nDecr key\n# 减少指定的整数\nDecrBy key decrement\n```\n6. 获取字符串长度和内容增加\n```bash\nStrLen key\nAppend key value\n```\n7. getset(先get再set)\n```bash\nGetSet key value\n```\n\n### Redis 列表（List）\nList 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。\n\n1. 为列表添加值\n```bash\nLPush/RPush key value [value...]\n```\n2. 查看列表指定区间元素\n```bash\n#0到-1代表查看所有元素\nLRange key start top\n```\n3. 移出并获取列表的第一个元素\n```bash\nLPop/RPop key \n```\n4. 按照索引下标获取元素\n```bash\nLIndex key index \n```\n5. 获取列表中元素的个数\n```bash\nLLen key\n```\n6. 删除N个数值等于xx的元素\n```bash\n# N为0代表指定值全部删除\nLRem key N xx\n```\n7. 截取指定Key范围内的值再指定给key\n```bash\nLTrim key start stop\n```\n8. 移除列表的最后一个元素并将该元素添加到另一个列表并返回\n```bash\nRPopLPush 源列表 目标列表\n```\n9. 通过索引设置列表元素中的值\n```bash\nLSet key index value\n```\n10. 向列表中插入新值\n```bash\nLInsert key Before/After 已有值 新值\n```\n\n### Redis 哈希（Hash）\nKV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。\n\n1. 基本操作\n```bash\nHSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]\n```\n2. 获取某个key中的键值对数量\n```bash\nHLen key\n```\n3. 查看hash指定字段是否存在\n```bash\nHExists key field\n```\n4. 查看hash中所有field或者value\n```bash\nHKeys/HVals key\n```\n5. 为hash表中的指定字段整加/浮点加\n```bash\nHIncrBy/HIncrByFloat key field value\n```\n6. 不存在就赋值，存在就无效\n```bash\nHSetNX key field value\n```\n### Redis 集合（Set）\n单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n1. 向集合中添加一个/多个元素\n```bash\nSAdd key member [member...]\n```\n2. 遍历集合key中的所有元素\n```bash\nSMembers key \n```\n3. 判断元素是否存在于集合中\n```bash\nSISMember key value \n```\n4. 移除集合中的元素\n```bash\nSRem key value \n```\n5. 获取集合中元素的个数\n```bash\nSCard key\n```\n6. 从集合中随机展现N个元素，元素不删除\n```bash\nSRandMember key N \n```\n6. 从集合中随机弹出N个元素，元素删除\n```bash\nSPop key N \n```\n6. 将集合中A中的某个值移入B集合中\n```bash\nSMove A B Avalue \n```\n7. 集合运算\n```bash\n# A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素\nSDiff key [key...]\n\n# A、B集合的并集运算\nSUnion key [key...]\n\n# A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合\nSInter key [key...]\n\n# 给定集合的交集产生的集合的基数，N代表key的个数\nSInterCard N key [key...]\n```\n\n### Redis 有序集合（ZSet）\nRedis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。\n\n1. 添加元素\n```bash \nZAdd key score member [score member...]\n```\n2. 通过索引区间返回有序集合中指定区间内的成员\n```bash \n# 按照元素分数从小到大，[withscores]是否带上分数\nZRange key start stop [withscores]\n```\n3. 通过索引区间返回有序集合中指定区间内的成员，倒序排列\n```bash \n# 按照元素分数从大到小，[withscores]是否带上分数\nZRevRange key start stop [withscores]\n```\n4. 指定分数范围内的元素\n```bash\nZRangeByScore key min max [withScores] [limit offset count]\n```\n5. 获取元素的分数\n```bash\nZScore key member\n```\n6. 获取集合中元素的数量\n```bash\nZCard key\n```\n7. 移除元素\n```bash\nZRem key member\n```\n8. 增加某个元素的分数\n```bash\nZIncrBy key increment member\n```\n9. 获取指定分数范围内的元素个数\n```bash\nZCount key min max\n```\n10. **从键名列表中的第一个**非空排序集中弹出一个或者多个元素，它们是成员分数对\n```bash\n# 从多个有序集合中弹出2个元素\nZMPop numKeys key [key...] min/max count 2\n```\n11. 获取有序集合中的元素下标值\n```bash\nZRank key values member\n```\n12. 获取有序集合中的逆序元素下标值\n```bash\nZRevRank key values member\n```\n\n## 四、基础数据类型的基本使用场景\n\n| 数据类型   | 经典使用场景                                   |\n|--------|------------------------------------------|\n| string | 抖音视频/商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id） |\n| List   | 微信公众号消息订阅；                               |\n| Hash   | 简单的购物车；                                  |\n| Set    | 抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人           |\n| ZSet   | 根据商品销售对商品进行排名                            |\n\n\n\n\n\n","source":"_posts/redis/base.md","raw":"---\ntitle: Redis基本数据类型及语法\ndate: 2023-04-02 14:06:18\ntags: [\"redis\", \"string\", \"list\", \"hash\", \"set\", \"zset\"]\nexcerpt: 本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n---\n\n# Redis基础-基本数据类型及语法\n本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n\nredis官网文档：https://redis.io\n\nredis中文文档：http://www.redis.cn\n\n## 一、docker安装redis\n1. 建立宿主机redis容器目录\n```bash\nmkdir -p /app/redis\n```\n2. 拷贝redis配置文件redis.conf到/app/redis目录下（redis配置文件官网下载地址：https://redis.io/download/）\n```bash\n# 修改redis.conf默认配置\n# 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1\n# 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败\n# 3. 【可选】开启redis数据持久化 appendonly yes \n# 4. 【可选】开启redis验证 requirepass 123456\n```\n3. 创建redis容器实例\n```bash\n# 拉取redis镜像\ndocker pull redis\n\n# 运行实例并挂载容器数据卷\ndocker run -d --name=redis --network=host --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf\n\n# 进入容器实例\ndocker exec -d redis /bin/bash\n\n# 执行redis-cli\n```\n## 二、redis键（key）常用命令\n1. 查看当前库所有key\n```bash\nKeys *\n```\n2. 判断某个key是否存在\n```bash\nExists key\n```\n3. 查看key类型\n```bash\nType key\n```\n3. 删除指定key\n```bash\nDel key\n```\n4. 非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作\n```bash\nUnlink key\n```\n5. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nTTL key\n```\n6. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nExpire key\n```\n\n7. 将当前数据库的 key移动到给定的数据库 db 当中\n```bash\nMove key dbIndex # dbIndex默认取证范围0-15\n```\n7. 切换数据库\n```bash\nSelect dbIndex # dbIndex默认取证范围0-15，默认为0\n```\n8. 查看当前数据局key的数量\n```bash\nDBSize\n```\n9. 清空当前库\n```bash\nFlushDB\n```\n10. 清空所有库\n```bash\nFlushAll\n```\n```bash\n# 查看具体数据类型的命令\nhelp @string \n```\n**更多命令查看官网：https://redis.io/commands/，**\n\n\n## 三、redis常用数据类型及命令\nredis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。\n### Redis字符串（String）\nString 单值单value\n1. 设置字符串\n```bash\nSet key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]\n```\nOptions说明：\n- EX seconds:以秒为单位设置过期时间；\n- PX milliseconds:以毫秒为单位设置过期时间；\n- EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；\n- PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；\n- NX:键不存在时设置键值；\n- XX:键存在时设置键值；\n- KEEPTTL:保留设置前的指定键的生存时间；\n- GET:返回指定键原本的值，若键不存在时返回nil\n\n2. 获取字符串`Get key`\n3. 同时设置获取多个键值\n```bash\nMSet key value [key value...]\nMGet key [key...]\n# 同时设置多个键值对当且仅当所有的key都不存在时\nMSetNX key value [key value...]\n```\n4. 获取指定区间范围内的值\n```bash\n# 相当于字符串的截取相当于substr，从0到-1表示全部\nGetRange name 0 2\nSetRange name 0 hello\n```\n5. 数值增减，只能是数字才能进行加减\n```bash\n# 递增数字\nIncr key\n# 增加指定的整数\nIncrBy key increment\n# 递减数字\nDecr key\n# 减少指定的整数\nDecrBy key decrement\n```\n6. 获取字符串长度和内容增加\n```bash\nStrLen key\nAppend key value\n```\n7. getset(先get再set)\n```bash\nGetSet key value\n```\n\n### Redis 列表（List）\nList 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。\n\n1. 为列表添加值\n```bash\nLPush/RPush key value [value...]\n```\n2. 查看列表指定区间元素\n```bash\n#0到-1代表查看所有元素\nLRange key start top\n```\n3. 移出并获取列表的第一个元素\n```bash\nLPop/RPop key \n```\n4. 按照索引下标获取元素\n```bash\nLIndex key index \n```\n5. 获取列表中元素的个数\n```bash\nLLen key\n```\n6. 删除N个数值等于xx的元素\n```bash\n# N为0代表指定值全部删除\nLRem key N xx\n```\n7. 截取指定Key范围内的值再指定给key\n```bash\nLTrim key start stop\n```\n8. 移除列表的最后一个元素并将该元素添加到另一个列表并返回\n```bash\nRPopLPush 源列表 目标列表\n```\n9. 通过索引设置列表元素中的值\n```bash\nLSet key index value\n```\n10. 向列表中插入新值\n```bash\nLInsert key Before/After 已有值 新值\n```\n\n### Redis 哈希（Hash）\nKV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。\n\n1. 基本操作\n```bash\nHSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]\n```\n2. 获取某个key中的键值对数量\n```bash\nHLen key\n```\n3. 查看hash指定字段是否存在\n```bash\nHExists key field\n```\n4. 查看hash中所有field或者value\n```bash\nHKeys/HVals key\n```\n5. 为hash表中的指定字段整加/浮点加\n```bash\nHIncrBy/HIncrByFloat key field value\n```\n6. 不存在就赋值，存在就无效\n```bash\nHSetNX key field value\n```\n### Redis 集合（Set）\n单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n1. 向集合中添加一个/多个元素\n```bash\nSAdd key member [member...]\n```\n2. 遍历集合key中的所有元素\n```bash\nSMembers key \n```\n3. 判断元素是否存在于集合中\n```bash\nSISMember key value \n```\n4. 移除集合中的元素\n```bash\nSRem key value \n```\n5. 获取集合中元素的个数\n```bash\nSCard key\n```\n6. 从集合中随机展现N个元素，元素不删除\n```bash\nSRandMember key N \n```\n6. 从集合中随机弹出N个元素，元素删除\n```bash\nSPop key N \n```\n6. 将集合中A中的某个值移入B集合中\n```bash\nSMove A B Avalue \n```\n7. 集合运算\n```bash\n# A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素\nSDiff key [key...]\n\n# A、B集合的并集运算\nSUnion key [key...]\n\n# A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合\nSInter key [key...]\n\n# 给定集合的交集产生的集合的基数，N代表key的个数\nSInterCard N key [key...]\n```\n\n### Redis 有序集合（ZSet）\nRedis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。\n\n1. 添加元素\n```bash \nZAdd key score member [score member...]\n```\n2. 通过索引区间返回有序集合中指定区间内的成员\n```bash \n# 按照元素分数从小到大，[withscores]是否带上分数\nZRange key start stop [withscores]\n```\n3. 通过索引区间返回有序集合中指定区间内的成员，倒序排列\n```bash \n# 按照元素分数从大到小，[withscores]是否带上分数\nZRevRange key start stop [withscores]\n```\n4. 指定分数范围内的元素\n```bash\nZRangeByScore key min max [withScores] [limit offset count]\n```\n5. 获取元素的分数\n```bash\nZScore key member\n```\n6. 获取集合中元素的数量\n```bash\nZCard key\n```\n7. 移除元素\n```bash\nZRem key member\n```\n8. 增加某个元素的分数\n```bash\nZIncrBy key increment member\n```\n9. 获取指定分数范围内的元素个数\n```bash\nZCount key min max\n```\n10. **从键名列表中的第一个**非空排序集中弹出一个或者多个元素，它们是成员分数对\n```bash\n# 从多个有序集合中弹出2个元素\nZMPop numKeys key [key...] min/max count 2\n```\n11. 获取有序集合中的元素下标值\n```bash\nZRank key values member\n```\n12. 获取有序集合中的逆序元素下标值\n```bash\nZRevRank key values member\n```\n\n## 四、基础数据类型的基本使用场景\n\n| 数据类型   | 经典使用场景                                   |\n|--------|------------------------------------------|\n| string | 抖音视频/商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id） |\n| List   | 微信公众号消息订阅；                               |\n| Hash   | 简单的购物车；                                  |\n| Set    | 抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人           |\n| ZSet   | 根据商品销售对商品进行排名                            |\n\n\n\n\n\n","slug":"redis/base","published":1,"updated":"2023-04-19T06:27:28.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi52001j6oupdzfu7k1u","content":"<h1 id=\"Redis基础-基本数据类型及语法\"><a href=\"#Redis基础-基本数据类型及语法\" class=\"headerlink\" title=\"Redis基础-基本数据类型及语法\"></a>Redis基础-基本数据类型及语法</h1><p>本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。</p>\n<p>redis官网文档：<a href=\"https://redis.io/\">https://redis.io</a></p>\n<p>redis中文文档：<a href=\"http://www.redis.cn/\">http://www.redis.cn</a></p>\n<h2 id=\"一、docker安装redis\"><a href=\"#一、docker安装redis\" class=\"headerlink\" title=\"一、docker安装redis\"></a>一、docker安装redis</h2><ol>\n<li>建立宿主机redis容器目录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /app/redis</span><br></pre></td></tr></table></figure></li>\n<li>拷贝redis配置文件redis.conf到&#x2F;app&#x2F;redis目录下（redis配置文件官网下载地址：<a href=\"https://redis.io/download/%EF%BC%89\">https://redis.io/download/）</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改redis.conf默认配置</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 【可选】开启redis数据持久化 appendonly yes </span></span><br><span class=\"line\"><span class=\"comment\"># 4. 【可选】开启redis验证 requirepass 123456</span></span><br></pre></td></tr></table></figure></li>\n<li>创建redis容器实例<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取redis镜像</span></span><br><span class=\"line\">docker pull redis</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行实例并挂载容器数据卷</span></span><br><span class=\"line\">docker run -d --name=redis --network=host --privileged=<span class=\"literal\">true</span> -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器实例</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -d redis /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行redis-cli</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"二、redis键（key）常用命令\"><a href=\"#二、redis键（key）常用命令\" class=\"headerlink\" title=\"二、redis键（key）常用命令\"></a>二、redis键（key）常用命令</h2><ol>\n<li><p>查看当前库所有key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keys *</span><br></pre></td></tr></table></figure></li>\n<li><p>判断某个key是否存在</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exists key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看key类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type key</span><br></pre></td></tr></table></figure></li>\n<li><p>删除指定key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Del key</span><br></pre></td></tr></table></figure></li>\n<li><p>非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unlink key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expire key</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将当前数据库的 key移动到给定的数据库 db 当中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move key dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15</span></span><br></pre></td></tr></table></figure></li>\n<li><p>切换数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15，默认为0</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查看当前数据局key的数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBSize</span><br></pre></td></tr></table></figure></li>\n<li><p>清空当前库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushDB</span><br></pre></td></tr></table></figure></li>\n<li><p>清空所有库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushAll</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看具体数据类型的命令</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> @string </span><br></pre></td></tr></table></figure>\n<p><strong>更多命令查看官网：<a href=\"https://redis.io/commands/%EF%BC%8C\">https://redis.io/commands/，</a></strong></p>\n</li>\n</ol>\n<h2 id=\"三、redis常用数据类型及命令\"><a href=\"#三、redis常用数据类型及命令\" class=\"headerlink\" title=\"三、redis常用数据类型及命令\"></a>三、redis常用数据类型及命令</h2><p>redis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。</p>\n<h3 id=\"Redis字符串（String）\"><a href=\"#Redis字符串（String）\" class=\"headerlink\" title=\"Redis字符串（String）\"></a>Redis字符串（String）</h3><p>String 单值单value</p>\n<ol>\n<li>设置字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>\nOptions说明：</li>\n</ol>\n<ul>\n<li>EX seconds:以秒为单位设置过期时间；</li>\n<li>PX milliseconds:以毫秒为单位设置过期时间；</li>\n<li>EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；</li>\n<li>PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；</li>\n<li>NX:键不存在时设置键值；</li>\n<li>XX:键存在时设置键值；</li>\n<li>KEEPTTL:保留设置前的指定键的生存时间；</li>\n<li>GET:返回指定键原本的值，若键不存在时返回nil</li>\n</ul>\n<ol start=\"2\">\n<li>获取字符串<code>Get key</code></li>\n<li>同时设置获取多个键值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSet key value [key value...]</span><br><span class=\"line\">MGet key [key...]</span><br><span class=\"line\"><span class=\"comment\"># 同时设置多个键值对当且仅当所有的key都不存在时</span></span><br><span class=\"line\">MSetNX key value [key value...]</span><br></pre></td></tr></table></figure></li>\n<li>获取指定区间范围内的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 相当于字符串的截取相当于substr，从0到-1表示全部</span></span><br><span class=\"line\">GetRange name 0 2</span><br><span class=\"line\">SetRange name 0 hello</span><br></pre></td></tr></table></figure></li>\n<li>数值增减，只能是数字才能进行加减<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 递增数字</span></span><br><span class=\"line\">Incr key</span><br><span class=\"line\"><span class=\"comment\"># 增加指定的整数</span></span><br><span class=\"line\">IncrBy key increment</span><br><span class=\"line\"><span class=\"comment\"># 递减数字</span></span><br><span class=\"line\">Decr key</span><br><span class=\"line\"><span class=\"comment\"># 减少指定的整数</span></span><br><span class=\"line\">DecrBy key decrement</span><br></pre></td></tr></table></figure></li>\n<li>获取字符串长度和内容增加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrLen key</span><br><span class=\"line\">Append key value</span><br></pre></td></tr></table></figure></li>\n<li>getset(先get再set)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GetSet key value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-列表（List）\"><a href=\"#Redis-列表（List）\" class=\"headerlink\" title=\"Redis 列表（List）\"></a>Redis 列表（List）</h3><p>List 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p>\n<ol>\n<li>为列表添加值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPush/RPush key value [value...]</span><br></pre></td></tr></table></figure></li>\n<li>查看列表指定区间元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#0到-1代表查看所有元素</span></span><br><span class=\"line\">LRange key start top</span><br></pre></td></tr></table></figure></li>\n<li>移出并获取列表的第一个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPop/RPop key </span><br></pre></td></tr></table></figure></li>\n<li>按照索引下标获取元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIndex key index </span><br></pre></td></tr></table></figure></li>\n<li>获取列表中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LLen key</span><br></pre></td></tr></table></figure></li>\n<li>删除N个数值等于xx的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># N为0代表指定值全部删除</span></span><br><span class=\"line\">LRem key N xx</span><br></pre></td></tr></table></figure></li>\n<li>截取指定Key范围内的值再指定给key<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LTrim key start stop</span><br></pre></td></tr></table></figure></li>\n<li>移除列表的最后一个元素并将该元素添加到另一个列表并返回<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPopLPush 源列表 目标列表</span><br></pre></td></tr></table></figure></li>\n<li>通过索引设置列表元素中的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSet key index value</span><br></pre></td></tr></table></figure></li>\n<li>向列表中插入新值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LInsert key Before/After 已有值 新值</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-哈希（Hash）\"><a href=\"#Redis-哈希（Hash）\" class=\"headerlink\" title=\"Redis 哈希（Hash）\"></a>Redis 哈希（Hash）</h3><p>KV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>\n<ol>\n<li>基本操作<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]</span><br></pre></td></tr></table></figure></li>\n<li>获取某个key中的键值对数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HLen key</span><br></pre></td></tr></table></figure></li>\n<li>查看hash指定字段是否存在<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HExists key field</span><br></pre></td></tr></table></figure></li>\n<li>查看hash中所有field或者value<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HKeys/HVals key</span><br></pre></td></tr></table></figure></li>\n<li>为hash表中的指定字段整加&#x2F;浮点加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HIncrBy/HIncrByFloat key field value</span><br></pre></td></tr></table></figure></li>\n<li>不存在就赋值，存在就无效<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSetNX key field value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-集合（Set）\"><a href=\"#Redis-集合（Set）\" class=\"headerlink\" title=\"Redis 集合（Set）\"></a>Redis 集合（Set）</h3><p>单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>\n<ol>\n<li>向集合中添加一个&#x2F;多个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAdd key member [member...]</span><br></pre></td></tr></table></figure></li>\n<li>遍历集合key中的所有元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMembers key </span><br></pre></td></tr></table></figure></li>\n<li>判断元素是否存在于集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SISMember key value </span><br></pre></td></tr></table></figure></li>\n<li>移除集合中的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRem key value </span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCard key</span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机展现N个元素，元素不删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRandMember key N </span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机弹出N个元素，元素删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SPop key N </span><br></pre></td></tr></table></figure></li>\n<li>将集合中A中的某个值移入B集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMove A B Avalue </span><br></pre></td></tr></table></figure></li>\n<li>集合运算<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素</span></span><br><span class=\"line\">SDiff key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的并集运算</span></span><br><span class=\"line\">SUnion key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合</span></span><br><span class=\"line\">SInter key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给定集合的交集产生的集合的基数，N代表key的个数</span></span><br><span class=\"line\">SInterCard N key [key...]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-有序集合（ZSet）\"><a href=\"#Redis-有序集合（ZSet）\" class=\"headerlink\" title=\"Redis 有序集合（ZSet）\"></a>Redis 有序集合（ZSet）</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>\n<ol>\n<li>添加元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZAdd key score member [score member...]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从小到大，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员，倒序排列<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从大到小，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRevRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>指定分数范围内的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRangeByScore key min max [withScores] [<span class=\"built_in\">limit</span> offset count]</span><br></pre></td></tr></table></figure></li>\n<li>获取元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZScore key member</span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCard key</span><br></pre></td></tr></table></figure></li>\n<li>移除元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRem key member</span><br></pre></td></tr></table></figure></li>\n<li>增加某个元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZIncrBy key increment member</span><br></pre></td></tr></table></figure></li>\n<li>获取指定分数范围内的元素个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCount key min max</span><br></pre></td></tr></table></figure></li>\n<li><strong>从键名列表中的第一个</strong>非空排序集中弹出一个或者多个元素，它们是成员分数对<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从多个有序集合中弹出2个元素</span></span><br><span class=\"line\">ZMPop numKeys key [key...] min/max count 2</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRank key values member</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的逆序元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRevRank key values member</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"四、基础数据类型的基本使用场景\"><a href=\"#四、基础数据类型的基本使用场景\" class=\"headerlink\" title=\"四、基础数据类型的基本使用场景\"></a>四、基础数据类型的基本使用场景</h2><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>经典使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>抖音视频&#x2F;商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id）</td>\n</tr>\n<tr>\n<td>List</td>\n<td>微信公众号消息订阅；</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>简单的购物车；</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人</td>\n</tr>\n<tr>\n<td>ZSet</td>\n<td>根据商品销售对商品进行排名</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"more":"<h1 id=\"Redis基础-基本数据类型及语法\"><a href=\"#Redis基础-基本数据类型及语法\" class=\"headerlink\" title=\"Redis基础-基本数据类型及语法\"></a>Redis基础-基本数据类型及语法</h1><p>本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。</p>\n<p>redis官网文档：<a href=\"https://redis.io/\">https://redis.io</a></p>\n<p>redis中文文档：<a href=\"http://www.redis.cn/\">http://www.redis.cn</a></p>\n<h2 id=\"一、docker安装redis\"><a href=\"#一、docker安装redis\" class=\"headerlink\" title=\"一、docker安装redis\"></a>一、docker安装redis</h2><ol>\n<li>建立宿主机redis容器目录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /app/redis</span><br></pre></td></tr></table></figure></li>\n<li>拷贝redis配置文件redis.conf到&#x2F;app&#x2F;redis目录下（redis配置文件官网下载地址：<a href=\"https://redis.io/download/%EF%BC%89\">https://redis.io/download/）</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改redis.conf默认配置</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 【可选】开启redis数据持久化 appendonly yes </span></span><br><span class=\"line\"><span class=\"comment\"># 4. 【可选】开启redis验证 requirepass 123456</span></span><br></pre></td></tr></table></figure></li>\n<li>创建redis容器实例<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取redis镜像</span></span><br><span class=\"line\">docker pull redis</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行实例并挂载容器数据卷</span></span><br><span class=\"line\">docker run -d --name=redis --network=host --privileged=<span class=\"literal\">true</span> -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器实例</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -d redis /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行redis-cli</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"二、redis键（key）常用命令\"><a href=\"#二、redis键（key）常用命令\" class=\"headerlink\" title=\"二、redis键（key）常用命令\"></a>二、redis键（key）常用命令</h2><ol>\n<li><p>查看当前库所有key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keys *</span><br></pre></td></tr></table></figure></li>\n<li><p>判断某个key是否存在</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exists key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看key类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type key</span><br></pre></td></tr></table></figure></li>\n<li><p>删除指定key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Del key</span><br></pre></td></tr></table></figure></li>\n<li><p>非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unlink key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expire key</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将当前数据库的 key移动到给定的数据库 db 当中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move key dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15</span></span><br></pre></td></tr></table></figure></li>\n<li><p>切换数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15，默认为0</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查看当前数据局key的数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBSize</span><br></pre></td></tr></table></figure></li>\n<li><p>清空当前库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushDB</span><br></pre></td></tr></table></figure></li>\n<li><p>清空所有库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushAll</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看具体数据类型的命令</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> @string </span><br></pre></td></tr></table></figure>\n<p><strong>更多命令查看官网：<a href=\"https://redis.io/commands/%EF%BC%8C\">https://redis.io/commands/，</a></strong></p>\n</li>\n</ol>\n<h2 id=\"三、redis常用数据类型及命令\"><a href=\"#三、redis常用数据类型及命令\" class=\"headerlink\" title=\"三、redis常用数据类型及命令\"></a>三、redis常用数据类型及命令</h2><p>redis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。</p>\n<h3 id=\"Redis字符串（String）\"><a href=\"#Redis字符串（String）\" class=\"headerlink\" title=\"Redis字符串（String）\"></a>Redis字符串（String）</h3><p>String 单值单value</p>\n<ol>\n<li>设置字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>\nOptions说明：</li>\n</ol>\n<ul>\n<li>EX seconds:以秒为单位设置过期时间；</li>\n<li>PX milliseconds:以毫秒为单位设置过期时间；</li>\n<li>EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；</li>\n<li>PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；</li>\n<li>NX:键不存在时设置键值；</li>\n<li>XX:键存在时设置键值；</li>\n<li>KEEPTTL:保留设置前的指定键的生存时间；</li>\n<li>GET:返回指定键原本的值，若键不存在时返回nil</li>\n</ul>\n<ol start=\"2\">\n<li>获取字符串<code>Get key</code></li>\n<li>同时设置获取多个键值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSet key value [key value...]</span><br><span class=\"line\">MGet key [key...]</span><br><span class=\"line\"><span class=\"comment\"># 同时设置多个键值对当且仅当所有的key都不存在时</span></span><br><span class=\"line\">MSetNX key value [key value...]</span><br></pre></td></tr></table></figure></li>\n<li>获取指定区间范围内的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 相当于字符串的截取相当于substr，从0到-1表示全部</span></span><br><span class=\"line\">GetRange name 0 2</span><br><span class=\"line\">SetRange name 0 hello</span><br></pre></td></tr></table></figure></li>\n<li>数值增减，只能是数字才能进行加减<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 递增数字</span></span><br><span class=\"line\">Incr key</span><br><span class=\"line\"><span class=\"comment\"># 增加指定的整数</span></span><br><span class=\"line\">IncrBy key increment</span><br><span class=\"line\"><span class=\"comment\"># 递减数字</span></span><br><span class=\"line\">Decr key</span><br><span class=\"line\"><span class=\"comment\"># 减少指定的整数</span></span><br><span class=\"line\">DecrBy key decrement</span><br></pre></td></tr></table></figure></li>\n<li>获取字符串长度和内容增加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrLen key</span><br><span class=\"line\">Append key value</span><br></pre></td></tr></table></figure></li>\n<li>getset(先get再set)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GetSet key value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-列表（List）\"><a href=\"#Redis-列表（List）\" class=\"headerlink\" title=\"Redis 列表（List）\"></a>Redis 列表（List）</h3><p>List 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p>\n<ol>\n<li>为列表添加值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPush/RPush key value [value...]</span><br></pre></td></tr></table></figure></li>\n<li>查看列表指定区间元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#0到-1代表查看所有元素</span></span><br><span class=\"line\">LRange key start top</span><br></pre></td></tr></table></figure></li>\n<li>移出并获取列表的第一个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPop/RPop key </span><br></pre></td></tr></table></figure></li>\n<li>按照索引下标获取元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIndex key index </span><br></pre></td></tr></table></figure></li>\n<li>获取列表中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LLen key</span><br></pre></td></tr></table></figure></li>\n<li>删除N个数值等于xx的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># N为0代表指定值全部删除</span></span><br><span class=\"line\">LRem key N xx</span><br></pre></td></tr></table></figure></li>\n<li>截取指定Key范围内的值再指定给key<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LTrim key start stop</span><br></pre></td></tr></table></figure></li>\n<li>移除列表的最后一个元素并将该元素添加到另一个列表并返回<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPopLPush 源列表 目标列表</span><br></pre></td></tr></table></figure></li>\n<li>通过索引设置列表元素中的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSet key index value</span><br></pre></td></tr></table></figure></li>\n<li>向列表中插入新值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LInsert key Before/After 已有值 新值</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-哈希（Hash）\"><a href=\"#Redis-哈希（Hash）\" class=\"headerlink\" title=\"Redis 哈希（Hash）\"></a>Redis 哈希（Hash）</h3><p>KV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>\n<ol>\n<li>基本操作<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]</span><br></pre></td></tr></table></figure></li>\n<li>获取某个key中的键值对数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HLen key</span><br></pre></td></tr></table></figure></li>\n<li>查看hash指定字段是否存在<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HExists key field</span><br></pre></td></tr></table></figure></li>\n<li>查看hash中所有field或者value<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HKeys/HVals key</span><br></pre></td></tr></table></figure></li>\n<li>为hash表中的指定字段整加&#x2F;浮点加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HIncrBy/HIncrByFloat key field value</span><br></pre></td></tr></table></figure></li>\n<li>不存在就赋值，存在就无效<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSetNX key field value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-集合（Set）\"><a href=\"#Redis-集合（Set）\" class=\"headerlink\" title=\"Redis 集合（Set）\"></a>Redis 集合（Set）</h3><p>单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>\n<ol>\n<li>向集合中添加一个&#x2F;多个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAdd key member [member...]</span><br></pre></td></tr></table></figure></li>\n<li>遍历集合key中的所有元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMembers key </span><br></pre></td></tr></table></figure></li>\n<li>判断元素是否存在于集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SISMember key value </span><br></pre></td></tr></table></figure></li>\n<li>移除集合中的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRem key value </span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCard key</span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机展现N个元素，元素不删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRandMember key N </span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机弹出N个元素，元素删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SPop key N </span><br></pre></td></tr></table></figure></li>\n<li>将集合中A中的某个值移入B集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMove A B Avalue </span><br></pre></td></tr></table></figure></li>\n<li>集合运算<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素</span></span><br><span class=\"line\">SDiff key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的并集运算</span></span><br><span class=\"line\">SUnion key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合</span></span><br><span class=\"line\">SInter key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给定集合的交集产生的集合的基数，N代表key的个数</span></span><br><span class=\"line\">SInterCard N key [key...]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-有序集合（ZSet）\"><a href=\"#Redis-有序集合（ZSet）\" class=\"headerlink\" title=\"Redis 有序集合（ZSet）\"></a>Redis 有序集合（ZSet）</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>\n<ol>\n<li>添加元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZAdd key score member [score member...]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从小到大，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员，倒序排列<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从大到小，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRevRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>指定分数范围内的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRangeByScore key min max [withScores] [<span class=\"built_in\">limit</span> offset count]</span><br></pre></td></tr></table></figure></li>\n<li>获取元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZScore key member</span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCard key</span><br></pre></td></tr></table></figure></li>\n<li>移除元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRem key member</span><br></pre></td></tr></table></figure></li>\n<li>增加某个元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZIncrBy key increment member</span><br></pre></td></tr></table></figure></li>\n<li>获取指定分数范围内的元素个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCount key min max</span><br></pre></td></tr></table></figure></li>\n<li><strong>从键名列表中的第一个</strong>非空排序集中弹出一个或者多个元素，它们是成员分数对<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从多个有序集合中弹出2个元素</span></span><br><span class=\"line\">ZMPop numKeys key [key...] min/max count 2</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRank key values member</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的逆序元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRevRank key values member</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"四、基础数据类型的基本使用场景\"><a href=\"#四、基础数据类型的基本使用场景\" class=\"headerlink\" title=\"四、基础数据类型的基本使用场景\"></a>四、基础数据类型的基本使用场景</h2><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>经典使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>抖音视频&#x2F;商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id）</td>\n</tr>\n<tr>\n<td>List</td>\n<td>微信公众号消息订阅；</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>简单的购物车；</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人</td>\n</tr>\n<tr>\n<td>ZSet</td>\n<td>根据商品销售对商品进行排名</td>\n</tr>\n</tbody></table>\n"},{"title":"go/limit","_content":"","source":"_drafts/go-limit.md","raw":"---\ntitle: go/limit\ntags:\n---\n","slug":"go-limit","published":0,"date":"2023-05-27T08:37:53.259Z","updated":"2023-05-27T08:37:53.259Z","_id":"cli2hqudu000034up3axq29bg","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"前端开发者应该掌握的docker知识","date":"2023-03-03T09:01:39.000Z","excerpt":"身为前端开发者的我们应该怎样理解、掌握docker？","_content":"身为前端开发者的我们应该怎样理解、掌握docker？\n### docker的基本组成\nDocker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。![平台架构图-基础版](/images/docker/composition.png)\n#### 镜像（image）\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。\n它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”\n#### 容器（container）\nDocker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.\n#### 仓库（respository）\n仓库（Repository）是集中存放镜像文件的场所。\n\n### 下载\n1.[官网地址](https://www.docker.com/)\n2.[仓库地址](https://hub.docker.com/)\n\n### 基本命令\n1. 启动docker\n```bash\nsystemctl start docker\n```\n2. 停止docker\n```bash\nsystemctl stop docker\n```\n3. 重启docker\n```bash\nsystemctl restart docker\n```\n4. 查看docker状态\n```bash\nsystemctl status docker\n```\n5. 开机启动\n```bash\nsystemctl enable docker\n```\n6. 查看docker概要信息\n```bash\ndocker info\n```\n7. 帮助命令\n```bash\n# 查看总体帮助\ndocker help\n# 查看具体命令帮助\ndocker 命令 --help\n```\n### 镜像常用命令\n1. 查看本地镜像\n```bash\ndocker images [options]\n\noptions:\n-a 列出本地所有镜像\n-q 只显示镜像ID\n```\n2. 查找镜像\n```bash\ndocker search [options] 镜像名称\n\noptions:\n--limit N 列出n个\n```\n3. 拉取镜像\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker pull 镜像名称[:tag] \n```\n4. 查看镜像/容器/数据卷所占的空间\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker system df\n```\n5. 镜像删除\n```bash\n# 删除某个镜像\ndocker rmi -f 镜像ID\n\n# 删除多个镜像\ndocker rmi -f 镜像名1:tag 镜像名2:tag\n\n# 删除全部\ndocker rmi -f ${docker images -qa}\n```\n6. 提交容器副本使之成为新的镜像\n```bash\ndocker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]\n```\n7. 将指定镜像保存成 tar 归档文件\n```bash\ndocker save [OPTIONS] IMAGE [IMAGE...]\n\nOPTIONS：\n-o :输出到的文件\n```\n8. 导入使用 docker save 命令导出的镜像\n```bash\ndocker load [OPTIONS]\n举例 docker load < 镜像文件名\n\nOPTIONS：\n--input , -i : 指定导入的文件，代替 STDIN\n--quiet , -q : 精简输出信息\n```\n### 容器常用命令\n1. 新建/启动容器\n```bash\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...] \n\nOPTIONS:有些是一个减号有些是两个减号\n--name=\"容器新名字\" 为容器指定一个名称\n-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)\n-i：以交互模式运行容器，通常与 -t 同时使用\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)\n-P: 随机端口映射，大写P\n-p: 指定端口映射，小写p\n```\n![container-options](/images/docker/container-options.png)\n2. 列出当前正在运行的容器\n```bash\ndocker ps [OPTIONS]\n\nOPTIONS:\n-a :列出当前所有正在运行的容器+历史上运行过的\n-l :显示最近创建的容器\n-n :显示最近n个创建的容器\n-q :静默模式，只显示容器编号\n```\n3. 退出容器\n```bash\nexit run进入exit退出 容器停止\nctrl+p+q run进入ctrl+p+q退出 容器不停止\n```\n4. 启动已停止运行的容器\n```bash\ndocker start 容器ID/容器name\n```\n5. 重启容器\n```bash\ndocker restart 容器ID/容器name\n```\n6. 停止容器\n```bash\ndocker stop 容器ID/容器name\n```\n7. 强制停止容器\n```bash\ndocker kill 容器ID/容器name\n```\n8. 删除已停止的容器\n```bash\ndocker rm 容器ID/容器name\n```\n9. 启动守护式容器（后台服务器）\n```bash\ndocker run -it -d 容器ID\n```\n10. 查看容器日志\n```bash\ndocker logs 容器ID\n#跟踪查看最近100条日志\ndocker logs -f -n100\n```\n11. 查看容器内运行的进程\n```bash\ndocker top 容器ID\n```\n12. 查看容器内部细节\n```bash\ndocker inspect 容器ID\n```\n13. 进入正在运行的容器并以命令行交互\n```bash\ndocker exec -it 容器ID /bin/bash\n```\n14. 从容器内拷贝文件到主机上\n```bash\ndocker cp 容器id:容器内路径 宿主机路径\n```\n\n15. 常用命令总结\n![container-command](/images/docker/container-command.png)\n```bash\nattach    # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     # 通过 Dockerfile 定制镜像\n\ncommit    # 提交当前容器为新的镜像\n\ncp        #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    # 创建一个新的容器，同 run，但不启动容器\n\ndiff      # 查看 docker 容器变化\n\nevents    # 从 docker 服务获取容器实时事件\n\nexec      # 在已存在的容器上运行命令\n\nexport    # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   # 展示一个镜像形成历史\n\nimages    # 列出系统当前镜像\n\nimport    # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      # 显示系统相关信息\n\ninspect   # 查看容器详细信息\n\nkill      # kill 指定 docker 容器\n\nload      # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     # 注册或者登陆一个 docker 源服务器\n\nlogout    # 从当前 Docker registry 退出\n\nlogs      # 输出当前容器日志信息 docker logs -f -n=100 container-id\n\nport      # 查看映射端口对应的容器内部源端口\n\npause     # 暂停容器\n\nps        # 列出容器列表\n\npull      # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   # 重启运行的容器\n\nrm        # 移除一个或者多个容器\n\nrmi       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       # 创建一个新的容器并运行一个命令\n\nsave      # 保存一个镜像为一个 tar 包[对应 load]\n\nsearch    # 在 docker hub 中搜索镜像\n\nstart     # 启动容器\n\nstop      # 停止容器\n\ntag       # 给源中镜像打标签\n\ntop       # 查看容器中运行的进程信息\n\nunpause   # 取消暂停容器\n\nversion   # 查看 docker 版本号\n\nwait      # 截取容器停止时的退出状态值\n```\n\n### 容器数据卷\n将docker容器中的数据保存到宿主机的磁盘中\n```bash\n# 一定要带上--privileged=true不然没有权限\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名\n```\n\n### DockerFile\nDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n#### DockerFile基础说明\n- 每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n- 指令按照顺序，从上到下顺序执行\n- #表示注释\n- 每条指令都会创建一个新的镜像层并对镜像进行提交\n\n#### docker执行DockerFile流程\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器进行修改\n3. 执行类似docker commit的操作提交一个新的镜像层\n4. docker再基于刚提交的镜像运行一个新容器\n5. 执行docker中的下一条指令直至所有指令完成\n\n#### 常用保留字指令\n1. FROM： 基础镜像\n2. MAINTAINER： 镜像维护者姓名和邮箱\n3. RUN： docker build时需要运行的命令\n4. EXPOSE：当前容器对外暴露的端口\n5. WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\n6. USER：指定容器以什么样的用户去执行，默认root\n7. ENV：用来在构建镜像过程中设置环境变量\n8. ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包\n9. COPY：类似ADD拷贝文件和目录到镜像中\n10. VOLUME：容器数据卷用于保存数据和数据持久化\n11. CMD：指定容器启动后要干的事情\n12. ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序\n![](/images/docker/dockerfile.png)","source":"_posts/docker/docker.md","raw":"---\ntitle: 前端开发者应该掌握的docker知识\ndate: 2023-03-03 17:01:39\ntags: ['web','docker']\nexcerpt: 身为前端开发者的我们应该怎样理解、掌握docker？\n---\n身为前端开发者的我们应该怎样理解、掌握docker？\n### docker的基本组成\nDocker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。![平台架构图-基础版](/images/docker/composition.png)\n#### 镜像（image）\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。\n它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”\n#### 容器（container）\nDocker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.\n#### 仓库（respository）\n仓库（Repository）是集中存放镜像文件的场所。\n\n### 下载\n1.[官网地址](https://www.docker.com/)\n2.[仓库地址](https://hub.docker.com/)\n\n### 基本命令\n1. 启动docker\n```bash\nsystemctl start docker\n```\n2. 停止docker\n```bash\nsystemctl stop docker\n```\n3. 重启docker\n```bash\nsystemctl restart docker\n```\n4. 查看docker状态\n```bash\nsystemctl status docker\n```\n5. 开机启动\n```bash\nsystemctl enable docker\n```\n6. 查看docker概要信息\n```bash\ndocker info\n```\n7. 帮助命令\n```bash\n# 查看总体帮助\ndocker help\n# 查看具体命令帮助\ndocker 命令 --help\n```\n### 镜像常用命令\n1. 查看本地镜像\n```bash\ndocker images [options]\n\noptions:\n-a 列出本地所有镜像\n-q 只显示镜像ID\n```\n2. 查找镜像\n```bash\ndocker search [options] 镜像名称\n\noptions:\n--limit N 列出n个\n```\n3. 拉取镜像\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker pull 镜像名称[:tag] \n```\n4. 查看镜像/容器/数据卷所占的空间\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker system df\n```\n5. 镜像删除\n```bash\n# 删除某个镜像\ndocker rmi -f 镜像ID\n\n# 删除多个镜像\ndocker rmi -f 镜像名1:tag 镜像名2:tag\n\n# 删除全部\ndocker rmi -f ${docker images -qa}\n```\n6. 提交容器副本使之成为新的镜像\n```bash\ndocker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]\n```\n7. 将指定镜像保存成 tar 归档文件\n```bash\ndocker save [OPTIONS] IMAGE [IMAGE...]\n\nOPTIONS：\n-o :输出到的文件\n```\n8. 导入使用 docker save 命令导出的镜像\n```bash\ndocker load [OPTIONS]\n举例 docker load < 镜像文件名\n\nOPTIONS：\n--input , -i : 指定导入的文件，代替 STDIN\n--quiet , -q : 精简输出信息\n```\n### 容器常用命令\n1. 新建/启动容器\n```bash\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...] \n\nOPTIONS:有些是一个减号有些是两个减号\n--name=\"容器新名字\" 为容器指定一个名称\n-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)\n-i：以交互模式运行容器，通常与 -t 同时使用\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)\n-P: 随机端口映射，大写P\n-p: 指定端口映射，小写p\n```\n![container-options](/images/docker/container-options.png)\n2. 列出当前正在运行的容器\n```bash\ndocker ps [OPTIONS]\n\nOPTIONS:\n-a :列出当前所有正在运行的容器+历史上运行过的\n-l :显示最近创建的容器\n-n :显示最近n个创建的容器\n-q :静默模式，只显示容器编号\n```\n3. 退出容器\n```bash\nexit run进入exit退出 容器停止\nctrl+p+q run进入ctrl+p+q退出 容器不停止\n```\n4. 启动已停止运行的容器\n```bash\ndocker start 容器ID/容器name\n```\n5. 重启容器\n```bash\ndocker restart 容器ID/容器name\n```\n6. 停止容器\n```bash\ndocker stop 容器ID/容器name\n```\n7. 强制停止容器\n```bash\ndocker kill 容器ID/容器name\n```\n8. 删除已停止的容器\n```bash\ndocker rm 容器ID/容器name\n```\n9. 启动守护式容器（后台服务器）\n```bash\ndocker run -it -d 容器ID\n```\n10. 查看容器日志\n```bash\ndocker logs 容器ID\n#跟踪查看最近100条日志\ndocker logs -f -n100\n```\n11. 查看容器内运行的进程\n```bash\ndocker top 容器ID\n```\n12. 查看容器内部细节\n```bash\ndocker inspect 容器ID\n```\n13. 进入正在运行的容器并以命令行交互\n```bash\ndocker exec -it 容器ID /bin/bash\n```\n14. 从容器内拷贝文件到主机上\n```bash\ndocker cp 容器id:容器内路径 宿主机路径\n```\n\n15. 常用命令总结\n![container-command](/images/docker/container-command.png)\n```bash\nattach    # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     # 通过 Dockerfile 定制镜像\n\ncommit    # 提交当前容器为新的镜像\n\ncp        #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    # 创建一个新的容器，同 run，但不启动容器\n\ndiff      # 查看 docker 容器变化\n\nevents    # 从 docker 服务获取容器实时事件\n\nexec      # 在已存在的容器上运行命令\n\nexport    # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   # 展示一个镜像形成历史\n\nimages    # 列出系统当前镜像\n\nimport    # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      # 显示系统相关信息\n\ninspect   # 查看容器详细信息\n\nkill      # kill 指定 docker 容器\n\nload      # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     # 注册或者登陆一个 docker 源服务器\n\nlogout    # 从当前 Docker registry 退出\n\nlogs      # 输出当前容器日志信息 docker logs -f -n=100 container-id\n\nport      # 查看映射端口对应的容器内部源端口\n\npause     # 暂停容器\n\nps        # 列出容器列表\n\npull      # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   # 重启运行的容器\n\nrm        # 移除一个或者多个容器\n\nrmi       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       # 创建一个新的容器并运行一个命令\n\nsave      # 保存一个镜像为一个 tar 包[对应 load]\n\nsearch    # 在 docker hub 中搜索镜像\n\nstart     # 启动容器\n\nstop      # 停止容器\n\ntag       # 给源中镜像打标签\n\ntop       # 查看容器中运行的进程信息\n\nunpause   # 取消暂停容器\n\nversion   # 查看 docker 版本号\n\nwait      # 截取容器停止时的退出状态值\n```\n\n### 容器数据卷\n将docker容器中的数据保存到宿主机的磁盘中\n```bash\n# 一定要带上--privileged=true不然没有权限\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名\n```\n\n### DockerFile\nDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n#### DockerFile基础说明\n- 每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n- 指令按照顺序，从上到下顺序执行\n- #表示注释\n- 每条指令都会创建一个新的镜像层并对镜像进行提交\n\n#### docker执行DockerFile流程\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器进行修改\n3. 执行类似docker commit的操作提交一个新的镜像层\n4. docker再基于刚提交的镜像运行一个新容器\n5. 执行docker中的下一条指令直至所有指令完成\n\n#### 常用保留字指令\n1. FROM： 基础镜像\n2. MAINTAINER： 镜像维护者姓名和邮箱\n3. RUN： docker build时需要运行的命令\n4. EXPOSE：当前容器对外暴露的端口\n5. WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\n6. USER：指定容器以什么样的用户去执行，默认root\n7. ENV：用来在构建镜像过程中设置环境变量\n8. ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包\n9. COPY：类似ADD拷贝文件和目录到镜像中\n10. VOLUME：容器数据卷用于保存数据和数据持久化\n11. CMD：指定容器启动后要干的事情\n12. ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序\n![](/images/docker/dockerfile.png)","slug":"docker/docker","published":1,"updated":"2023-05-27T08:37:53.260Z","_id":"cli2hque1000234up3mc2blmq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>身为前端开发者的我们应该怎样理解、掌握docker？</p>\n<h3 id=\"docker的基本组成\"><a href=\"#docker的基本组成\" class=\"headerlink\" title=\"docker的基本组成\"></a>docker的基本组成</h3><p>Docker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。<img src=\"/blog/images/docker/composition.png\" alt=\"平台架构图-基础版\"></p>\n<h4 id=\"镜像（image）\"><a href=\"#镜像（image）\" class=\"headerlink\" title=\"镜像（image）\"></a>镜像（image）</h4><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。<br>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”</p>\n<h4 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h4><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.</p>\n<h4 id=\"仓库（respository）\"><a href=\"#仓库（respository）\" class=\"headerlink\" title=\"仓库（respository）\"></a>仓库（respository）</h4><p>仓库（Repository）是集中存放镜像文件的场所。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>1.<a href=\"https://www.docker.com/\">官网地址</a><br>2.<a href=\"https://hub.docker.com/\">仓库地址</a></p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ol>\n<li>启动docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure></li>\n<li>停止docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop docker</span><br></pre></td></tr></table></figure></li>\n<li>重启docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker状态<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker</span><br></pre></td></tr></table></figure></li>\n<li>开机启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker概要信息<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure></li>\n<li>帮助命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看总体帮助</span></span><br><span class=\"line\">docker <span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\"># 查看具体命令帮助</span></span><br><span class=\"line\">docker 命令 --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"镜像常用命令\"><a href=\"#镜像常用命令\" class=\"headerlink\" title=\"镜像常用命令\"></a>镜像常用命令</h3><ol>\n<li>查看本地镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images [options]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-a 列出本地所有镜像</span><br><span class=\"line\">-q 只显示镜像ID</span><br></pre></td></tr></table></figure></li>\n<li>查找镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search [options] 镜像名称</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">--<span class=\"built_in\">limit</span> N 列出n个</span><br></pre></td></tr></table></figure></li>\n<li>拉取镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker pull 镜像名称[:tag] </span><br></pre></td></tr></table></figure></li>\n<li>查看镜像&#x2F;容器&#x2F;数据卷所占的空间<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker system <span class=\"built_in\">df</span></span><br></pre></td></tr></table></figure></li>\n<li>镜像删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除某个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像ID</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除多个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像名1:tag 镜像名2:tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除全部</span></span><br><span class=\"line\">docker rmi -f <span class=\"variable\">$&#123;docker images -qa&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>提交容器副本使之成为新的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure></li>\n<li>将指定镜像保存成 tar 归档文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">-o :输出到的文件</span><br></pre></td></tr></table></figure></li>\n<li>导入使用 docker save 命令导出的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load [OPTIONS]</span><br><span class=\"line\">举例 docker load &lt; 镜像文件名</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">--input , -i : 指定导入的文件，代替 STDIN</span><br><span class=\"line\">--quiet , -q : 精简输出信息</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器常用命令\"><a href=\"#容器常用命令\" class=\"headerlink\" title=\"容器常用命令\"></a>容器常用命令</h3><ol>\n<li><p>新建&#x2F;启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...] </span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:有些是一个减号有些是两个减号</span><br><span class=\"line\">--name=<span class=\"string\">&quot;容器新名字&quot;</span> 为容器指定一个名称</span><br><span class=\"line\">-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)</span><br><span class=\"line\">-i：以交互模式运行容器，通常与 -t 同时使用</span><br><span class=\"line\">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)</span><br><span class=\"line\">-P: 随机端口映射，大写P</span><br><span class=\"line\">-p: 指定端口映射，小写p</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/docker/container-options.png\" alt=\"container-options\"></p>\n</li>\n<li><p>列出当前正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:</span><br><span class=\"line\">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class=\"line\">-l :显示最近创建的容器</span><br><span class=\"line\">-n :显示最近n个创建的容器</span><br><span class=\"line\">-q :静默模式，只显示容器编号</span><br></pre></td></tr></table></figure></li>\n<li><p>退出容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exit</span> run进入<span class=\"built_in\">exit</span>退出 容器停止</span><br><span class=\"line\">ctrl+p+q run进入ctrl+p+q退出 容器不停止</span><br></pre></td></tr></table></figure></li>\n<li><p>启动已停止运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>重启容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>强制停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">kill</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>删除已停止的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>启动守护式容器（后台服务器）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -d 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker logs 容器ID</span><br><span class=\"line\"><span class=\"comment\">#跟踪查看最近100条日志</span></span><br><span class=\"line\">docker logs -f -n100</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内运行的进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker top 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内部细节</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>进入正在运行的容器并以命令行交互</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure></li>\n<li><p>从容器内拷贝文件到主机上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">cp</span> 容器<span class=\"built_in\">id</span>:容器内路径 宿主机路径</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用命令总结<br><img src=\"/blog/images/docker/container-command.png\" alt=\"container-command\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attach    <span class=\"comment\"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">build     <span class=\"comment\"># 通过 Dockerfile 定制镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit    <span class=\"comment\"># 提交当前容器为新的镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span>        <span class=\"comment\">#从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class=\"line\"></span><br><span class=\"line\">create    <span class=\"comment\"># 创建一个新的容器，同 run，但不启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">diff      <span class=\"comment\"># 查看 docker 容器变化</span></span><br><span class=\"line\"></span><br><span class=\"line\">events    <span class=\"comment\"># 从 docker 服务获取容器实时事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exec</span>      <span class=\"comment\"># 在已存在的容器上运行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span>    <span class=\"comment\"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">history</span>   <span class=\"comment\"># 展示一个镜像形成历史</span></span><br><span class=\"line\"></span><br><span class=\"line\">images    <span class=\"comment\"># 列出系统当前镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">import    <span class=\"comment\"># 从tar包中的内容创建一个新的文件系统映像[对应export]</span></span><br><span class=\"line\"></span><br><span class=\"line\">info      <span class=\"comment\"># 显示系统相关信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">inspect   <span class=\"comment\"># 查看容器详细信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span>      <span class=\"comment\"># kill 指定 docker 容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">load      <span class=\"comment\"># 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class=\"line\"></span><br><span class=\"line\">login     <span class=\"comment\"># 注册或者登陆一个 docker 源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">logout</span>    <span class=\"comment\"># 从当前 Docker registry 退出</span></span><br><span class=\"line\"></span><br><span class=\"line\">logs      <span class=\"comment\"># 输出当前容器日志信息 docker logs -f -n=100 container-id</span></span><br><span class=\"line\"></span><br><span class=\"line\">port      <span class=\"comment\"># 查看映射端口对应的容器内部源端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">pause     <span class=\"comment\"># 暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">ps        <span class=\"comment\"># 列出容器列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">pull      <span class=\"comment\"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">push      <span class=\"comment\"># 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\">restart   <span class=\"comment\"># 重启运行的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rm</span>        <span class=\"comment\"># 移除一个或者多个容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">rmi       <span class=\"comment\"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class=\"line\"></span><br><span class=\"line\">run       <span class=\"comment\"># 创建一个新的容器并运行一个命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">save      <span class=\"comment\"># 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class=\"line\"></span><br><span class=\"line\">search    <span class=\"comment\"># 在 docker hub 中搜索镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">start     <span class=\"comment\"># 启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">stop      <span class=\"comment\"># 停止容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">tag       <span class=\"comment\"># 给源中镜像打标签</span></span><br><span class=\"line\"></span><br><span class=\"line\">top       <span class=\"comment\"># 查看容器中运行的进程信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">unpause   <span class=\"comment\"># 取消暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">version   <span class=\"comment\"># 查看 docker 版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">wait</span>      <span class=\"comment\"># 截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h3><p>将docker容器中的数据保存到宿主机的磁盘中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一定要带上--privileged=true不然没有权限</span></span><br><span class=\"line\">docker run -it --privileged=<span class=\"literal\">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h3><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<h4 id=\"DockerFile基础说明\"><a href=\"#DockerFile基础说明\" class=\"headerlink\" title=\"DockerFile基础说明\"></a>DockerFile基础说明</h4><ul>\n<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>\n<li>指令按照顺序，从上到下顺序执行</li>\n<li>#表示注释</li>\n<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>\n</ul>\n<h4 id=\"docker执行DockerFile流程\"><a href=\"#docker执行DockerFile流程\" class=\"headerlink\" title=\"docker执行DockerFile流程\"></a>docker执行DockerFile流程</h4><ol>\n<li>docker从基础镜像运行一个容器</li>\n<li>执行一条指令并对容器进行修改</li>\n<li>执行类似docker commit的操作提交一个新的镜像层</li>\n<li>docker再基于刚提交的镜像运行一个新容器</li>\n<li>执行docker中的下一条指令直至所有指令完成</li>\n</ol>\n<h4 id=\"常用保留字指令\"><a href=\"#常用保留字指令\" class=\"headerlink\" title=\"常用保留字指令\"></a>常用保留字指令</h4><ol>\n<li>FROM： 基础镜像</li>\n<li>MAINTAINER： 镜像维护者姓名和邮箱</li>\n<li>RUN： docker build时需要运行的命令</li>\n<li>EXPOSE：当前容器对外暴露的端口</li>\n<li>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</li>\n<li>USER：指定容器以什么样的用户去执行，默认root</li>\n<li>ENV：用来在构建镜像过程中设置环境变量</li>\n<li>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li>\n<li>COPY：类似ADD拷贝文件和目录到镜像中</li>\n<li>VOLUME：容器数据卷用于保存数据和数据持久化</li>\n<li>CMD：指定容器启动后要干的事情</li>\n<li>ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序<br><img src=\"/blog/images/docker/dockerfile.png\"></li>\n</ol>\n","site":{"data":{}},"more":"<p>身为前端开发者的我们应该怎样理解、掌握docker？</p>\n<h3 id=\"docker的基本组成\"><a href=\"#docker的基本组成\" class=\"headerlink\" title=\"docker的基本组成\"></a>docker的基本组成</h3><p>Docker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。<img src=\"/blog/images/docker/composition.png\" alt=\"平台架构图-基础版\"></p>\n<h4 id=\"镜像（image）\"><a href=\"#镜像（image）\" class=\"headerlink\" title=\"镜像（image）\"></a>镜像（image）</h4><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。<br>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”</p>\n<h4 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h4><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.</p>\n<h4 id=\"仓库（respository）\"><a href=\"#仓库（respository）\" class=\"headerlink\" title=\"仓库（respository）\"></a>仓库（respository）</h4><p>仓库（Repository）是集中存放镜像文件的场所。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>1.<a href=\"https://www.docker.com/\">官网地址</a><br>2.<a href=\"https://hub.docker.com/\">仓库地址</a></p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ol>\n<li>启动docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure></li>\n<li>停止docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop docker</span><br></pre></td></tr></table></figure></li>\n<li>重启docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker状态<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker</span><br></pre></td></tr></table></figure></li>\n<li>开机启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker概要信息<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure></li>\n<li>帮助命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看总体帮助</span></span><br><span class=\"line\">docker <span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\"># 查看具体命令帮助</span></span><br><span class=\"line\">docker 命令 --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"镜像常用命令\"><a href=\"#镜像常用命令\" class=\"headerlink\" title=\"镜像常用命令\"></a>镜像常用命令</h3><ol>\n<li>查看本地镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images [options]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-a 列出本地所有镜像</span><br><span class=\"line\">-q 只显示镜像ID</span><br></pre></td></tr></table></figure></li>\n<li>查找镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search [options] 镜像名称</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">--<span class=\"built_in\">limit</span> N 列出n个</span><br></pre></td></tr></table></figure></li>\n<li>拉取镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker pull 镜像名称[:tag] </span><br></pre></td></tr></table></figure></li>\n<li>查看镜像&#x2F;容器&#x2F;数据卷所占的空间<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker system <span class=\"built_in\">df</span></span><br></pre></td></tr></table></figure></li>\n<li>镜像删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除某个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像ID</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除多个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像名1:tag 镜像名2:tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除全部</span></span><br><span class=\"line\">docker rmi -f <span class=\"variable\">$&#123;docker images -qa&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>提交容器副本使之成为新的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure></li>\n<li>将指定镜像保存成 tar 归档文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">-o :输出到的文件</span><br></pre></td></tr></table></figure></li>\n<li>导入使用 docker save 命令导出的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load [OPTIONS]</span><br><span class=\"line\">举例 docker load &lt; 镜像文件名</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">--input , -i : 指定导入的文件，代替 STDIN</span><br><span class=\"line\">--quiet , -q : 精简输出信息</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器常用命令\"><a href=\"#容器常用命令\" class=\"headerlink\" title=\"容器常用命令\"></a>容器常用命令</h3><ol>\n<li><p>新建&#x2F;启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...] </span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:有些是一个减号有些是两个减号</span><br><span class=\"line\">--name=<span class=\"string\">&quot;容器新名字&quot;</span> 为容器指定一个名称</span><br><span class=\"line\">-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)</span><br><span class=\"line\">-i：以交互模式运行容器，通常与 -t 同时使用</span><br><span class=\"line\">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)</span><br><span class=\"line\">-P: 随机端口映射，大写P</span><br><span class=\"line\">-p: 指定端口映射，小写p</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/docker/container-options.png\" alt=\"container-options\"></p>\n</li>\n<li><p>列出当前正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:</span><br><span class=\"line\">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class=\"line\">-l :显示最近创建的容器</span><br><span class=\"line\">-n :显示最近n个创建的容器</span><br><span class=\"line\">-q :静默模式，只显示容器编号</span><br></pre></td></tr></table></figure></li>\n<li><p>退出容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exit</span> run进入<span class=\"built_in\">exit</span>退出 容器停止</span><br><span class=\"line\">ctrl+p+q run进入ctrl+p+q退出 容器不停止</span><br></pre></td></tr></table></figure></li>\n<li><p>启动已停止运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>重启容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>强制停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">kill</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>删除已停止的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>启动守护式容器（后台服务器）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -d 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker logs 容器ID</span><br><span class=\"line\"><span class=\"comment\">#跟踪查看最近100条日志</span></span><br><span class=\"line\">docker logs -f -n100</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内运行的进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker top 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内部细节</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>进入正在运行的容器并以命令行交互</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure></li>\n<li><p>从容器内拷贝文件到主机上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">cp</span> 容器<span class=\"built_in\">id</span>:容器内路径 宿主机路径</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用命令总结<br><img src=\"/blog/images/docker/container-command.png\" alt=\"container-command\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attach    <span class=\"comment\"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">build     <span class=\"comment\"># 通过 Dockerfile 定制镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit    <span class=\"comment\"># 提交当前容器为新的镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span>        <span class=\"comment\">#从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class=\"line\"></span><br><span class=\"line\">create    <span class=\"comment\"># 创建一个新的容器，同 run，但不启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">diff      <span class=\"comment\"># 查看 docker 容器变化</span></span><br><span class=\"line\"></span><br><span class=\"line\">events    <span class=\"comment\"># 从 docker 服务获取容器实时事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exec</span>      <span class=\"comment\"># 在已存在的容器上运行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span>    <span class=\"comment\"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">history</span>   <span class=\"comment\"># 展示一个镜像形成历史</span></span><br><span class=\"line\"></span><br><span class=\"line\">images    <span class=\"comment\"># 列出系统当前镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">import    <span class=\"comment\"># 从tar包中的内容创建一个新的文件系统映像[对应export]</span></span><br><span class=\"line\"></span><br><span class=\"line\">info      <span class=\"comment\"># 显示系统相关信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">inspect   <span class=\"comment\"># 查看容器详细信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span>      <span class=\"comment\"># kill 指定 docker 容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">load      <span class=\"comment\"># 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class=\"line\"></span><br><span class=\"line\">login     <span class=\"comment\"># 注册或者登陆一个 docker 源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">logout</span>    <span class=\"comment\"># 从当前 Docker registry 退出</span></span><br><span class=\"line\"></span><br><span class=\"line\">logs      <span class=\"comment\"># 输出当前容器日志信息 docker logs -f -n=100 container-id</span></span><br><span class=\"line\"></span><br><span class=\"line\">port      <span class=\"comment\"># 查看映射端口对应的容器内部源端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">pause     <span class=\"comment\"># 暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">ps        <span class=\"comment\"># 列出容器列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">pull      <span class=\"comment\"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">push      <span class=\"comment\"># 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\">restart   <span class=\"comment\"># 重启运行的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rm</span>        <span class=\"comment\"># 移除一个或者多个容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">rmi       <span class=\"comment\"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class=\"line\"></span><br><span class=\"line\">run       <span class=\"comment\"># 创建一个新的容器并运行一个命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">save      <span class=\"comment\"># 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class=\"line\"></span><br><span class=\"line\">search    <span class=\"comment\"># 在 docker hub 中搜索镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">start     <span class=\"comment\"># 启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">stop      <span class=\"comment\"># 停止容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">tag       <span class=\"comment\"># 给源中镜像打标签</span></span><br><span class=\"line\"></span><br><span class=\"line\">top       <span class=\"comment\"># 查看容器中运行的进程信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">unpause   <span class=\"comment\"># 取消暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">version   <span class=\"comment\"># 查看 docker 版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">wait</span>      <span class=\"comment\"># 截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h3><p>将docker容器中的数据保存到宿主机的磁盘中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一定要带上--privileged=true不然没有权限</span></span><br><span class=\"line\">docker run -it --privileged=<span class=\"literal\">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h3><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<h4 id=\"DockerFile基础说明\"><a href=\"#DockerFile基础说明\" class=\"headerlink\" title=\"DockerFile基础说明\"></a>DockerFile基础说明</h4><ul>\n<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>\n<li>指令按照顺序，从上到下顺序执行</li>\n<li>#表示注释</li>\n<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>\n</ul>\n<h4 id=\"docker执行DockerFile流程\"><a href=\"#docker执行DockerFile流程\" class=\"headerlink\" title=\"docker执行DockerFile流程\"></a>docker执行DockerFile流程</h4><ol>\n<li>docker从基础镜像运行一个容器</li>\n<li>执行一条指令并对容器进行修改</li>\n<li>执行类似docker commit的操作提交一个新的镜像层</li>\n<li>docker再基于刚提交的镜像运行一个新容器</li>\n<li>执行docker中的下一条指令直至所有指令完成</li>\n</ol>\n<h4 id=\"常用保留字指令\"><a href=\"#常用保留字指令\" class=\"headerlink\" title=\"常用保留字指令\"></a>常用保留字指令</h4><ol>\n<li>FROM： 基础镜像</li>\n<li>MAINTAINER： 镜像维护者姓名和邮箱</li>\n<li>RUN： docker build时需要运行的命令</li>\n<li>EXPOSE：当前容器对外暴露的端口</li>\n<li>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</li>\n<li>USER：指定容器以什么样的用户去执行，默认root</li>\n<li>ENV：用来在构建镜像过程中设置环境变量</li>\n<li>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li>\n<li>COPY：类似ADD拷贝文件和目录到镜像中</li>\n<li>VOLUME：容器数据卷用于保存数据和数据持久化</li>\n<li>CMD：指定容器启动后要干的事情</li>\n<li>ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序<br><img src=\"/blog/images/docker/dockerfile.png\"></li>\n</ol>\n"},{"title":"grpc","date":"2023-05-25T02:10:28.000Z","excerpt":"gRPC 是一种高性能、跨语言、跨平台的 RPC 框架，通过使用 Protobuf 进行接口定义和数据序列化，提供了简单易用的 API 和强大的功能，适用于构建分布式系统、微服务架构和高性能的客户端-服务器通信。","_content":"\n## Protobuf\n- Protocol Buffers（简称为 Protobuf）是一种语言无关、平台无关、可扩展的数据序列化格式，由 Google 开发并开源。它可以用于结构化数据的序列化和反序列化，用于数据存储、通信协议等领域。\n- Protobuf 使用 .proto 文件定义数据结构，然后使用特定的编译器将这些 .proto 文件编译成相应语言的源代码，从而在程序中使用生成的代码来进行数据的序列化和反序列化。它支持多种编程语言，包括但不限于 C++, Java, Python, Go, JavaScript 等。\n- Protobuf 的设计目标是高效、简单、可扩展。它采用二进制编码格式，相比于其他文本格式（如 JSON、XML），序列化后的数据更加紧凑，传输效率更高。同时，Protobuf 支持定义复杂的数据结构，包括嵌套类型、枚举类型、默认值等，使得数据的描述更加灵活和丰富。\n- 使用 Protobuf 的好处包括：\n1. 代码生成：根据 .proto 文件生成代码，简化数据的序列化和反序列化操作，提高开发效率。\n2. 紧凑的数据表示：相比文本格式，序列化后的数据更小，传输效率更高。\n3. 跨平台、跨语言支持：支持多种编程语言，使得不同平台和语言之间的数据交换更加方便。\n4. 可扩展性：支持版本升级和向后兼容，可以在不破坏现有数据的情况下进行结构的扩展和修改。\n\n总结来说，Protobuf 是一种高效、简单、可扩展的数据序列化格式，适用于多种领域，包括网络通信、数据存储、RPC（远程过程调用）等。它提供了强大的数据描述能力和跨平台、跨语言的支持，是一种优秀的数据交换格式。\n\n\n## 将`Protobuf`（.proto）转化为`go文件`（.go）\n### protobuf环境搭建\n\n1. **protoc**\n\nprotoc 是 Protocol Buffers（简称 Protobuf）的编译器命令行工具。[protoc下载地址](https://github.com/protocolbuffers/protobuf/releases)，下载解压完成之后将可执行文件加入系统的环境变量中。\n\n2. **安装protobuf库**\n```bash\ngo get github.com/golang/protobuf/proto@v1.5.3\n```\n\n3. **安装protoc-gen-go插件**\n```bash\n# go get 用于获取第三方包或模块并安装依赖项，go install 用于构建并安装指定包或模块的可执行文件或库。\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n\n4. 代码演示\n- 项目目录\n```bash\n# go-grpc\n├── protos                                  # protobuf\n│   ├── models.proto                        # 模型\n├── src\n│   ├── pbfiles                             # 存放protobuf转化为go的文件\n├── go.mod                                 \n├── proto.bat                               # 命令文件\n└── main.go                            \n```\n- 使用protobuf定义商品类型\n```golang\n# models.proto\nsyntax = \"proto3\";\n\noption go_package = \"go-grpc/src/pbfiles\";\n\nmessage ProdModel {\n    int32 id = 1; // 商品ID\n    string name = 2; // 商品名称\n}\n```\n- 执行protoc命令\n```bash\nprotoc --proto_path=protos --go_out=./../ models.proto\n```\n执行结束会在`src/pbfiles`下生成一个`models.pb.go`文件\n\n```golang\n# 在golang中使用models.pb.go\nfunc main() {\n\tprod := &pbfiles.ProdModel{Id: 2, Name: \"dengnanhao2\"}\n\tb, _ := proto.Marshal(prod)\n\tfmt.Println(prod)\n\tprod2 := &pbfiles.ProdModel{}\n\tproto.Unmarshal(b, prod2)\n\tfmt.Println(prod2)\n}\n\n```\n\n## rpc\n- RPC（Remote Procedure Call）是一种通信协议，用于不同计算机之间的远程调用。它允许程序在网络上的不同节点之间相互通信，使得远程节点的程序能够像调用本地函数一样调用远程节点的函数或方法。\n- RPC 的基本原理是客户端调用远程服务器上的函数，就像调用本地函数一样，而不需要关心网络通信的细节。客户端通过发送请求到服务器，并等待服务器的响应来完成远程调用。RPC 可以在不同的编程语言和不同的操作系统之间进行通信，使得分布式系统的构建和开发变得更加容易。\n- RPC 的设计目标是提供一种简单、高效和统一的方法来实现远程调用。它通常使用了一些序列化协议来将函数参数和返回值进行编码和解码，以便在网络上传输。常见的 RPC 框架包括 gRPC、Thrift、Apache Dubbo 等，它们提供了一系列的工具和库来简化 RPC 的开发和集成。\n- 通过使用 RPC，开发者可以将分布式系统中的各个组件连接起来，实现跨网络的函数调用，从而构建出更加灵活、可扩展和可维护的应用程序。RPC 在微服务架构、分布式计算和分布式系统中扮演着重要的角色，帮助开发者构建高效的分布式应用。\n\n## grpc\n- gRPC 是一种高性能、跨语言、跨平台的 RPC 框架，通过使用 Protobuf 进行接口定义和数据序列化，提供了简单易用的 API 和强大的功能，适用于构建分布式系统、微服务架构和高性能的客户端-服务器通信。\n- gRPC 的主要特点和优势包括：\n1. 高性能：gRPC 使用基于二进制的 Protobuf 进行数据序列化和传输，相比基于文本的传输格式（如 JSON、XML），传输效率更高，性能更好。\n2. 多语言支持：gRPC 支持多种编程语言，包括 C++, Java, Go, Python, JavaScript 等，使得不同语言的服务可以相互调用，方便构建跨平台、跨语言的分布式系统。\n3. 强大的IDL：通过 Protobuf 定义接口和消息类型，提供了强类型的接口定义和数据结构，使得接口和数据的描述更加清晰和灵活。\n4. 支持流式通信：gRPC 支持基于流的请求和响应，使得客户端和服务器之间可以实现双向流式通信，适用于实时数据传输、长连接等场景。\n5. 可插拔的拦截器：gRPC 提供拦截器机制，可以在请求和响应的不同阶段进行自定义操作，如认证、日志记录、流量控制等。\n6. 支持多种传输协议：gRPC 默认使用 HTTP/2 作为底层传输协议，提供了高效的、多路复用的、双向通信的传输能力。同时也支持使用其他的传输协议，如 gRPC-Web 用于浏览器环境下的通信。\n\n### grpc环境搭建\n1. 安装`grpc`库\n```bash\ngo get google.golang.org/grpc@v1.37\n```\n2. 安装`protoc-gen-go-grpc`库\n```bash\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc\n```\n3. 生成代码\n```bash\nprotoc --proto_path=protos --go-grpc_out=./../ service.proto\n```\n4. 测试\n- 定义消息类型\n```golang\n// models.proto 添加请求响应\n// 请求参数\nmessage ProdRequest {\n    int32 id = 1; // 商品ID\n}\n\n// 响应结果\nmessage ProdResponse {\n    ProdModel result = 1; // 商品信息\n}\n```\n\n- 定义服务\n```golang\n// service.proto\nsyntax=\"proto3\";\n\noption go_package = \"go-grpc/src/pbfiles\";\n\nimport \"models.proto\";\n\n\nservice ProdService {\n    rpc GetProd(ProdRequest) returns (ProdResponse);\n}\n```\n- 使用`protoc`工具根据`.proto`文件生成相应的代码文件\n```bash \nprotoc --proto_path=protos --go_out=./../ models.proto\nprotoc --proto_path=protos --go-grpc_out=./../ service.proto\n```\n\n- 编写`service`层\n```golang\n// services/ProdService.go\ntype ProdService struct {\n\tpbfiles.UnimplementedProdServiceServer // 不建议直接使用默认实现的GetProd方法，自行实现GetProd方法\n}\n\nfunc NewProdService() *ProdService {\n\treturn &ProdService{}\n}\n\nfunc (this *ProdService) GetProd(ctx context.Context, req *pbfiles.ProdRequest) (*pbfiles.ProdResponse, error) {\n\trsp := &pbfiles.ProdResponse{\n\t\tResult: &pbfiles.ProdModel{\n\t\t\tId:   req.Id,\n\t\t\tName: \"test\",\n\t\t},\n\t}\n\treturn rsp, nil\n}\n```\n- server端\n```golang\nfunc main() {\n\t// 创建一个 gRPC 服务器实例\n\tmyserver := grpc.NewServer()\n\t// 注册你的服务实现到服务器上\n\tpbfiles.RegisterProdServiceServer(myserver, services.NewProdService())\n\t// 监听8080\n\tlis, _ := net.Listen(\"tcp\", \":8080\")\n\t// 启动服务器，监听指定的网络地址\n\tif err := myserver.Serve(lis); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n- 客户端\n```golang\nfunc main() {\n\t// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法\n\t// 不校验证书\n\tclient, err := grpc.DialContext(context.Background(), \"localhost:8080\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treq := &pbfiles.ProdRequest{Id: 1002}\n\tres := &pbfiles.ProdResponse{}\n\terr = client.Invoke(context.Background(), \"/ProdService/GetProd\", req, res)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(res.Result)\n}\n```\n\n### 证书认证\nSAN (Subject Alternative Name) 证书是一种用于加密通信的数字证书，其中包含了多个主体名称（Subject Name）的备用选项。SAN 证书可以用于解决传统的 X.509 数字证书中的一个限制，即每个证书只能对应一个主体名称。\n\n传统的 X.509 数字证书在签发时需要指定一个主体名称，例如域名或者 IP 地址。而当一个服务器需要支持多个域名或者 IP 地址时，传统证书的方式就无法满足需求。这时就可以使用 SAN 证书来解决这个问题。\n\nSAN 证书允许在一个证书中指定多个主体名称，可以是域名、IP 地址或者其他标识符。这样，服务器在进行加密通信时就可以使用同一个证书，同时支持多个主体名称的验证。\n\nSAN 证书的主要优点是灵活性和可扩展性。它可以适应多种场景，例如多域名共享同一个证书、多个子域名、多个 IP 地址等。SAN 证书在实际应用中广泛使用，特别是在虚拟主机环境或者多站点共享证书的情况下。\n\n总结而言，SAN 证书是一种具有多个主体名称备选项的数字证书，用于解决传统证书单一主体名称的限制，提供更灵活和可扩展的加密通信解决方案。\n\n#### 双向认证\n1. `ca`根证书\n```bash\n# 生成私钥文件\nopenssl genrsa -out ca.key 4096\n# 生成ca根证书\nopenssl req -new -x509 -days 3650 -key ca.key -out ca.crt\n```\n2. `SAN`证书\n```bash\n#修改openssl.cnf配置，配置文件位于/etc/pki/tls/openssl.cnf\n#在[ req ]下新增\nreq_extensions = v3_req\n#[ v3_req ]新增\nsubjectAltName = @alt_names\n\n[ alt_names ]\nDNS.1 = *.grpc.dengnanhao.com\nDNS.2 = *.dengnanhao.com\n\n#同步修改window本地hosts文件添加\n127.0.0.1 test.grpc.dengnanhao.com\n```\n3. 服务端证书\n- 生成私钥\n```bash\nopenssl genpkey -algorithm RSA -out server.key\n```\n- 生成证书请求文件\n```bash\nopenssl req -new -nodes -key server.key -out server.csr -days 3650 -subj \"/C=cn/OU=dengnanhao/O=dengnanhao/CN=test.grpc.dengnanhao.com\" -config ./openssl.cnf -extensions v3_req\n# 查看请求文件DNS是否正确\nopenssl req -noout -text -in server.csr\n```\n- 签发证书\n```bash \nopenssl x509 -req -days 3650 -in server.csr -out server.pem -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -extfile ./openssl.cnf -extensions v3_req\n```\n- 将生成的`server.pem` `server.key`添加至项目目录 `certs`\n- 修改服务端代码\n```golang\nfunc main() {\n\t// 创建证书\n\tcreds, err := credentials.NewServerTLSFromFile(\"certs/server.pem\", \"certs/server.key\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// 创建一个 gRPC 服务器实例\n\tmyserver := grpc.NewServer(grpc.Creds(creds))\n\t// 注册你的服务实现到服务器上\n\tpbfiles.RegisterProdServiceServer(myserver, services.NewProdService())\n\t// 监听8080\n\tlis, _ := net.Listen(\"tcp\", \":8080\")\n\t// 启动服务器，监听指定的网络地址\n\tif err := myserver.Serve(lis); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n- 修改客户端代码\n```golang\nfunc main() {\n\tcreds, err := credentials.NewClientTLSFromFile(\"certs/server.pem\", \"test.grpc.dengnanhao.com\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法\n\t// 校验证书 grpc.WithTransportCredentials(creds)\n\tclient, err := grpc.DialContext(context.Background(), \"test.grpc.dengnanhao.com:8080\", grpc.WithTransportCredentials(creds))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treq := &pbfiles.ProdRequest{Id: 1002}\n\tres := &pbfiles.ProdResponse{}\n\tclient.Invoke(context.Background(), \"/ProdService/GetProd\", req, res)\n\tfmt.Println(res.Result)\n}\n```\n\n4. 客户端证书\n- 生成私钥\n```bash\nopenssl genpkey -algorithm RSA -out client.key\n```\n- 生成证书请求文件\n```bash\nopenssl req -new -key client.key -subj \"/CN=myclient\" -out client.csr\n```\n- 签发证书\n```bash \nopenssl x509 -req -in client.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -days 3650 -out client.crt\n``` \n\n- 修改客户端代码\n```golang\nfunc main() {\n\t// 可以作为全局变量，放入一个启动文件中\n\tcert, err := tls.LoadX509KeyPair(\"certs/client.crt\", \"certs/client.key\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcertPool := x509.NewCertPool()\n\tca, err := ioutil.ReadFile(\"certs/ca.crt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcertPool.AppendCertsFromPEM(ca)\n\tcreds := credentials.NewTLS(&tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t\tServerName:   \"test.grpc.dengnanhao.com\",\n\t\tRootCAs:      certPool,\n\t})\n\n\t// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法\n\t// 校验证书 grpc.WithTransportCredentials(creds)\n\tclient, e := grpc.DialContext(context.Background(), \"test.grpc.dengnanhao.com:8080\", grpc.WithTransportCredentials(creds))\n\tif e != nil {\n\t\tlog.Fatal(e)\n\t}\n\treq := &pbfiles.ProdRequest{Id: 1002}\n\tres := &pbfiles.ProdResponse{}\n\terr = client.Invoke(context.Background(), \"/ProdService/GetProd\", req, res)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(res.Result)\n}\n```\n\n","source":"_posts/go/grpc.md","raw":"---\ntitle: grpc\ntags:\n  - go\n  - grpc\ndate: 2023-05-25 10:10:28\nexcerpt: gRPC 是一种高性能、跨语言、跨平台的 RPC 框架，通过使用 Protobuf 进行接口定义和数据序列化，提供了简单易用的 API 和强大的功能，适用于构建分布式系统、微服务架构和高性能的客户端-服务器通信。\n---\n\n## Protobuf\n- Protocol Buffers（简称为 Protobuf）是一种语言无关、平台无关、可扩展的数据序列化格式，由 Google 开发并开源。它可以用于结构化数据的序列化和反序列化，用于数据存储、通信协议等领域。\n- Protobuf 使用 .proto 文件定义数据结构，然后使用特定的编译器将这些 .proto 文件编译成相应语言的源代码，从而在程序中使用生成的代码来进行数据的序列化和反序列化。它支持多种编程语言，包括但不限于 C++, Java, Python, Go, JavaScript 等。\n- Protobuf 的设计目标是高效、简单、可扩展。它采用二进制编码格式，相比于其他文本格式（如 JSON、XML），序列化后的数据更加紧凑，传输效率更高。同时，Protobuf 支持定义复杂的数据结构，包括嵌套类型、枚举类型、默认值等，使得数据的描述更加灵活和丰富。\n- 使用 Protobuf 的好处包括：\n1. 代码生成：根据 .proto 文件生成代码，简化数据的序列化和反序列化操作，提高开发效率。\n2. 紧凑的数据表示：相比文本格式，序列化后的数据更小，传输效率更高。\n3. 跨平台、跨语言支持：支持多种编程语言，使得不同平台和语言之间的数据交换更加方便。\n4. 可扩展性：支持版本升级和向后兼容，可以在不破坏现有数据的情况下进行结构的扩展和修改。\n\n总结来说，Protobuf 是一种高效、简单、可扩展的数据序列化格式，适用于多种领域，包括网络通信、数据存储、RPC（远程过程调用）等。它提供了强大的数据描述能力和跨平台、跨语言的支持，是一种优秀的数据交换格式。\n\n\n## 将`Protobuf`（.proto）转化为`go文件`（.go）\n### protobuf环境搭建\n\n1. **protoc**\n\nprotoc 是 Protocol Buffers（简称 Protobuf）的编译器命令行工具。[protoc下载地址](https://github.com/protocolbuffers/protobuf/releases)，下载解压完成之后将可执行文件加入系统的环境变量中。\n\n2. **安装protobuf库**\n```bash\ngo get github.com/golang/protobuf/proto@v1.5.3\n```\n\n3. **安装protoc-gen-go插件**\n```bash\n# go get 用于获取第三方包或模块并安装依赖项，go install 用于构建并安装指定包或模块的可执行文件或库。\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n```\n\n4. 代码演示\n- 项目目录\n```bash\n# go-grpc\n├── protos                                  # protobuf\n│   ├── models.proto                        # 模型\n├── src\n│   ├── pbfiles                             # 存放protobuf转化为go的文件\n├── go.mod                                 \n├── proto.bat                               # 命令文件\n└── main.go                            \n```\n- 使用protobuf定义商品类型\n```golang\n# models.proto\nsyntax = \"proto3\";\n\noption go_package = \"go-grpc/src/pbfiles\";\n\nmessage ProdModel {\n    int32 id = 1; // 商品ID\n    string name = 2; // 商品名称\n}\n```\n- 执行protoc命令\n```bash\nprotoc --proto_path=protos --go_out=./../ models.proto\n```\n执行结束会在`src/pbfiles`下生成一个`models.pb.go`文件\n\n```golang\n# 在golang中使用models.pb.go\nfunc main() {\n\tprod := &pbfiles.ProdModel{Id: 2, Name: \"dengnanhao2\"}\n\tb, _ := proto.Marshal(prod)\n\tfmt.Println(prod)\n\tprod2 := &pbfiles.ProdModel{}\n\tproto.Unmarshal(b, prod2)\n\tfmt.Println(prod2)\n}\n\n```\n\n## rpc\n- RPC（Remote Procedure Call）是一种通信协议，用于不同计算机之间的远程调用。它允许程序在网络上的不同节点之间相互通信，使得远程节点的程序能够像调用本地函数一样调用远程节点的函数或方法。\n- RPC 的基本原理是客户端调用远程服务器上的函数，就像调用本地函数一样，而不需要关心网络通信的细节。客户端通过发送请求到服务器，并等待服务器的响应来完成远程调用。RPC 可以在不同的编程语言和不同的操作系统之间进行通信，使得分布式系统的构建和开发变得更加容易。\n- RPC 的设计目标是提供一种简单、高效和统一的方法来实现远程调用。它通常使用了一些序列化协议来将函数参数和返回值进行编码和解码，以便在网络上传输。常见的 RPC 框架包括 gRPC、Thrift、Apache Dubbo 等，它们提供了一系列的工具和库来简化 RPC 的开发和集成。\n- 通过使用 RPC，开发者可以将分布式系统中的各个组件连接起来，实现跨网络的函数调用，从而构建出更加灵活、可扩展和可维护的应用程序。RPC 在微服务架构、分布式计算和分布式系统中扮演着重要的角色，帮助开发者构建高效的分布式应用。\n\n## grpc\n- gRPC 是一种高性能、跨语言、跨平台的 RPC 框架，通过使用 Protobuf 进行接口定义和数据序列化，提供了简单易用的 API 和强大的功能，适用于构建分布式系统、微服务架构和高性能的客户端-服务器通信。\n- gRPC 的主要特点和优势包括：\n1. 高性能：gRPC 使用基于二进制的 Protobuf 进行数据序列化和传输，相比基于文本的传输格式（如 JSON、XML），传输效率更高，性能更好。\n2. 多语言支持：gRPC 支持多种编程语言，包括 C++, Java, Go, Python, JavaScript 等，使得不同语言的服务可以相互调用，方便构建跨平台、跨语言的分布式系统。\n3. 强大的IDL：通过 Protobuf 定义接口和消息类型，提供了强类型的接口定义和数据结构，使得接口和数据的描述更加清晰和灵活。\n4. 支持流式通信：gRPC 支持基于流的请求和响应，使得客户端和服务器之间可以实现双向流式通信，适用于实时数据传输、长连接等场景。\n5. 可插拔的拦截器：gRPC 提供拦截器机制，可以在请求和响应的不同阶段进行自定义操作，如认证、日志记录、流量控制等。\n6. 支持多种传输协议：gRPC 默认使用 HTTP/2 作为底层传输协议，提供了高效的、多路复用的、双向通信的传输能力。同时也支持使用其他的传输协议，如 gRPC-Web 用于浏览器环境下的通信。\n\n### grpc环境搭建\n1. 安装`grpc`库\n```bash\ngo get google.golang.org/grpc@v1.37\n```\n2. 安装`protoc-gen-go-grpc`库\n```bash\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc\n```\n3. 生成代码\n```bash\nprotoc --proto_path=protos --go-grpc_out=./../ service.proto\n```\n4. 测试\n- 定义消息类型\n```golang\n// models.proto 添加请求响应\n// 请求参数\nmessage ProdRequest {\n    int32 id = 1; // 商品ID\n}\n\n// 响应结果\nmessage ProdResponse {\n    ProdModel result = 1; // 商品信息\n}\n```\n\n- 定义服务\n```golang\n// service.proto\nsyntax=\"proto3\";\n\noption go_package = \"go-grpc/src/pbfiles\";\n\nimport \"models.proto\";\n\n\nservice ProdService {\n    rpc GetProd(ProdRequest) returns (ProdResponse);\n}\n```\n- 使用`protoc`工具根据`.proto`文件生成相应的代码文件\n```bash \nprotoc --proto_path=protos --go_out=./../ models.proto\nprotoc --proto_path=protos --go-grpc_out=./../ service.proto\n```\n\n- 编写`service`层\n```golang\n// services/ProdService.go\ntype ProdService struct {\n\tpbfiles.UnimplementedProdServiceServer // 不建议直接使用默认实现的GetProd方法，自行实现GetProd方法\n}\n\nfunc NewProdService() *ProdService {\n\treturn &ProdService{}\n}\n\nfunc (this *ProdService) GetProd(ctx context.Context, req *pbfiles.ProdRequest) (*pbfiles.ProdResponse, error) {\n\trsp := &pbfiles.ProdResponse{\n\t\tResult: &pbfiles.ProdModel{\n\t\t\tId:   req.Id,\n\t\t\tName: \"test\",\n\t\t},\n\t}\n\treturn rsp, nil\n}\n```\n- server端\n```golang\nfunc main() {\n\t// 创建一个 gRPC 服务器实例\n\tmyserver := grpc.NewServer()\n\t// 注册你的服务实现到服务器上\n\tpbfiles.RegisterProdServiceServer(myserver, services.NewProdService())\n\t// 监听8080\n\tlis, _ := net.Listen(\"tcp\", \":8080\")\n\t// 启动服务器，监听指定的网络地址\n\tif err := myserver.Serve(lis); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n- 客户端\n```golang\nfunc main() {\n\t// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法\n\t// 不校验证书\n\tclient, err := grpc.DialContext(context.Background(), \"localhost:8080\", grpc.WithInsecure())\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treq := &pbfiles.ProdRequest{Id: 1002}\n\tres := &pbfiles.ProdResponse{}\n\terr = client.Invoke(context.Background(), \"/ProdService/GetProd\", req, res)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(res.Result)\n}\n```\n\n### 证书认证\nSAN (Subject Alternative Name) 证书是一种用于加密通信的数字证书，其中包含了多个主体名称（Subject Name）的备用选项。SAN 证书可以用于解决传统的 X.509 数字证书中的一个限制，即每个证书只能对应一个主体名称。\n\n传统的 X.509 数字证书在签发时需要指定一个主体名称，例如域名或者 IP 地址。而当一个服务器需要支持多个域名或者 IP 地址时，传统证书的方式就无法满足需求。这时就可以使用 SAN 证书来解决这个问题。\n\nSAN 证书允许在一个证书中指定多个主体名称，可以是域名、IP 地址或者其他标识符。这样，服务器在进行加密通信时就可以使用同一个证书，同时支持多个主体名称的验证。\n\nSAN 证书的主要优点是灵活性和可扩展性。它可以适应多种场景，例如多域名共享同一个证书、多个子域名、多个 IP 地址等。SAN 证书在实际应用中广泛使用，特别是在虚拟主机环境或者多站点共享证书的情况下。\n\n总结而言，SAN 证书是一种具有多个主体名称备选项的数字证书，用于解决传统证书单一主体名称的限制，提供更灵活和可扩展的加密通信解决方案。\n\n#### 双向认证\n1. `ca`根证书\n```bash\n# 生成私钥文件\nopenssl genrsa -out ca.key 4096\n# 生成ca根证书\nopenssl req -new -x509 -days 3650 -key ca.key -out ca.crt\n```\n2. `SAN`证书\n```bash\n#修改openssl.cnf配置，配置文件位于/etc/pki/tls/openssl.cnf\n#在[ req ]下新增\nreq_extensions = v3_req\n#[ v3_req ]新增\nsubjectAltName = @alt_names\n\n[ alt_names ]\nDNS.1 = *.grpc.dengnanhao.com\nDNS.2 = *.dengnanhao.com\n\n#同步修改window本地hosts文件添加\n127.0.0.1 test.grpc.dengnanhao.com\n```\n3. 服务端证书\n- 生成私钥\n```bash\nopenssl genpkey -algorithm RSA -out server.key\n```\n- 生成证书请求文件\n```bash\nopenssl req -new -nodes -key server.key -out server.csr -days 3650 -subj \"/C=cn/OU=dengnanhao/O=dengnanhao/CN=test.grpc.dengnanhao.com\" -config ./openssl.cnf -extensions v3_req\n# 查看请求文件DNS是否正确\nopenssl req -noout -text -in server.csr\n```\n- 签发证书\n```bash \nopenssl x509 -req -days 3650 -in server.csr -out server.pem -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -extfile ./openssl.cnf -extensions v3_req\n```\n- 将生成的`server.pem` `server.key`添加至项目目录 `certs`\n- 修改服务端代码\n```golang\nfunc main() {\n\t// 创建证书\n\tcreds, err := credentials.NewServerTLSFromFile(\"certs/server.pem\", \"certs/server.key\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// 创建一个 gRPC 服务器实例\n\tmyserver := grpc.NewServer(grpc.Creds(creds))\n\t// 注册你的服务实现到服务器上\n\tpbfiles.RegisterProdServiceServer(myserver, services.NewProdService())\n\t// 监听8080\n\tlis, _ := net.Listen(\"tcp\", \":8080\")\n\t// 启动服务器，监听指定的网络地址\n\tif err := myserver.Serve(lis); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n- 修改客户端代码\n```golang\nfunc main() {\n\tcreds, err := credentials.NewClientTLSFromFile(\"certs/server.pem\", \"test.grpc.dengnanhao.com\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法\n\t// 校验证书 grpc.WithTransportCredentials(creds)\n\tclient, err := grpc.DialContext(context.Background(), \"test.grpc.dengnanhao.com:8080\", grpc.WithTransportCredentials(creds))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treq := &pbfiles.ProdRequest{Id: 1002}\n\tres := &pbfiles.ProdResponse{}\n\tclient.Invoke(context.Background(), \"/ProdService/GetProd\", req, res)\n\tfmt.Println(res.Result)\n}\n```\n\n4. 客户端证书\n- 生成私钥\n```bash\nopenssl genpkey -algorithm RSA -out client.key\n```\n- 生成证书请求文件\n```bash\nopenssl req -new -key client.key -subj \"/CN=myclient\" -out client.csr\n```\n- 签发证书\n```bash \nopenssl x509 -req -in client.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -days 3650 -out client.crt\n``` \n\n- 修改客户端代码\n```golang\nfunc main() {\n\t// 可以作为全局变量，放入一个启动文件中\n\tcert, err := tls.LoadX509KeyPair(\"certs/client.crt\", \"certs/client.key\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcertPool := x509.NewCertPool()\n\tca, err := ioutil.ReadFile(\"certs/ca.crt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tcertPool.AppendCertsFromPEM(ca)\n\tcreds := credentials.NewTLS(&tls.Config{\n\t\tCertificates: []tls.Certificate{cert},\n\t\tServerName:   \"test.grpc.dengnanhao.com\",\n\t\tRootCAs:      certPool,\n\t})\n\n\t// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法\n\t// 校验证书 grpc.WithTransportCredentials(creds)\n\tclient, e := grpc.DialContext(context.Background(), \"test.grpc.dengnanhao.com:8080\", grpc.WithTransportCredentials(creds))\n\tif e != nil {\n\t\tlog.Fatal(e)\n\t}\n\treq := &pbfiles.ProdRequest{Id: 1002}\n\tres := &pbfiles.ProdResponse{}\n\terr = client.Invoke(context.Background(), \"/ProdService/GetProd\", req, res)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(res.Result)\n}\n```\n\n","slug":"go/grpc","published":1,"updated":"2023-06-02T13:20:02.560Z","_id":"cli2hzoyt00014oup1bfc64vc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h2><ul>\n<li>Protocol Buffers（简称为 Protobuf）是一种语言无关、平台无关、可扩展的数据序列化格式，由 Google 开发并开源。它可以用于结构化数据的序列化和反序列化，用于数据存储、通信协议等领域。</li>\n<li>Protobuf 使用 .proto 文件定义数据结构，然后使用特定的编译器将这些 .proto 文件编译成相应语言的源代码，从而在程序中使用生成的代码来进行数据的序列化和反序列化。它支持多种编程语言，包括但不限于 C++, Java, Python, Go, JavaScript 等。</li>\n<li>Protobuf 的设计目标是高效、简单、可扩展。它采用二进制编码格式，相比于其他文本格式（如 JSON、XML），序列化后的数据更加紧凑，传输效率更高。同时，Protobuf 支持定义复杂的数据结构，包括嵌套类型、枚举类型、默认值等，使得数据的描述更加灵活和丰富。</li>\n<li>使用 Protobuf 的好处包括：</li>\n</ul>\n<ol>\n<li>代码生成：根据 .proto 文件生成代码，简化数据的序列化和反序列化操作，提高开发效率。</li>\n<li>紧凑的数据表示：相比文本格式，序列化后的数据更小，传输效率更高。</li>\n<li>跨平台、跨语言支持：支持多种编程语言，使得不同平台和语言之间的数据交换更加方便。</li>\n<li>可扩展性：支持版本升级和向后兼容，可以在不破坏现有数据的情况下进行结构的扩展和修改。</li>\n</ol>\n<p>总结来说，Protobuf 是一种高效、简单、可扩展的数据序列化格式，适用于多种领域，包括网络通信、数据存储、RPC（远程过程调用）等。它提供了强大的数据描述能力和跨平台、跨语言的支持，是一种优秀的数据交换格式。</p>\n<h2 id=\"将Protobuf（-proto）转化为go文件（-go）\"><a href=\"#将Protobuf（-proto）转化为go文件（-go）\" class=\"headerlink\" title=\"将Protobuf（.proto）转化为go文件（.go）\"></a>将<code>Protobuf</code>（.proto）转化为<code>go文件</code>（.go）</h2><h3 id=\"protobuf环境搭建\"><a href=\"#protobuf环境搭建\" class=\"headerlink\" title=\"protobuf环境搭建\"></a>protobuf环境搭建</h3><ol>\n<li><strong>protoc</strong></li>\n</ol>\n<p>protoc 是 Protocol Buffers（简称 Protobuf）的编译器命令行工具。<a href=\"https://github.com/protocolbuffers/protobuf/releases\">protoc下载地址</a>，下载解压完成之后将可执行文件加入系统的环境变量中。</p>\n<ol start=\"2\">\n<li><p><strong>安装protobuf库</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get github.com/golang/protobuf/proto@v1.5.3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>安装protoc-gen-go插件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># go get 用于获取第三方包或模块并安装依赖项，go install 用于构建并安装指定包或模块的可执行文件或库。</span></span><br><span class=\"line\">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码演示</p>\n</li>\n</ol>\n<ul>\n<li>项目目录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># go-grpc</span></span><br><span class=\"line\">├── protos                                  <span class=\"comment\"># protobuf</span></span><br><span class=\"line\">│   ├── models.proto                        <span class=\"comment\"># 模型</span></span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── pbfiles                             <span class=\"comment\"># 存放protobuf转化为go的文件</span></span><br><span class=\"line\">├── go.mod                                 </span><br><span class=\"line\">├── proto.bat                               <span class=\"comment\"># 命令文件</span></span><br><span class=\"line\">└── main.go                            </span><br></pre></td></tr></table></figure></li>\n<li>使用protobuf定义商品类型<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># models.proto</span><br><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package = <span class=\"string\">&quot;go-grpc/src/pbfiles&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">message ProdModel &#123;</span><br><span class=\"line\">    <span class=\"type\">int32</span> id = <span class=\"number\">1</span>; <span class=\"comment\">// 商品ID</span></span><br><span class=\"line\">    <span class=\"type\">string</span> name = <span class=\"number\">2</span>; <span class=\"comment\">// 商品名称</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>执行protoc命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --proto_path=protos --go_out=./../ models.proto</span><br></pre></td></tr></table></figure>\n执行结束会在<code>src/pbfiles</code>下生成一个<code>models.pb.go</code>文件</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在golang中使用models.pb.<span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tprod := &amp;pbfiles.ProdModel&#123;Id: <span class=\"number\">2</span>, Name: <span class=\"string\">&quot;dengnanhao2&quot;</span>&#125;</span><br><span class=\"line\">\tb, _ := proto.Marshal(prod)</span><br><span class=\"line\">\tfmt.Println(prod)</span><br><span class=\"line\">\tprod2 := &amp;pbfiles.ProdModel&#123;&#125;</span><br><span class=\"line\">\tproto.Unmarshal(b, prod2)</span><br><span class=\"line\">\tfmt.Println(prod2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rpc\"><a href=\"#rpc\" class=\"headerlink\" title=\"rpc\"></a>rpc</h2><ul>\n<li>RPC（Remote Procedure Call）是一种通信协议，用于不同计算机之间的远程调用。它允许程序在网络上的不同节点之间相互通信，使得远程节点的程序能够像调用本地函数一样调用远程节点的函数或方法。</li>\n<li>RPC 的基本原理是客户端调用远程服务器上的函数，就像调用本地函数一样，而不需要关心网络通信的细节。客户端通过发送请求到服务器，并等待服务器的响应来完成远程调用。RPC 可以在不同的编程语言和不同的操作系统之间进行通信，使得分布式系统的构建和开发变得更加容易。</li>\n<li>RPC 的设计目标是提供一种简单、高效和统一的方法来实现远程调用。它通常使用了一些序列化协议来将函数参数和返回值进行编码和解码，以便在网络上传输。常见的 RPC 框架包括 gRPC、Thrift、Apache Dubbo 等，它们提供了一系列的工具和库来简化 RPC 的开发和集成。</li>\n<li>通过使用 RPC，开发者可以将分布式系统中的各个组件连接起来，实现跨网络的函数调用，从而构建出更加灵活、可扩展和可维护的应用程序。RPC 在微服务架构、分布式计算和分布式系统中扮演着重要的角色，帮助开发者构建高效的分布式应用。</li>\n</ul>\n<h2 id=\"grpc\"><a href=\"#grpc\" class=\"headerlink\" title=\"grpc\"></a>grpc</h2><ul>\n<li>gRPC 是一种高性能、跨语言、跨平台的 RPC 框架，通过使用 Protobuf 进行接口定义和数据序列化，提供了简单易用的 API 和强大的功能，适用于构建分布式系统、微服务架构和高性能的客户端-服务器通信。</li>\n<li>gRPC 的主要特点和优势包括：</li>\n</ul>\n<ol>\n<li>高性能：gRPC 使用基于二进制的 Protobuf 进行数据序列化和传输，相比基于文本的传输格式（如 JSON、XML），传输效率更高，性能更好。</li>\n<li>多语言支持：gRPC 支持多种编程语言，包括 C++, Java, Go, Python, JavaScript 等，使得不同语言的服务可以相互调用，方便构建跨平台、跨语言的分布式系统。</li>\n<li>强大的IDL：通过 Protobuf 定义接口和消息类型，提供了强类型的接口定义和数据结构，使得接口和数据的描述更加清晰和灵活。</li>\n<li>支持流式通信：gRPC 支持基于流的请求和响应，使得客户端和服务器之间可以实现双向流式通信，适用于实时数据传输、长连接等场景。</li>\n<li>可插拔的拦截器：gRPC 提供拦截器机制，可以在请求和响应的不同阶段进行自定义操作，如认证、日志记录、流量控制等。</li>\n<li>支持多种传输协议：gRPC 默认使用 HTTP&#x2F;2 作为底层传输协议，提供了高效的、多路复用的、双向通信的传输能力。同时也支持使用其他的传输协议，如 gRPC-Web 用于浏览器环境下的通信。</li>\n</ol>\n<h3 id=\"grpc环境搭建\"><a href=\"#grpc环境搭建\" class=\"headerlink\" title=\"grpc环境搭建\"></a>grpc环境搭建</h3><ol>\n<li>安装<code>grpc</code>库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google.golang.org/grpc@v1.37</span><br></pre></td></tr></table></figure></li>\n<li>安装<code>protoc-gen-go-grpc</code>库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure></li>\n<li>生成代码<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --proto_path=protos --go-grpc_out=./../ service.proto</span><br></pre></td></tr></table></figure></li>\n<li>测试</li>\n</ol>\n<ul>\n<li><p>定义消息类型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// models.proto 添加请求响应</span></span><br><span class=\"line\"><span class=\"comment\">// 请求参数</span></span><br><span class=\"line\">message ProdRequest &#123;</span><br><span class=\"line\">    <span class=\"type\">int32</span> id = <span class=\"number\">1</span>; <span class=\"comment\">// 商品ID</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应结果</span></span><br><span class=\"line\">message ProdResponse &#123;</span><br><span class=\"line\">    ProdModel result = <span class=\"number\">1</span>; <span class=\"comment\">// 商品信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义服务</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// service.proto</span></span><br><span class=\"line\">syntax=<span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package = <span class=\"string\">&quot;go-grpc/src/pbfiles&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;models.proto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">service ProdService &#123;</span><br><span class=\"line\">    rpc GetProd(ProdRequest) returns (ProdResponse);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用<code>protoc</code>工具根据<code>.proto</code>文件生成相应的代码文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --proto_path=protos --go_out=./../ models.proto</span><br><span class=\"line\">protoc --proto_path=protos --go-grpc_out=./../ service.proto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写<code>service</code>层</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// services/ProdService.go</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ProdService <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpbfiles.UnimplementedProdServiceServer <span class=\"comment\">// 不建议直接使用默认实现的GetProd方法，自行实现GetProd方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewProdService</span><span class=\"params\">()</span></span> *ProdService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ProdService&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ProdService)</span></span> GetProd(ctx context.Context, req *pbfiles.ProdRequest) (*pbfiles.ProdResponse, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\trsp := &amp;pbfiles.ProdResponse&#123;</span><br><span class=\"line\">\t\tResult: &amp;pbfiles.ProdModel&#123;</span><br><span class=\"line\">\t\t\tId:   req.Id,</span><br><span class=\"line\">\t\t\tName: <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rsp, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>server端</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个 gRPC 服务器实例</span></span><br><span class=\"line\">\tmyserver := grpc.NewServer()</span><br><span class=\"line\">\t<span class=\"comment\">// 注册你的服务实现到服务器上</span></span><br><span class=\"line\">\tpbfiles.RegisterProdServiceServer(myserver, services.NewProdService())</span><br><span class=\"line\">\t<span class=\"comment\">// 监听8080</span></span><br><span class=\"line\">\tlis, _ := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;:8080&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 启动服务器，监听指定的网络地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := myserver.Serve(lis); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>客户端</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法</span></span><br><span class=\"line\">\t<span class=\"comment\">// 不校验证书</span></span><br><span class=\"line\">\tclient, err := grpc.DialContext(context.Background(), <span class=\"string\">&quot;localhost:8080&quot;</span>, grpc.WithInsecure())</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treq := &amp;pbfiles.ProdRequest&#123;Id: <span class=\"number\">1002</span>&#125;</span><br><span class=\"line\">\tres := &amp;pbfiles.ProdResponse&#123;&#125;</span><br><span class=\"line\">\terr = client.Invoke(context.Background(), <span class=\"string\">&quot;/ProdService/GetProd&quot;</span>, req, res)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(res.Result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"证书认证\"><a href=\"#证书认证\" class=\"headerlink\" title=\"证书认证\"></a>证书认证</h3><p>SAN (Subject Alternative Name) 证书是一种用于加密通信的数字证书，其中包含了多个主体名称（Subject Name）的备用选项。SAN 证书可以用于解决传统的 X.509 数字证书中的一个限制，即每个证书只能对应一个主体名称。</p>\n<p>传统的 X.509 数字证书在签发时需要指定一个主体名称，例如域名或者 IP 地址。而当一个服务器需要支持多个域名或者 IP 地址时，传统证书的方式就无法满足需求。这时就可以使用 SAN 证书来解决这个问题。</p>\n<p>SAN 证书允许在一个证书中指定多个主体名称，可以是域名、IP 地址或者其他标识符。这样，服务器在进行加密通信时就可以使用同一个证书，同时支持多个主体名称的验证。</p>\n<p>SAN 证书的主要优点是灵活性和可扩展性。它可以适应多种场景，例如多域名共享同一个证书、多个子域名、多个 IP 地址等。SAN 证书在实际应用中广泛使用，特别是在虚拟主机环境或者多站点共享证书的情况下。</p>\n<p>总结而言，SAN 证书是一种具有多个主体名称备选项的数字证书，用于解决传统证书单一主体名称的限制，提供更灵活和可扩展的加密通信解决方案。</p>\n<h4 id=\"双向认证\"><a href=\"#双向认证\" class=\"headerlink\" title=\"双向认证\"></a>双向认证</h4><ol>\n<li><code>ca</code>根证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成私钥文件</span></span><br><span class=\"line\">openssl genrsa -out ca.key 4096</span><br><span class=\"line\"><span class=\"comment\"># 生成ca根证书</span></span><br><span class=\"line\">openssl req -new -x509 -days 3650 -key ca.key -out ca.crt</span><br></pre></td></tr></table></figure></li>\n<li><code>SAN</code>证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#修改openssl.cnf配置，配置文件位于/etc/pki/tls/openssl.cnf</span></span><br><span class=\"line\"><span class=\"comment\">#在[ req ]下新增</span></span><br><span class=\"line\">req_extensions = v3_req</span><br><span class=\"line\"><span class=\"comment\">#[ v3_req ]新增</span></span><br><span class=\"line\">subjectAltName = @alt_names</span><br><span class=\"line\"></span><br><span class=\"line\">[ alt_names ]</span><br><span class=\"line\">DNS.1 = *.grpc.dengnanhao.com</span><br><span class=\"line\">DNS.2 = *.dengnanhao.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#同步修改window本地hosts文件添加</span></span><br><span class=\"line\">127.0.0.1 test.grpc.dengnanhao.com</span><br></pre></td></tr></table></figure></li>\n<li>服务端证书</li>\n</ol>\n<ul>\n<li>生成私钥<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genpkey -algorithm RSA -out server.key</span><br></pre></td></tr></table></figure></li>\n<li>生成证书请求文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -nodes -key server.key -out server.csr -days 3650 -subj <span class=\"string\">&quot;/C=cn/OU=dengnanhao/O=dengnanhao/CN=test.grpc.dengnanhao.com&quot;</span> -config ./openssl.cnf -extensions v3_req</span><br><span class=\"line\"><span class=\"comment\"># 查看请求文件DNS是否正确</span></span><br><span class=\"line\">openssl req -noout -text -<span class=\"keyword\">in</span> server.csr</span><br></pre></td></tr></table></figure></li>\n<li>签发证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -days 3650 -<span class=\"keyword\">in</span> server.csr -out server.pem -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -extfile ./openssl.cnf -extensions v3_req</span><br></pre></td></tr></table></figure></li>\n<li>将生成的<code>server.pem</code> <code>server.key</code>添加至项目目录 <code>certs</code></li>\n<li>修改服务端代码<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建证书</span></span><br><span class=\"line\">\tcreds, err := credentials.NewServerTLSFromFile(<span class=\"string\">&quot;certs/server.pem&quot;</span>, <span class=\"string\">&quot;certs/server.key&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个 gRPC 服务器实例</span></span><br><span class=\"line\">\tmyserver := grpc.NewServer(grpc.Creds(creds))</span><br><span class=\"line\">\t<span class=\"comment\">// 注册你的服务实现到服务器上</span></span><br><span class=\"line\">\tpbfiles.RegisterProdServiceServer(myserver, services.NewProdService())</span><br><span class=\"line\">\t<span class=\"comment\">// 监听8080</span></span><br><span class=\"line\">\tlis, _ := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;:8080&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 启动服务器，监听指定的网络地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := myserver.Serve(lis); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修改客户端代码<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tcreds, err := credentials.NewClientTLSFromFile(<span class=\"string\">&quot;certs/server.pem&quot;</span>, <span class=\"string\">&quot;test.grpc.dengnanhao.com&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法</span></span><br><span class=\"line\">\t<span class=\"comment\">// 校验证书 grpc.WithTransportCredentials(creds)</span></span><br><span class=\"line\">\tclient, err := grpc.DialContext(context.Background(), <span class=\"string\">&quot;test.grpc.dengnanhao.com:8080&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treq := &amp;pbfiles.ProdRequest&#123;Id: <span class=\"number\">1002</span>&#125;</span><br><span class=\"line\">\tres := &amp;pbfiles.ProdResponse&#123;&#125;</span><br><span class=\"line\">\tclient.Invoke(context.Background(), <span class=\"string\">&quot;/ProdService/GetProd&quot;</span>, req, res)</span><br><span class=\"line\">\tfmt.Println(res.Result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>客户端证书</li>\n</ol>\n<ul>\n<li><p>生成私钥</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genpkey -algorithm RSA -out client.key</span><br></pre></td></tr></table></figure></li>\n<li><p>生成证书请求文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key client.key -subj <span class=\"string\">&quot;/CN=myclient&quot;</span> -out client.csr</span><br></pre></td></tr></table></figure></li>\n<li><p>签发证书</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -<span class=\"keyword\">in</span> client.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -days 3650 -out client.crt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改客户端代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 可以作为全局变量，放入一个启动文件中</span></span><br><span class=\"line\">\tcert, err := tls.LoadX509KeyPair(<span class=\"string\">&quot;certs/client.crt&quot;</span>, <span class=\"string\">&quot;certs/client.key&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcertPool := x509.NewCertPool()</span><br><span class=\"line\">\tca, err := ioutil.ReadFile(<span class=\"string\">&quot;certs/ca.crt&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcertPool.AppendCertsFromPEM(ca)</span><br><span class=\"line\">\tcreds := credentials.NewTLS(&amp;tls.Config&#123;</span><br><span class=\"line\">\t\tCertificates: []tls.Certificate&#123;cert&#125;,</span><br><span class=\"line\">\t\tServerName:   <span class=\"string\">&quot;test.grpc.dengnanhao.com&quot;</span>,</span><br><span class=\"line\">\t\tRootCAs:      certPool,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法</span></span><br><span class=\"line\">\t<span class=\"comment\">// 校验证书 grpc.WithTransportCredentials(creds)</span></span><br><span class=\"line\">\tclient, e := grpc.DialContext(context.Background(), <span class=\"string\">&quot;test.grpc.dengnanhao.com:8080&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(e)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treq := &amp;pbfiles.ProdRequest&#123;Id: <span class=\"number\">1002</span>&#125;</span><br><span class=\"line\">\tres := &amp;pbfiles.ProdResponse&#123;&#125;</span><br><span class=\"line\">\terr = client.Invoke(context.Background(), <span class=\"string\">&quot;/ProdService/GetProd&quot;</span>, req, res)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(res.Result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"more":"<h2 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h2><ul>\n<li>Protocol Buffers（简称为 Protobuf）是一种语言无关、平台无关、可扩展的数据序列化格式，由 Google 开发并开源。它可以用于结构化数据的序列化和反序列化，用于数据存储、通信协议等领域。</li>\n<li>Protobuf 使用 .proto 文件定义数据结构，然后使用特定的编译器将这些 .proto 文件编译成相应语言的源代码，从而在程序中使用生成的代码来进行数据的序列化和反序列化。它支持多种编程语言，包括但不限于 C++, Java, Python, Go, JavaScript 等。</li>\n<li>Protobuf 的设计目标是高效、简单、可扩展。它采用二进制编码格式，相比于其他文本格式（如 JSON、XML），序列化后的数据更加紧凑，传输效率更高。同时，Protobuf 支持定义复杂的数据结构，包括嵌套类型、枚举类型、默认值等，使得数据的描述更加灵活和丰富。</li>\n<li>使用 Protobuf 的好处包括：</li>\n</ul>\n<ol>\n<li>代码生成：根据 .proto 文件生成代码，简化数据的序列化和反序列化操作，提高开发效率。</li>\n<li>紧凑的数据表示：相比文本格式，序列化后的数据更小，传输效率更高。</li>\n<li>跨平台、跨语言支持：支持多种编程语言，使得不同平台和语言之间的数据交换更加方便。</li>\n<li>可扩展性：支持版本升级和向后兼容，可以在不破坏现有数据的情况下进行结构的扩展和修改。</li>\n</ol>\n<p>总结来说，Protobuf 是一种高效、简单、可扩展的数据序列化格式，适用于多种领域，包括网络通信、数据存储、RPC（远程过程调用）等。它提供了强大的数据描述能力和跨平台、跨语言的支持，是一种优秀的数据交换格式。</p>\n<h2 id=\"将Protobuf（-proto）转化为go文件（-go）\"><a href=\"#将Protobuf（-proto）转化为go文件（-go）\" class=\"headerlink\" title=\"将Protobuf（.proto）转化为go文件（.go）\"></a>将<code>Protobuf</code>（.proto）转化为<code>go文件</code>（.go）</h2><h3 id=\"protobuf环境搭建\"><a href=\"#protobuf环境搭建\" class=\"headerlink\" title=\"protobuf环境搭建\"></a>protobuf环境搭建</h3><ol>\n<li><strong>protoc</strong></li>\n</ol>\n<p>protoc 是 Protocol Buffers（简称 Protobuf）的编译器命令行工具。<a href=\"https://github.com/protocolbuffers/protobuf/releases\">protoc下载地址</a>，下载解压完成之后将可执行文件加入系统的环境变量中。</p>\n<ol start=\"2\">\n<li><p><strong>安装protobuf库</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get github.com/golang/protobuf/proto@v1.5.3</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>安装protoc-gen-go插件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># go get 用于获取第三方包或模块并安装依赖项，go install 用于构建并安装指定包或模块的可执行文件或库。</span></span><br><span class=\"line\">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码演示</p>\n</li>\n</ol>\n<ul>\n<li>项目目录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># go-grpc</span></span><br><span class=\"line\">├── protos                                  <span class=\"comment\"># protobuf</span></span><br><span class=\"line\">│   ├── models.proto                        <span class=\"comment\"># 模型</span></span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── pbfiles                             <span class=\"comment\"># 存放protobuf转化为go的文件</span></span><br><span class=\"line\">├── go.mod                                 </span><br><span class=\"line\">├── proto.bat                               <span class=\"comment\"># 命令文件</span></span><br><span class=\"line\">└── main.go                            </span><br></pre></td></tr></table></figure></li>\n<li>使用protobuf定义商品类型<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># models.proto</span><br><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package = <span class=\"string\">&quot;go-grpc/src/pbfiles&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">message ProdModel &#123;</span><br><span class=\"line\">    <span class=\"type\">int32</span> id = <span class=\"number\">1</span>; <span class=\"comment\">// 商品ID</span></span><br><span class=\"line\">    <span class=\"type\">string</span> name = <span class=\"number\">2</span>; <span class=\"comment\">// 商品名称</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>执行protoc命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --proto_path=protos --go_out=./../ models.proto</span><br></pre></td></tr></table></figure>\n执行结束会在<code>src/pbfiles</code>下生成一个<code>models.pb.go</code>文件</li>\n</ul>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在golang中使用models.pb.<span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tprod := &amp;pbfiles.ProdModel&#123;Id: <span class=\"number\">2</span>, Name: <span class=\"string\">&quot;dengnanhao2&quot;</span>&#125;</span><br><span class=\"line\">\tb, _ := proto.Marshal(prod)</span><br><span class=\"line\">\tfmt.Println(prod)</span><br><span class=\"line\">\tprod2 := &amp;pbfiles.ProdModel&#123;&#125;</span><br><span class=\"line\">\tproto.Unmarshal(b, prod2)</span><br><span class=\"line\">\tfmt.Println(prod2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"rpc\"><a href=\"#rpc\" class=\"headerlink\" title=\"rpc\"></a>rpc</h2><ul>\n<li>RPC（Remote Procedure Call）是一种通信协议，用于不同计算机之间的远程调用。它允许程序在网络上的不同节点之间相互通信，使得远程节点的程序能够像调用本地函数一样调用远程节点的函数或方法。</li>\n<li>RPC 的基本原理是客户端调用远程服务器上的函数，就像调用本地函数一样，而不需要关心网络通信的细节。客户端通过发送请求到服务器，并等待服务器的响应来完成远程调用。RPC 可以在不同的编程语言和不同的操作系统之间进行通信，使得分布式系统的构建和开发变得更加容易。</li>\n<li>RPC 的设计目标是提供一种简单、高效和统一的方法来实现远程调用。它通常使用了一些序列化协议来将函数参数和返回值进行编码和解码，以便在网络上传输。常见的 RPC 框架包括 gRPC、Thrift、Apache Dubbo 等，它们提供了一系列的工具和库来简化 RPC 的开发和集成。</li>\n<li>通过使用 RPC，开发者可以将分布式系统中的各个组件连接起来，实现跨网络的函数调用，从而构建出更加灵活、可扩展和可维护的应用程序。RPC 在微服务架构、分布式计算和分布式系统中扮演着重要的角色，帮助开发者构建高效的分布式应用。</li>\n</ul>\n<h2 id=\"grpc\"><a href=\"#grpc\" class=\"headerlink\" title=\"grpc\"></a>grpc</h2><ul>\n<li>gRPC 是一种高性能、跨语言、跨平台的 RPC 框架，通过使用 Protobuf 进行接口定义和数据序列化，提供了简单易用的 API 和强大的功能，适用于构建分布式系统、微服务架构和高性能的客户端-服务器通信。</li>\n<li>gRPC 的主要特点和优势包括：</li>\n</ul>\n<ol>\n<li>高性能：gRPC 使用基于二进制的 Protobuf 进行数据序列化和传输，相比基于文本的传输格式（如 JSON、XML），传输效率更高，性能更好。</li>\n<li>多语言支持：gRPC 支持多种编程语言，包括 C++, Java, Go, Python, JavaScript 等，使得不同语言的服务可以相互调用，方便构建跨平台、跨语言的分布式系统。</li>\n<li>强大的IDL：通过 Protobuf 定义接口和消息类型，提供了强类型的接口定义和数据结构，使得接口和数据的描述更加清晰和灵活。</li>\n<li>支持流式通信：gRPC 支持基于流的请求和响应，使得客户端和服务器之间可以实现双向流式通信，适用于实时数据传输、长连接等场景。</li>\n<li>可插拔的拦截器：gRPC 提供拦截器机制，可以在请求和响应的不同阶段进行自定义操作，如认证、日志记录、流量控制等。</li>\n<li>支持多种传输协议：gRPC 默认使用 HTTP&#x2F;2 作为底层传输协议，提供了高效的、多路复用的、双向通信的传输能力。同时也支持使用其他的传输协议，如 gRPC-Web 用于浏览器环境下的通信。</li>\n</ol>\n<h3 id=\"grpc环境搭建\"><a href=\"#grpc环境搭建\" class=\"headerlink\" title=\"grpc环境搭建\"></a>grpc环境搭建</h3><ol>\n<li>安装<code>grpc</code>库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google.golang.org/grpc@v1.37</span><br></pre></td></tr></table></figure></li>\n<li>安装<code>protoc-gen-go-grpc</code>库<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure></li>\n<li>生成代码<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --proto_path=protos --go-grpc_out=./../ service.proto</span><br></pre></td></tr></table></figure></li>\n<li>测试</li>\n</ol>\n<ul>\n<li><p>定义消息类型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// models.proto 添加请求响应</span></span><br><span class=\"line\"><span class=\"comment\">// 请求参数</span></span><br><span class=\"line\">message ProdRequest &#123;</span><br><span class=\"line\">    <span class=\"type\">int32</span> id = <span class=\"number\">1</span>; <span class=\"comment\">// 商品ID</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应结果</span></span><br><span class=\"line\">message ProdResponse &#123;</span><br><span class=\"line\">    ProdModel result = <span class=\"number\">1</span>; <span class=\"comment\">// 商品信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>定义服务</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// service.proto</span></span><br><span class=\"line\">syntax=<span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package = <span class=\"string\">&quot;go-grpc/src/pbfiles&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;models.proto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">service ProdService &#123;</span><br><span class=\"line\">    rpc GetProd(ProdRequest) returns (ProdResponse);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用<code>protoc</code>工具根据<code>.proto</code>文件生成相应的代码文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --proto_path=protos --go_out=./../ models.proto</span><br><span class=\"line\">protoc --proto_path=protos --go-grpc_out=./../ service.proto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写<code>service</code>层</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// services/ProdService.go</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ProdService <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpbfiles.UnimplementedProdServiceServer <span class=\"comment\">// 不建议直接使用默认实现的GetProd方法，自行实现GetProd方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewProdService</span><span class=\"params\">()</span></span> *ProdService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ProdService&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ProdService)</span></span> GetProd(ctx context.Context, req *pbfiles.ProdRequest) (*pbfiles.ProdResponse, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\trsp := &amp;pbfiles.ProdResponse&#123;</span><br><span class=\"line\">\t\tResult: &amp;pbfiles.ProdModel&#123;</span><br><span class=\"line\">\t\t\tId:   req.Id,</span><br><span class=\"line\">\t\t\tName: <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rsp, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>server端</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个 gRPC 服务器实例</span></span><br><span class=\"line\">\tmyserver := grpc.NewServer()</span><br><span class=\"line\">\t<span class=\"comment\">// 注册你的服务实现到服务器上</span></span><br><span class=\"line\">\tpbfiles.RegisterProdServiceServer(myserver, services.NewProdService())</span><br><span class=\"line\">\t<span class=\"comment\">// 监听8080</span></span><br><span class=\"line\">\tlis, _ := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;:8080&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 启动服务器，监听指定的网络地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := myserver.Serve(lis); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>客户端</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法</span></span><br><span class=\"line\">\t<span class=\"comment\">// 不校验证书</span></span><br><span class=\"line\">\tclient, err := grpc.DialContext(context.Background(), <span class=\"string\">&quot;localhost:8080&quot;</span>, grpc.WithInsecure())</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treq := &amp;pbfiles.ProdRequest&#123;Id: <span class=\"number\">1002</span>&#125;</span><br><span class=\"line\">\tres := &amp;pbfiles.ProdResponse&#123;&#125;</span><br><span class=\"line\">\terr = client.Invoke(context.Background(), <span class=\"string\">&quot;/ProdService/GetProd&quot;</span>, req, res)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(res.Result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"证书认证\"><a href=\"#证书认证\" class=\"headerlink\" title=\"证书认证\"></a>证书认证</h3><p>SAN (Subject Alternative Name) 证书是一种用于加密通信的数字证书，其中包含了多个主体名称（Subject Name）的备用选项。SAN 证书可以用于解决传统的 X.509 数字证书中的一个限制，即每个证书只能对应一个主体名称。</p>\n<p>传统的 X.509 数字证书在签发时需要指定一个主体名称，例如域名或者 IP 地址。而当一个服务器需要支持多个域名或者 IP 地址时，传统证书的方式就无法满足需求。这时就可以使用 SAN 证书来解决这个问题。</p>\n<p>SAN 证书允许在一个证书中指定多个主体名称，可以是域名、IP 地址或者其他标识符。这样，服务器在进行加密通信时就可以使用同一个证书，同时支持多个主体名称的验证。</p>\n<p>SAN 证书的主要优点是灵活性和可扩展性。它可以适应多种场景，例如多域名共享同一个证书、多个子域名、多个 IP 地址等。SAN 证书在实际应用中广泛使用，特别是在虚拟主机环境或者多站点共享证书的情况下。</p>\n<p>总结而言，SAN 证书是一种具有多个主体名称备选项的数字证书，用于解决传统证书单一主体名称的限制，提供更灵活和可扩展的加密通信解决方案。</p>\n<h4 id=\"双向认证\"><a href=\"#双向认证\" class=\"headerlink\" title=\"双向认证\"></a>双向认证</h4><ol>\n<li><code>ca</code>根证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成私钥文件</span></span><br><span class=\"line\">openssl genrsa -out ca.key 4096</span><br><span class=\"line\"><span class=\"comment\"># 生成ca根证书</span></span><br><span class=\"line\">openssl req -new -x509 -days 3650 -key ca.key -out ca.crt</span><br></pre></td></tr></table></figure></li>\n<li><code>SAN</code>证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#修改openssl.cnf配置，配置文件位于/etc/pki/tls/openssl.cnf</span></span><br><span class=\"line\"><span class=\"comment\">#在[ req ]下新增</span></span><br><span class=\"line\">req_extensions = v3_req</span><br><span class=\"line\"><span class=\"comment\">#[ v3_req ]新增</span></span><br><span class=\"line\">subjectAltName = @alt_names</span><br><span class=\"line\"></span><br><span class=\"line\">[ alt_names ]</span><br><span class=\"line\">DNS.1 = *.grpc.dengnanhao.com</span><br><span class=\"line\">DNS.2 = *.dengnanhao.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#同步修改window本地hosts文件添加</span></span><br><span class=\"line\">127.0.0.1 test.grpc.dengnanhao.com</span><br></pre></td></tr></table></figure></li>\n<li>服务端证书</li>\n</ol>\n<ul>\n<li>生成私钥<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genpkey -algorithm RSA -out server.key</span><br></pre></td></tr></table></figure></li>\n<li>生成证书请求文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -nodes -key server.key -out server.csr -days 3650 -subj <span class=\"string\">&quot;/C=cn/OU=dengnanhao/O=dengnanhao/CN=test.grpc.dengnanhao.com&quot;</span> -config ./openssl.cnf -extensions v3_req</span><br><span class=\"line\"><span class=\"comment\"># 查看请求文件DNS是否正确</span></span><br><span class=\"line\">openssl req -noout -text -<span class=\"keyword\">in</span> server.csr</span><br></pre></td></tr></table></figure></li>\n<li>签发证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -days 3650 -<span class=\"keyword\">in</span> server.csr -out server.pem -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -extfile ./openssl.cnf -extensions v3_req</span><br></pre></td></tr></table></figure></li>\n<li>将生成的<code>server.pem</code> <code>server.key</code>添加至项目目录 <code>certs</code></li>\n<li>修改服务端代码<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建证书</span></span><br><span class=\"line\">\tcreds, err := credentials.NewServerTLSFromFile(<span class=\"string\">&quot;certs/server.pem&quot;</span>, <span class=\"string\">&quot;certs/server.key&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个 gRPC 服务器实例</span></span><br><span class=\"line\">\tmyserver := grpc.NewServer(grpc.Creds(creds))</span><br><span class=\"line\">\t<span class=\"comment\">// 注册你的服务实现到服务器上</span></span><br><span class=\"line\">\tpbfiles.RegisterProdServiceServer(myserver, services.NewProdService())</span><br><span class=\"line\">\t<span class=\"comment\">// 监听8080</span></span><br><span class=\"line\">\tlis, _ := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;:8080&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 启动服务器，监听指定的网络地址</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := myserver.Serve(lis); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修改客户端代码<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tcreds, err := credentials.NewClientTLSFromFile(<span class=\"string\">&quot;certs/server.pem&quot;</span>, <span class=\"string\">&quot;test.grpc.dengnanhao.com&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法</span></span><br><span class=\"line\">\t<span class=\"comment\">// 校验证书 grpc.WithTransportCredentials(creds)</span></span><br><span class=\"line\">\tclient, err := grpc.DialContext(context.Background(), <span class=\"string\">&quot;test.grpc.dengnanhao.com:8080&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treq := &amp;pbfiles.ProdRequest&#123;Id: <span class=\"number\">1002</span>&#125;</span><br><span class=\"line\">\tres := &amp;pbfiles.ProdResponse&#123;&#125;</span><br><span class=\"line\">\tclient.Invoke(context.Background(), <span class=\"string\">&quot;/ProdService/GetProd&quot;</span>, req, res)</span><br><span class=\"line\">\tfmt.Println(res.Result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>客户端证书</li>\n</ol>\n<ul>\n<li><p>生成私钥</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genpkey -algorithm RSA -out client.key</span><br></pre></td></tr></table></figure></li>\n<li><p>生成证书请求文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl req -new -key client.key -subj <span class=\"string\">&quot;/CN=myclient&quot;</span> -out client.csr</span><br></pre></td></tr></table></figure></li>\n<li><p>签发证书</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl x509 -req -<span class=\"keyword\">in</span> client.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial -days 3650 -out client.crt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改客户端代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 可以作为全局变量，放入一个启动文件中</span></span><br><span class=\"line\">\tcert, err := tls.LoadX509KeyPair(<span class=\"string\">&quot;certs/client.crt&quot;</span>, <span class=\"string\">&quot;certs/client.key&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcertPool := x509.NewCertPool()</span><br><span class=\"line\">\tca, err := ioutil.ReadFile(<span class=\"string\">&quot;certs/ca.crt&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcertPool.AppendCertsFromPEM(ca)</span><br><span class=\"line\">\tcreds := credentials.NewTLS(&amp;tls.Config&#123;</span><br><span class=\"line\">\t\tCertificates: []tls.Certificate&#123;cert&#125;,</span><br><span class=\"line\">\t\tServerName:   <span class=\"string\">&quot;test.grpc.dengnanhao.com&quot;</span>,</span><br><span class=\"line\">\t\tRootCAs:      certPool,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// grpc.DialContext 是 gRPC 客户端用于建立与 gRPC 服务器的连接的方法</span></span><br><span class=\"line\">\t<span class=\"comment\">// 校验证书 grpc.WithTransportCredentials(creds)</span></span><br><span class=\"line\">\tclient, e := grpc.DialContext(context.Background(), <span class=\"string\">&quot;test.grpc.dengnanhao.com:8080&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(e)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treq := &amp;pbfiles.ProdRequest&#123;Id: <span class=\"number\">1002</span>&#125;</span><br><span class=\"line\">\tres := &amp;pbfiles.ProdResponse&#123;&#125;</span><br><span class=\"line\">\terr = client.Invoke(context.Background(), <span class=\"string\">&quot;/ProdService/GetProd&quot;</span>, req, res)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(res.Result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"CentOS 的内核升级","excerpt":"因为需要安装docker，对linux内核版本有所要求，本文记录在centos7系统中升级linux内核的方法，仅供参考","_content":"\n要将 CentOS 的内核升级，您可以按照以下步骤进行操作：\n1. 在进行任何内核升级之前，确保您的系统已经进行了完整的备份，以防出现意外情况。\n2. 在 CentOS 7 上，您可以使用 ELRepo 仓库来获取更新的内核版本。ELRepo 是一个社区维护的第三方软件仓库，提供了新的内核版本。\n- 首先，安装 ELRepo 仓库的 RPM 包。打开终端并运行以下命令：\n```bash\nsudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\nsudo rpm -Uvh https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm\n```\n- 安装新的内核。运行以下命令：\n```bash\nsudo yum --enablerepo=elrepo-kernel install kernel-ml\n```\n此命令将安装最新的稳定版内核。如果您想要安装特定版本的内核，可以在命令末尾指定具体的内核版本号，例如 `kernel-ml-4.19.0`\n- 配置 GRUB 引导加载程序。运行以下命令：\n```bash\nsudo grub2-mkconfig -o /boot/grub2/grub.cfg\n```\n此命令将重新生成 GRUB 配置文件，以包含新安装的内核。\n- 重启系统。运行以下命令来重启系统：\n```bash\nsudo reboot\n```\n系统重启后，GRUB 将显示可用的内核选项。选择新安装的内核并启动系统。\n","source":"_posts/linux/centos-core-up.md","raw":"---\ntitle:  CentOS 的内核升级\ntags: [\"linux\", \"centos\", \"docker\"]\nexcerpt: 因为需要安装docker，对linux内核版本有所要求，本文记录在centos7系统中升级linux内核的方法，仅供参考\n---\n\n要将 CentOS 的内核升级，您可以按照以下步骤进行操作：\n1. 在进行任何内核升级之前，确保您的系统已经进行了完整的备份，以防出现意外情况。\n2. 在 CentOS 7 上，您可以使用 ELRepo 仓库来获取更新的内核版本。ELRepo 是一个社区维护的第三方软件仓库，提供了新的内核版本。\n- 首先，安装 ELRepo 仓库的 RPM 包。打开终端并运行以下命令：\n```bash\nsudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\nsudo rpm -Uvh https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm\n```\n- 安装新的内核。运行以下命令：\n```bash\nsudo yum --enablerepo=elrepo-kernel install kernel-ml\n```\n此命令将安装最新的稳定版内核。如果您想要安装特定版本的内核，可以在命令末尾指定具体的内核版本号，例如 `kernel-ml-4.19.0`\n- 配置 GRUB 引导加载程序。运行以下命令：\n```bash\nsudo grub2-mkconfig -o /boot/grub2/grub.cfg\n```\n此命令将重新生成 GRUB 配置文件，以包含新安装的内核。\n- 重启系统。运行以下命令来重启系统：\n```bash\nsudo reboot\n```\n系统重启后，GRUB 将显示可用的内核选项。选择新安装的内核并启动系统。\n","slug":"linux/centos-core-up","published":1,"date":"2023-05-30T07:22:28.689Z","updated":"2023-05-30T07:30:28.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli9ymnnb0000tkuphb5vf8jf","content":"<p>要将 CentOS 的内核升级，您可以按照以下步骤进行操作：</p>\n<ol>\n<li>在进行任何内核升级之前，确保您的系统已经进行了完整的备份，以防出现意外情况。</li>\n<li>在 CentOS 7 上，您可以使用 ELRepo 仓库来获取更新的内核版本。ELRepo 是一个社区维护的第三方软件仓库，提供了新的内核版本。</li>\n</ol>\n<ul>\n<li>首先，安装 ELRepo 仓库的 RPM 包。打开终端并运行以下命令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class=\"line\">sudo rpm -Uvh https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure></li>\n<li>安装新的内核。运行以下命令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum --enablerepo=elrepo-kernel install kernel-ml</span><br></pre></td></tr></table></figure>\n此命令将安装最新的稳定版内核。如果您想要安装特定版本的内核，可以在命令末尾指定具体的内核版本号，例如 <code>kernel-ml-4.19.0</code></li>\n<li>配置 GRUB 引导加载程序。运行以下命令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>\n此命令将重新生成 GRUB 配置文件，以包含新安装的内核。</li>\n<li>重启系统。运行以下命令来重启系统：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo reboot</span><br></pre></td></tr></table></figure>\n系统重启后，GRUB 将显示可用的内核选项。选择新安装的内核并启动系统。</li>\n</ul>\n","site":{"data":{}},"more":"<p>要将 CentOS 的内核升级，您可以按照以下步骤进行操作：</p>\n<ol>\n<li>在进行任何内核升级之前，确保您的系统已经进行了完整的备份，以防出现意外情况。</li>\n<li>在 CentOS 7 上，您可以使用 ELRepo 仓库来获取更新的内核版本。ELRepo 是一个社区维护的第三方软件仓库，提供了新的内核版本。</li>\n</ol>\n<ul>\n<li>首先，安装 ELRepo 仓库的 RPM 包。打开终端并运行以下命令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class=\"line\">sudo rpm -Uvh https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure></li>\n<li>安装新的内核。运行以下命令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum --enablerepo=elrepo-kernel install kernel-ml</span><br></pre></td></tr></table></figure>\n此命令将安装最新的稳定版内核。如果您想要安装特定版本的内核，可以在命令末尾指定具体的内核版本号，例如 <code>kernel-ml-4.19.0</code></li>\n<li>配置 GRUB 引导加载程序。运行以下命令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>\n此命令将重新生成 GRUB 配置文件，以包含新安装的内核。</li>\n<li>重启系统。运行以下命令来重启系统：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo reboot</span><br></pre></td></tr></table></figure>\n系统重启后，GRUB 将显示可用的内核选项。选择新安装的内核并启动系统。</li>\n</ul>\n"},{"title":"VMware虚拟机静态IP配置","excerpt":"虚拟机NAT模式网络配置","_content":"# VMware静态IP配置\n本教程主要说明在windows虚拟机centos7.x系统上如何配置网络连接NAT模式\n\n## 环境准备\n- VMware-workstation-full-16.2.3-19376536\n- CentOS-7-x86_64-DVD-2009.iso\n- window11\n\n## 详细配置\n\n1. 在vmware中安装centos（自行安装），网络连接选择NAT模式。\n2. vmware虚拟机网络设置\n- 在window11中搜索【虚拟网络编辑器】\n\n![vmware虚拟机网络设置](../../images/linux/vmware-1.png)\n\n- 第一步：点击【更改设置】进入编辑模式，选择或者是【添加】虚拟网络\n\n- 第二步：选择【NAT模式】，然后点击【NAT设置】记住【网关IP】，网关IP需要在子网IP段下\n\n![NAT设置](../../images/linux/nat.png)\n\n- 第三步：点击【DHCP设置】，记住【起始IP地址】、【结束IP地址】\n\n![DHCP设置](../../images/linux/dhcp.png)\n\n- 第四步：勾选【使用本地DHCP服务将IP地址分配给虚拟机】\n\n3. 配置宿主机的网络与VMnet2共享\n- 设置位置【控制面板>网络和 Internet>网络连接】\n- 右键点击宿主机网络选择【属性】，按下图设置\n\n![网络共享设置](../../images/linux/network.png)\n\n4. 右击虚拟机名称，选择【设置】更改【网络适配器】选择【自定义】中的VMnet2\n\n![网络适配器](../../images/linux/setting.png)\n\n5. 设置静态IP地址\n- 打开虚拟机进入centos系统\n- 配置网络\n```bash\nvim  /etc/sysconfig/network-scripts/ifcfg-ens33\n```\n\n![配置网络](../../images/linux/static-ip.png)\n- 设置`BOOTPROTO=static`\n- 添加IP地址、网关和dns地址\n```bash\n#ip地址需要设置成【DHCP设置】中的【起始IP】和【终止IP】之间\nIPADDR=192.168.150.130\nNETMASK=255.255.255.0\n#gateway 【NAT设置】中的网关IP\nGATEWAY=192.168.150.2\n#dns\nDNS1=114.114.114.114\nDNS2=8.8.8.8\n```\n\n6. 重启网络服务\n```bash\nsystemctl restart network\n```","source":"_posts/linux/vmware-network.md","raw":"---\ntitle: VMware虚拟机静态IP配置\ntags: [\"linux\", \"centos\", \"vmware\", \"network\"]\nexcerpt: 虚拟机NAT模式网络配置\n---\n# VMware静态IP配置\n本教程主要说明在windows虚拟机centos7.x系统上如何配置网络连接NAT模式\n\n## 环境准备\n- VMware-workstation-full-16.2.3-19376536\n- CentOS-7-x86_64-DVD-2009.iso\n- window11\n\n## 详细配置\n\n1. 在vmware中安装centos（自行安装），网络连接选择NAT模式。\n2. vmware虚拟机网络设置\n- 在window11中搜索【虚拟网络编辑器】\n\n![vmware虚拟机网络设置](../../images/linux/vmware-1.png)\n\n- 第一步：点击【更改设置】进入编辑模式，选择或者是【添加】虚拟网络\n\n- 第二步：选择【NAT模式】，然后点击【NAT设置】记住【网关IP】，网关IP需要在子网IP段下\n\n![NAT设置](../../images/linux/nat.png)\n\n- 第三步：点击【DHCP设置】，记住【起始IP地址】、【结束IP地址】\n\n![DHCP设置](../../images/linux/dhcp.png)\n\n- 第四步：勾选【使用本地DHCP服务将IP地址分配给虚拟机】\n\n3. 配置宿主机的网络与VMnet2共享\n- 设置位置【控制面板>网络和 Internet>网络连接】\n- 右键点击宿主机网络选择【属性】，按下图设置\n\n![网络共享设置](../../images/linux/network.png)\n\n4. 右击虚拟机名称，选择【设置】更改【网络适配器】选择【自定义】中的VMnet2\n\n![网络适配器](../../images/linux/setting.png)\n\n5. 设置静态IP地址\n- 打开虚拟机进入centos系统\n- 配置网络\n```bash\nvim  /etc/sysconfig/network-scripts/ifcfg-ens33\n```\n\n![配置网络](../../images/linux/static-ip.png)\n- 设置`BOOTPROTO=static`\n- 添加IP地址、网关和dns地址\n```bash\n#ip地址需要设置成【DHCP设置】中的【起始IP】和【终止IP】之间\nIPADDR=192.168.150.130\nNETMASK=255.255.255.0\n#gateway 【NAT设置】中的网关IP\nGATEWAY=192.168.150.2\n#dns\nDNS1=114.114.114.114\nDNS2=8.8.8.8\n```\n\n6. 重启网络服务\n```bash\nsystemctl restart network\n```","slug":"linux/vmware-network","published":1,"date":"2023-05-30T07:22:28.701Z","updated":"2023-05-30T07:38:23.528Z","_id":"cli9ymnnu0006tkup7ci47rkf","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"VMware静态IP配置\"><a href=\"#VMware静态IP配置\" class=\"headerlink\" title=\"VMware静态IP配置\"></a>VMware静态IP配置</h1><p>本教程主要说明在windows虚拟机centos7.x系统上如何配置网络连接NAT模式</p>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>VMware-workstation-full-16.2.3-19376536</li>\n<li>CentOS-7-x86_64-DVD-2009.iso</li>\n<li>window11</li>\n</ul>\n<h2 id=\"详细配置\"><a href=\"#详细配置\" class=\"headerlink\" title=\"详细配置\"></a>详细配置</h2><ol>\n<li>在vmware中安装centos（自行安装），网络连接选择NAT模式。</li>\n<li>vmware虚拟机网络设置</li>\n</ol>\n<ul>\n<li>在window11中搜索【虚拟网络编辑器】</li>\n</ul>\n<p><img src=\"/blog/../../images/linux/vmware-1.png\" alt=\"vmware虚拟机网络设置\"></p>\n<ul>\n<li><p>第一步：点击【更改设置】进入编辑模式，选择或者是【添加】虚拟网络</p>\n</li>\n<li><p>第二步：选择【NAT模式】，然后点击【NAT设置】记住【网关IP】，网关IP需要在子网IP段下</p>\n</li>\n</ul>\n<p><img src=\"/blog/../../images/linux/nat.png\" alt=\"NAT设置\"></p>\n<ul>\n<li>第三步：点击【DHCP设置】，记住【起始IP地址】、【结束IP地址】</li>\n</ul>\n<p><img src=\"/blog/../../images/linux/dhcp.png\" alt=\"DHCP设置\"></p>\n<ul>\n<li>第四步：勾选【使用本地DHCP服务将IP地址分配给虚拟机】</li>\n</ul>\n<ol start=\"3\">\n<li>配置宿主机的网络与VMnet2共享</li>\n</ol>\n<ul>\n<li>设置位置【控制面板&gt;网络和 Internet&gt;网络连接】</li>\n<li>右键点击宿主机网络选择【属性】，按下图设置</li>\n</ul>\n<p><img src=\"/blog/../../images/linux/network.png\" alt=\"网络共享设置\"></p>\n<ol start=\"4\">\n<li>右击虚拟机名称，选择【设置】更改【网络适配器】选择【自定义】中的VMnet2</li>\n</ol>\n<p><img src=\"/blog/../../images/linux/setting.png\" alt=\"网络适配器\"></p>\n<ol start=\"5\">\n<li>设置静态IP地址</li>\n</ol>\n<ul>\n<li>打开虚拟机进入centos系统</li>\n<li>配置网络<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim  /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"/blog/../../images/linux/static-ip.png\" alt=\"配置网络\"></p>\n<ul>\n<li>设置<code>BOOTPROTO=static</code></li>\n<li>添加IP地址、网关和dns地址<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#ip地址需要设置成【DHCP设置】中的【起始IP】和【终止IP】之间</span></span><br><span class=\"line\">IPADDR=192.168.150.130</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\"><span class=\"comment\">#gateway 【NAT设置】中的网关IP</span></span><br><span class=\"line\">GATEWAY=192.168.150.2</span><br><span class=\"line\"><span class=\"comment\">#dns</span></span><br><span class=\"line\">DNS1=114.114.114.114</span><br><span class=\"line\">DNS2=8.8.8.8</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"6\">\n<li>重启网络服务<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"more":"<h1 id=\"VMware静态IP配置\"><a href=\"#VMware静态IP配置\" class=\"headerlink\" title=\"VMware静态IP配置\"></a>VMware静态IP配置</h1><p>本教程主要说明在windows虚拟机centos7.x系统上如何配置网络连接NAT模式</p>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ul>\n<li>VMware-workstation-full-16.2.3-19376536</li>\n<li>CentOS-7-x86_64-DVD-2009.iso</li>\n<li>window11</li>\n</ul>\n<h2 id=\"详细配置\"><a href=\"#详细配置\" class=\"headerlink\" title=\"详细配置\"></a>详细配置</h2><ol>\n<li>在vmware中安装centos（自行安装），网络连接选择NAT模式。</li>\n<li>vmware虚拟机网络设置</li>\n</ol>\n<ul>\n<li>在window11中搜索【虚拟网络编辑器】</li>\n</ul>\n<p><img src=\"/blog/../../images/linux/vmware-1.png\" alt=\"vmware虚拟机网络设置\"></p>\n<ul>\n<li><p>第一步：点击【更改设置】进入编辑模式，选择或者是【添加】虚拟网络</p>\n</li>\n<li><p>第二步：选择【NAT模式】，然后点击【NAT设置】记住【网关IP】，网关IP需要在子网IP段下</p>\n</li>\n</ul>\n<p><img src=\"/blog/../../images/linux/nat.png\" alt=\"NAT设置\"></p>\n<ul>\n<li>第三步：点击【DHCP设置】，记住【起始IP地址】、【结束IP地址】</li>\n</ul>\n<p><img src=\"/blog/../../images/linux/dhcp.png\" alt=\"DHCP设置\"></p>\n<ul>\n<li>第四步：勾选【使用本地DHCP服务将IP地址分配给虚拟机】</li>\n</ul>\n<ol start=\"3\">\n<li>配置宿主机的网络与VMnet2共享</li>\n</ol>\n<ul>\n<li>设置位置【控制面板&gt;网络和 Internet&gt;网络连接】</li>\n<li>右键点击宿主机网络选择【属性】，按下图设置</li>\n</ul>\n<p><img src=\"/blog/../../images/linux/network.png\" alt=\"网络共享设置\"></p>\n<ol start=\"4\">\n<li>右击虚拟机名称，选择【设置】更改【网络适配器】选择【自定义】中的VMnet2</li>\n</ol>\n<p><img src=\"/blog/../../images/linux/setting.png\" alt=\"网络适配器\"></p>\n<ol start=\"5\">\n<li>设置静态IP地址</li>\n</ol>\n<ul>\n<li>打开虚拟机进入centos系统</li>\n<li>配置网络<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim  /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><img src=\"/blog/../../images/linux/static-ip.png\" alt=\"配置网络\"></p>\n<ul>\n<li>设置<code>BOOTPROTO=static</code></li>\n<li>添加IP地址、网关和dns地址<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#ip地址需要设置成【DHCP设置】中的【起始IP】和【终止IP】之间</span></span><br><span class=\"line\">IPADDR=192.168.150.130</span><br><span class=\"line\">NETMASK=255.255.255.0</span><br><span class=\"line\"><span class=\"comment\">#gateway 【NAT设置】中的网关IP</span></span><br><span class=\"line\">GATEWAY=192.168.150.2</span><br><span class=\"line\"><span class=\"comment\">#dns</span></span><br><span class=\"line\">DNS1=114.114.114.114</span><br><span class=\"line\">DNS2=8.8.8.8</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"6\">\n<li>重启网络服务<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart network</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Rancher2.x + k8s快速搭建集群环境","date":"2023-06-03T13:46:14.000Z","excerpt":"k8s集群环境搭建","_content":"\n# Rancher2.x + k8s快速搭建集群环境\n准备三台虚拟机一台master节点一台worker节点一台rancher节点\n\n## 准备工作\n1. rancher节点准备工作\n```bash\n#删除所有容器\ndocker stop $(docker ps -a -q)\n#删除所有容器\ndocker rm $(docker ps -a -q)\n\n#关闭防火墙\nsystemctl stop firewalld && systemctl disable firewalld\n\n#关闭 SELinux\nsetenforce 0\nsed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config\n\n#关闭swap\nswapoff -a\n\n#重启docker\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n#启动rancher2\nsudo docker run --privileged -d --restart=unless-stopped -p 80:80 -p 443:443 -v /home/dengnanhao/rancher:/var/lib/rancher  rancher/rancher:stable\n\n#访问rancher服务ip设置密码：rancher123456\n```","source":"_drafts/kubernetes/rancher2.md","raw":"---\ntitle: Rancher2.x + k8s快速搭建集群环境\ndate: 2023-06-03 21:46:14\ntags: [\"k8s\", \"架构\", \"集群\", \"运开\"]\nexcerpt: k8s集群环境搭建\n---\n\n# Rancher2.x + k8s快速搭建集群环境\n准备三台虚拟机一台master节点一台worker节点一台rancher节点\n\n## 准备工作\n1. rancher节点准备工作\n```bash\n#删除所有容器\ndocker stop $(docker ps -a -q)\n#删除所有容器\ndocker rm $(docker ps -a -q)\n\n#关闭防火墙\nsystemctl stop firewalld && systemctl disable firewalld\n\n#关闭 SELinux\nsetenforce 0\nsed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config\n\n#关闭swap\nswapoff -a\n\n#重启docker\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n\n#启动rancher2\nsudo docker run --privileged -d --restart=unless-stopped -p 80:80 -p 443:443 -v /home/dengnanhao/rancher:/var/lib/rancher  rancher/rancher:stable\n\n#访问rancher服务ip设置密码：rancher123456\n```","slug":"kubernetes/rancher2","published":0,"updated":"2023-06-03T10:40:31.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljjmba830001jctn6fm186o1","content":"<h1 id=\"Rancher2-x-k8s快速搭建集群环境\"><a href=\"#Rancher2-x-k8s快速搭建集群环境\" class=\"headerlink\" title=\"Rancher2.x + k8s快速搭建集群环境\"></a>Rancher2.x + k8s快速搭建集群环境</h1><p>准备三台虚拟机一台master节点一台worker节点一台rancher节点</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>rancher节点准备工作<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#删除所有容器</span></span><br><span class=\"line\">docker stop $(docker ps -a -q)</span><br><span class=\"line\"><span class=\"comment\">#删除所有容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> $(docker ps -a -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关闭防火墙</span></span><br><span class=\"line\">systemctl stop firewalld &amp;&amp; systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关闭 SELinux</span></span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/selinux/config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关闭swap</span></span><br><span class=\"line\">swapoff -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#重启docker</span></span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#启动rancher2</span></span><br><span class=\"line\">sudo docker run --privileged -d --restart=unless-stopped -p 80:80 -p 443:443 -v /home/dengnanhao/rancher:/var/lib/rancher  rancher/rancher:stable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#访问rancher服务ip设置密码：rancher123456</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"more":"<h1 id=\"Rancher2-x-k8s快速搭建集群环境\"><a href=\"#Rancher2-x-k8s快速搭建集群环境\" class=\"headerlink\" title=\"Rancher2.x + k8s快速搭建集群环境\"></a>Rancher2.x + k8s快速搭建集群环境</h1><p>准备三台虚拟机一台master节点一台worker节点一台rancher节点</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>rancher节点准备工作<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#删除所有容器</span></span><br><span class=\"line\">docker stop $(docker ps -a -q)</span><br><span class=\"line\"><span class=\"comment\">#删除所有容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> $(docker ps -a -q)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关闭防火墙</span></span><br><span class=\"line\">systemctl stop firewalld &amp;&amp; systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关闭 SELinux</span></span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/selinux/config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关闭swap</span></span><br><span class=\"line\">swapoff -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#重启docker</span></span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl restart docker</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#启动rancher2</span></span><br><span class=\"line\">sudo docker run --privileged -d --restart=unless-stopped -p 80:80 -p 443:443 -v /home/dengnanhao/rancher:/var/lib/rancher  rancher/rancher:stable</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#访问rancher服务ip设置密码：rancher123456</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Nodejs架构","excerpt":"了解nodejs的整体架构，才能更好的运用nodejs。笔记主要是介绍nodejs的核心架构组成不包括具体标准库的使用及业务代码。","_content":"\n# Nodejs基础架构\n![Nodejs三层架构图](/images/node/framework/framework.png)\n\n## Node标准库\nNode标准库里面的内容全部是由js实现，主要是为业务程序提供了当前可以直接调用的库，例如：fs、path、http等。\n\n## Node Bindings\nNode Bindings(主要由C/C++实现)，是沟通js和C++的桥梁，主要是封装V8引擎和Libuv库的细节向上层提供基础API服务。\n\n举个例子：C/C++ 实现了一个 http_parser 的库，非常高效，但是前端开发人员只会写 JavaScript，直接调用这个库肯定是不能成功的，所以就需要一个中间的桥梁。于是 Node.js 的作者就用 C++ 对 http_parser 库进行封装，使它符合某些要求（比如统一数据类型等），封装的文件叫做 http_parser_bindings.cpp。同时 Node.js 提供的编译工具可以将其编译为.node文件。这样 JavaScript 代码可以直接 require 这个 .node 文件，这样 JavaScript 就能调用 C++ 库。\n\n中间的桥梁就是 binding，由于 Node.js 提供了很多 binding，多个 binding 就构成了 Node 基本架构中的 Node bindings 了。有了这个 Node Bindings 后，JavaScript 和 C++ 就可以进行一些相互调用的操作，进而实现功能上的一些通信。这里有官网提供的示例，便于大家理解 JS 和 C++ 是如何进行通信的：[JS 调用 C++ 代码](https://nodejs.cn/api/addons.html#addons_function_arguments)、[C++ 调用 JS 回调](https://nodejs.cn/api/addons.html#addons_callbacks)。\n\n## 底层\n- V8:执行js代码，提供桥梁接口。将js调用的模块功能转化为C/C++所编写的函数，这个转换的过程就是由V8引擎来完成的。\n- libuv：是专门为 Node.js 开发的一个封装库，提供跨平台的异步 I/O 能力及事件循环、事件队列。\n- C-ares：提供了异步处理 DNS 相关的能力。\n- http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。\n\n# Nodejs工作流程\n![Nodejs工作流程图](/images/node/framework/nodejs_worker.png)","source":"_posts/node/framework.md","raw":"---\ntitle:  Nodejs架构\ntags: [\"nodejs\", \"framework\"]\nexcerpt: 了解nodejs的整体架构，才能更好的运用nodejs。笔记主要是介绍nodejs的核心架构组成不包括具体标准库的使用及业务代码。\n---\n\n# Nodejs基础架构\n![Nodejs三层架构图](/images/node/framework/framework.png)\n\n## Node标准库\nNode标准库里面的内容全部是由js实现，主要是为业务程序提供了当前可以直接调用的库，例如：fs、path、http等。\n\n## Node Bindings\nNode Bindings(主要由C/C++实现)，是沟通js和C++的桥梁，主要是封装V8引擎和Libuv库的细节向上层提供基础API服务。\n\n举个例子：C/C++ 实现了一个 http_parser 的库，非常高效，但是前端开发人员只会写 JavaScript，直接调用这个库肯定是不能成功的，所以就需要一个中间的桥梁。于是 Node.js 的作者就用 C++ 对 http_parser 库进行封装，使它符合某些要求（比如统一数据类型等），封装的文件叫做 http_parser_bindings.cpp。同时 Node.js 提供的编译工具可以将其编译为.node文件。这样 JavaScript 代码可以直接 require 这个 .node 文件，这样 JavaScript 就能调用 C++ 库。\n\n中间的桥梁就是 binding，由于 Node.js 提供了很多 binding，多个 binding 就构成了 Node 基本架构中的 Node bindings 了。有了这个 Node Bindings 后，JavaScript 和 C++ 就可以进行一些相互调用的操作，进而实现功能上的一些通信。这里有官网提供的示例，便于大家理解 JS 和 C++ 是如何进行通信的：[JS 调用 C++ 代码](https://nodejs.cn/api/addons.html#addons_function_arguments)、[C++ 调用 JS 回调](https://nodejs.cn/api/addons.html#addons_callbacks)。\n\n## 底层\n- V8:执行js代码，提供桥梁接口。将js调用的模块功能转化为C/C++所编写的函数，这个转换的过程就是由V8引擎来完成的。\n- libuv：是专门为 Node.js 开发的一个封装库，提供跨平台的异步 I/O 能力及事件循环、事件队列。\n- C-ares：提供了异步处理 DNS 相关的能力。\n- http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。\n\n# Nodejs工作流程\n![Nodejs工作流程图](/images/node/framework/nodejs_worker.png)","slug":"node/framework","published":1,"date":"2023-07-01T02:22:18.553Z","updated":"2023-07-01T16:56:46.125Z","_id":"cljjmba890006jctn6quz3wp8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Nodejs基础架构\"><a href=\"#Nodejs基础架构\" class=\"headerlink\" title=\"Nodejs基础架构\"></a>Nodejs基础架构</h1><p><img src=\"/blog/images/node/framework/framework.png\" alt=\"Nodejs三层架构图\"></p>\n<h2 id=\"Node标准库\"><a href=\"#Node标准库\" class=\"headerlink\" title=\"Node标准库\"></a>Node标准库</h2><p>Node标准库里面的内容全部是由js实现，主要是为业务程序提供了当前可以直接调用的库，例如：fs、path、http等。</p>\n<h2 id=\"Node-Bindings\"><a href=\"#Node-Bindings\" class=\"headerlink\" title=\"Node Bindings\"></a>Node Bindings</h2><p>Node Bindings(主要由C&#x2F;C++实现)，是沟通js和C++的桥梁，主要是封装V8引擎和Libuv库的细节向上层提供基础API服务。</p>\n<p>举个例子：C&#x2F;C++ 实现了一个 http_parser 的库，非常高效，但是前端开发人员只会写 JavaScript，直接调用这个库肯定是不能成功的，所以就需要一个中间的桥梁。于是 Node.js 的作者就用 C++ 对 http_parser 库进行封装，使它符合某些要求（比如统一数据类型等），封装的文件叫做 http_parser_bindings.cpp。同时 Node.js 提供的编译工具可以将其编译为.node文件。这样 JavaScript 代码可以直接 require 这个 .node 文件，这样 JavaScript 就能调用 C++ 库。</p>\n<p>中间的桥梁就是 binding，由于 Node.js 提供了很多 binding，多个 binding 就构成了 Node 基本架构中的 Node bindings 了。有了这个 Node Bindings 后，JavaScript 和 C++ 就可以进行一些相互调用的操作，进而实现功能上的一些通信。这里有官网提供的示例，便于大家理解 JS 和 C++ 是如何进行通信的：<a href=\"https://nodejs.cn/api/addons.html#addons_function_arguments\">JS 调用 C++ 代码</a>、<a href=\"https://nodejs.cn/api/addons.html#addons_callbacks\">C++ 调用 JS 回调</a>。</p>\n<h2 id=\"底层\"><a href=\"#底层\" class=\"headerlink\" title=\"底层\"></a>底层</h2><ul>\n<li>V8:执行js代码，提供桥梁接口。将js调用的模块功能转化为C&#x2F;C++所编写的函数，这个转换的过程就是由V8引擎来完成的。</li>\n<li>libuv：是专门为 Node.js 开发的一个封装库，提供跨平台的异步 I&#x2F;O 能力及事件循环、事件队列。</li>\n<li>C-ares：提供了异步处理 DNS 相关的能力。</li>\n<li>http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。</li>\n</ul>\n<h1 id=\"Nodejs工作流程\"><a href=\"#Nodejs工作流程\" class=\"headerlink\" title=\"Nodejs工作流程\"></a>Nodejs工作流程</h1><p><img src=\"/blog/images/node/framework/nodejs_worker.png\" alt=\"Nodejs工作流程图\"></p>\n","site":{"data":{}},"more":"<h1 id=\"Nodejs基础架构\"><a href=\"#Nodejs基础架构\" class=\"headerlink\" title=\"Nodejs基础架构\"></a>Nodejs基础架构</h1><p><img src=\"/blog/images/node/framework/framework.png\" alt=\"Nodejs三层架构图\"></p>\n<h2 id=\"Node标准库\"><a href=\"#Node标准库\" class=\"headerlink\" title=\"Node标准库\"></a>Node标准库</h2><p>Node标准库里面的内容全部是由js实现，主要是为业务程序提供了当前可以直接调用的库，例如：fs、path、http等。</p>\n<h2 id=\"Node-Bindings\"><a href=\"#Node-Bindings\" class=\"headerlink\" title=\"Node Bindings\"></a>Node Bindings</h2><p>Node Bindings(主要由C&#x2F;C++实现)，是沟通js和C++的桥梁，主要是封装V8引擎和Libuv库的细节向上层提供基础API服务。</p>\n<p>举个例子：C&#x2F;C++ 实现了一个 http_parser 的库，非常高效，但是前端开发人员只会写 JavaScript，直接调用这个库肯定是不能成功的，所以就需要一个中间的桥梁。于是 Node.js 的作者就用 C++ 对 http_parser 库进行封装，使它符合某些要求（比如统一数据类型等），封装的文件叫做 http_parser_bindings.cpp。同时 Node.js 提供的编译工具可以将其编译为.node文件。这样 JavaScript 代码可以直接 require 这个 .node 文件，这样 JavaScript 就能调用 C++ 库。</p>\n<p>中间的桥梁就是 binding，由于 Node.js 提供了很多 binding，多个 binding 就构成了 Node 基本架构中的 Node bindings 了。有了这个 Node Bindings 后，JavaScript 和 C++ 就可以进行一些相互调用的操作，进而实现功能上的一些通信。这里有官网提供的示例，便于大家理解 JS 和 C++ 是如何进行通信的：<a href=\"https://nodejs.cn/api/addons.html#addons_function_arguments\">JS 调用 C++ 代码</a>、<a href=\"https://nodejs.cn/api/addons.html#addons_callbacks\">C++ 调用 JS 回调</a>。</p>\n<h2 id=\"底层\"><a href=\"#底层\" class=\"headerlink\" title=\"底层\"></a>底层</h2><ul>\n<li>V8:执行js代码，提供桥梁接口。将js调用的模块功能转化为C&#x2F;C++所编写的函数，这个转换的过程就是由V8引擎来完成的。</li>\n<li>libuv：是专门为 Node.js 开发的一个封装库，提供跨平台的异步 I&#x2F;O 能力及事件循环、事件队列。</li>\n<li>C-ares：提供了异步处理 DNS 相关的能力。</li>\n<li>http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。</li>\n</ul>\n<h1 id=\"Nodejs工作流程\"><a href=\"#Nodejs工作流程\" class=\"headerlink\" title=\"Nodejs工作流程\"></a>Nodejs工作流程</h1><p><img src=\"/blog/images/node/framework/nodejs_worker.png\" alt=\"Nodejs工作流程图\"></p>\n"},{"title":"linux-base","excerpt":"linux基础知识及常用命令总结","_content":"\n\n","source":"_drafts/linux-base.md","raw":"---\ntitle: linux-base\ntags: [\"linux\"]\nexcerpt: linux基础知识及常用命令总结\n---\n\n\n","slug":"linux-base","published":0,"date":"2023-09-01T15:01:49.581Z","updated":"2023-09-01T15:03:07.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0qb85o000020tnbt31dzfa","content":"","site":{"data":{}},"more":""},{"title":"从零搭建gitlab ci/cd流水线","date":"2023-07-15T01:24:14.000Z","excerpt":"打通开发、测试、运维的壁垒，实现开发、测试、运维一体化","_content":"\n# 从零搭建gitlab ci/cd流水线\n\n## 环境准备\n\n1. [ubuntu-20.04](https://www.releases.ubuntu.com/jammy/) \n2. [docker容器](https://zhuanlan.zhihu.com/p/632732853) \n\n## 部署gitlab\n1. 拉取社区版镜像\n```bash\ndocker pull gitlab/gitlab-ce\n```\n\n2. 在宿主机上创建gitlab数据卷\n```bash\n# data保存数据 logs保存日志 config保存配置\nsudo mkdir -p /gitlab/data /gitlab/logs /gitlab/config\n```\n3. 创建gitlab实例\n```bash\nsudo docker run -d --publish 8443:443 --publish 80:80 --publish 2222:22 --hostname 192.168.150.150 --name gitlab-app --privileged=true --restart unless-stopped --volume gitlab/config:/etc/gitlab --volume gitlab/logs:/var/log/gitlab --volume gitlab/data:/var/opt/gitlab -log-driver=none gitlab/gitlab-ce:latest\n```\n- -d 指定容器以守护进程的形式运行，即后台运行\n- --publish 端口映射，将容器的443、80、22端口映射到宿主机的8443、80、2222端口\n- --hostname 指定宿主机的ip，如果采用ip访问，则启动后访问地址为\"http://192.168.150.150\"\n- --name 指定镜像的名称\n- --privileged=true 以特权模式运行，即容器内的进程拥有主机的root权限\n- --restart unless-stopped 指定容器在退出时自动重启，除非容器被手动停止\n- --volume 指定挂载目录，将创建的目录挂载到容器的指定位置（宿主机目录:容器目录）\n- -log-driver=none： 禁用Docker的日志记录功能。\n\n(1) 由于gitlab的镜像比较大，要启动的服务比较多，因此启动比较耗时，大概需要3分钟左右，在启动过程中，镜像的状态是starting，启动成功后镜像的status是healthy。\n\n(2) 容器启动成功后，直接访问指定的宿主机ip地址 192.168.150.150\n\n(3) gitlab默认账户为root，root的默认密码在/gitlab/config/initial_root_password\n\n## 部署gitlab-runner\n1. 拉取镜像\n```bash\ndocker pull gitlab/gitlab-runner:latest\n```\n2. 创建实例\n```\ndocker run -d --name gitlab-runner --restart always -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:latest\n```\n- --restart always: 表示容器退出后总是重启。\n- -v /var/run/docker.sock:/var/run/docker.sock:将主机的docker.sock文件挂载到容器中，从而使容器可以与宿主机Docker引擎通信，这个配置很关键，因为只有增加了这个配置，gitlab-runner才能将构建产生的容器部署到宿主机，这里可以将gitlab-runner容器视为宿主机的GUI。\n\n3. 注册gitlab-runner\n- 注册前需要使用root账户登录gitlab-app创建runner（入口/管理中心/cicd/runner），获取token及url地址\n![创建runner](/images/cicd/runner-create.png)\n- 进入容器内部，执行gitlab-runner register命令开始注册流程，注册的时候填入token及url和一些runner的描述信息\n![注册runner](/images/cicd/runner-register.png)","source":"_posts/cicd/gitlab.md","raw":"---\ntitle: 从零搭建gitlab ci/cd流水线\ndate: 2023-07-15 09:24:14\ntags: [\"ci\", \"cd\", \"gitlab\"]\nexcerpt: 打通开发、测试、运维的壁垒，实现开发、测试、运维一体化\n---\n\n# 从零搭建gitlab ci/cd流水线\n\n## 环境准备\n\n1. [ubuntu-20.04](https://www.releases.ubuntu.com/jammy/) \n2. [docker容器](https://zhuanlan.zhihu.com/p/632732853) \n\n## 部署gitlab\n1. 拉取社区版镜像\n```bash\ndocker pull gitlab/gitlab-ce\n```\n\n2. 在宿主机上创建gitlab数据卷\n```bash\n# data保存数据 logs保存日志 config保存配置\nsudo mkdir -p /gitlab/data /gitlab/logs /gitlab/config\n```\n3. 创建gitlab实例\n```bash\nsudo docker run -d --publish 8443:443 --publish 80:80 --publish 2222:22 --hostname 192.168.150.150 --name gitlab-app --privileged=true --restart unless-stopped --volume gitlab/config:/etc/gitlab --volume gitlab/logs:/var/log/gitlab --volume gitlab/data:/var/opt/gitlab -log-driver=none gitlab/gitlab-ce:latest\n```\n- -d 指定容器以守护进程的形式运行，即后台运行\n- --publish 端口映射，将容器的443、80、22端口映射到宿主机的8443、80、2222端口\n- --hostname 指定宿主机的ip，如果采用ip访问，则启动后访问地址为\"http://192.168.150.150\"\n- --name 指定镜像的名称\n- --privileged=true 以特权模式运行，即容器内的进程拥有主机的root权限\n- --restart unless-stopped 指定容器在退出时自动重启，除非容器被手动停止\n- --volume 指定挂载目录，将创建的目录挂载到容器的指定位置（宿主机目录:容器目录）\n- -log-driver=none： 禁用Docker的日志记录功能。\n\n(1) 由于gitlab的镜像比较大，要启动的服务比较多，因此启动比较耗时，大概需要3分钟左右，在启动过程中，镜像的状态是starting，启动成功后镜像的status是healthy。\n\n(2) 容器启动成功后，直接访问指定的宿主机ip地址 192.168.150.150\n\n(3) gitlab默认账户为root，root的默认密码在/gitlab/config/initial_root_password\n\n## 部署gitlab-runner\n1. 拉取镜像\n```bash\ndocker pull gitlab/gitlab-runner:latest\n```\n2. 创建实例\n```\ndocker run -d --name gitlab-runner --restart always -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:latest\n```\n- --restart always: 表示容器退出后总是重启。\n- -v /var/run/docker.sock:/var/run/docker.sock:将主机的docker.sock文件挂载到容器中，从而使容器可以与宿主机Docker引擎通信，这个配置很关键，因为只有增加了这个配置，gitlab-runner才能将构建产生的容器部署到宿主机，这里可以将gitlab-runner容器视为宿主机的GUI。\n\n3. 注册gitlab-runner\n- 注册前需要使用root账户登录gitlab-app创建runner（入口/管理中心/cicd/runner），获取token及url地址\n![创建runner](/images/cicd/runner-create.png)\n- 进入容器内部，执行gitlab-runner register命令开始注册流程，注册的时候填入token及url和一些runner的描述信息\n![注册runner](/images/cicd/runner-register.png)","slug":"cicd/gitlab","published":1,"updated":"2023-07-15T02:47:40.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0qb85s000220tnczb0cg2c","content":"<h1 id=\"从零搭建gitlab-ci-x2F-cd流水线\"><a href=\"#从零搭建gitlab-ci-x2F-cd流水线\" class=\"headerlink\" title=\"从零搭建gitlab ci&#x2F;cd流水线\"></a>从零搭建gitlab ci&#x2F;cd流水线</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ol>\n<li><a href=\"https://www.releases.ubuntu.com/jammy/\">ubuntu-20.04</a> </li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/632732853\">docker容器</a></li>\n</ol>\n<h2 id=\"部署gitlab\"><a href=\"#部署gitlab\" class=\"headerlink\" title=\"部署gitlab\"></a>部署gitlab</h2><ol>\n<li><p>拉取社区版镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在宿主机上创建gitlab数据卷</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># data保存数据 logs保存日志 config保存配置</span></span><br><span class=\"line\">sudo <span class=\"built_in\">mkdir</span> -p /gitlab/data /gitlab/logs /gitlab/config</span><br></pre></td></tr></table></figure></li>\n<li><p>创建gitlab实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -d --publish 8443:443 --publish 80:80 --publish 2222:22 --hostname 192.168.150.150 --name gitlab-app --privileged=<span class=\"literal\">true</span> --restart unless-stopped --volume gitlab/config:/etc/gitlab --volume gitlab/logs:/var/log/gitlab --volume gitlab/data:/var/opt/gitlab -log-driver=none gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>-d 指定容器以守护进程的形式运行，即后台运行</li>\n<li>–publish 端口映射，将容器的443、80、22端口映射到宿主机的8443、80、2222端口</li>\n<li>–hostname 指定宿主机的ip，如果采用ip访问，则启动后访问地址为”<a href=\"http://192.168.150.150/\">http://192.168.150.150</a>“</li>\n<li>–name 指定镜像的名称</li>\n<li>–privileged&#x3D;true 以特权模式运行，即容器内的进程拥有主机的root权限</li>\n<li>–restart unless-stopped 指定容器在退出时自动重启，除非容器被手动停止</li>\n<li>–volume 指定挂载目录，将创建的目录挂载到容器的指定位置（宿主机目录:容器目录）</li>\n<li>-log-driver&#x3D;none： 禁用Docker的日志记录功能。</li>\n</ul>\n<p>(1) 由于gitlab的镜像比较大，要启动的服务比较多，因此启动比较耗时，大概需要3分钟左右，在启动过程中，镜像的状态是starting，启动成功后镜像的status是healthy。</p>\n<p>(2) 容器启动成功后，直接访问指定的宿主机ip地址 192.168.150.150</p>\n<p>(3) gitlab默认账户为root，root的默认密码在&#x2F;gitlab&#x2F;config&#x2F;initial_root_password</p>\n<h2 id=\"部署gitlab-runner\"><a href=\"#部署gitlab-runner\" class=\"headerlink\" title=\"部署gitlab-runner\"></a>部署gitlab-runner</h2><ol>\n<li>拉取镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure></li>\n<li>创建实例<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name gitlab-runner --restart always -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>–restart always: 表示容器退出后总是重启。</li>\n<li>-v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock:将主机的docker.sock文件挂载到容器中，从而使容器可以与宿主机Docker引擎通信，这个配置很关键，因为只有增加了这个配置，gitlab-runner才能将构建产生的容器部署到宿主机，这里可以将gitlab-runner容器视为宿主机的GUI。</li>\n</ul>\n<ol start=\"3\">\n<li>注册gitlab-runner</li>\n</ol>\n<ul>\n<li>注册前需要使用root账户登录gitlab-app创建runner（入口&#x2F;管理中心&#x2F;cicd&#x2F;runner），获取token及url地址<br><img src=\"/blog/images/cicd/runner-create.png\" alt=\"创建runner\"></li>\n<li>进入容器内部，执行gitlab-runner register命令开始注册流程，注册的时候填入token及url和一些runner的描述信息<br><img src=\"/blog/images/cicd/runner-register.png\" alt=\"注册runner\"></li>\n</ul>\n","site":{"data":{}},"more":"<h1 id=\"从零搭建gitlab-ci-x2F-cd流水线\"><a href=\"#从零搭建gitlab-ci-x2F-cd流水线\" class=\"headerlink\" title=\"从零搭建gitlab ci&#x2F;cd流水线\"></a>从零搭建gitlab ci&#x2F;cd流水线</h1><h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ol>\n<li><a href=\"https://www.releases.ubuntu.com/jammy/\">ubuntu-20.04</a> </li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/632732853\">docker容器</a></li>\n</ol>\n<h2 id=\"部署gitlab\"><a href=\"#部署gitlab\" class=\"headerlink\" title=\"部署gitlab\"></a>部署gitlab</h2><ol>\n<li><p>拉取社区版镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在宿主机上创建gitlab数据卷</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># data保存数据 logs保存日志 config保存配置</span></span><br><span class=\"line\">sudo <span class=\"built_in\">mkdir</span> -p /gitlab/data /gitlab/logs /gitlab/config</span><br></pre></td></tr></table></figure></li>\n<li><p>创建gitlab实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -d --publish 8443:443 --publish 80:80 --publish 2222:22 --hostname 192.168.150.150 --name gitlab-app --privileged=<span class=\"literal\">true</span> --restart unless-stopped --volume gitlab/config:/etc/gitlab --volume gitlab/logs:/var/log/gitlab --volume gitlab/data:/var/opt/gitlab -log-driver=none gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>-d 指定容器以守护进程的形式运行，即后台运行</li>\n<li>–publish 端口映射，将容器的443、80、22端口映射到宿主机的8443、80、2222端口</li>\n<li>–hostname 指定宿主机的ip，如果采用ip访问，则启动后访问地址为”<a href=\"http://192.168.150.150/\">http://192.168.150.150</a>“</li>\n<li>–name 指定镜像的名称</li>\n<li>–privileged&#x3D;true 以特权模式运行，即容器内的进程拥有主机的root权限</li>\n<li>–restart unless-stopped 指定容器在退出时自动重启，除非容器被手动停止</li>\n<li>–volume 指定挂载目录，将创建的目录挂载到容器的指定位置（宿主机目录:容器目录）</li>\n<li>-log-driver&#x3D;none： 禁用Docker的日志记录功能。</li>\n</ul>\n<p>(1) 由于gitlab的镜像比较大，要启动的服务比较多，因此启动比较耗时，大概需要3分钟左右，在启动过程中，镜像的状态是starting，启动成功后镜像的status是healthy。</p>\n<p>(2) 容器启动成功后，直接访问指定的宿主机ip地址 192.168.150.150</p>\n<p>(3) gitlab默认账户为root，root的默认密码在&#x2F;gitlab&#x2F;config&#x2F;initial_root_password</p>\n<h2 id=\"部署gitlab-runner\"><a href=\"#部署gitlab-runner\" class=\"headerlink\" title=\"部署gitlab-runner\"></a>部署gitlab-runner</h2><ol>\n<li>拉取镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure></li>\n<li>创建实例<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d --name gitlab-runner --restart always -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>–restart always: 表示容器退出后总是重启。</li>\n<li>-v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock:将主机的docker.sock文件挂载到容器中，从而使容器可以与宿主机Docker引擎通信，这个配置很关键，因为只有增加了这个配置，gitlab-runner才能将构建产生的容器部署到宿主机，这里可以将gitlab-runner容器视为宿主机的GUI。</li>\n</ul>\n<ol start=\"3\">\n<li>注册gitlab-runner</li>\n</ol>\n<ul>\n<li>注册前需要使用root账户登录gitlab-app创建runner（入口&#x2F;管理中心&#x2F;cicd&#x2F;runner），获取token及url地址<br><img src=\"/blog/images/cicd/runner-create.png\" alt=\"创建runner\"></li>\n<li>进入容器内部，执行gitlab-runner register命令开始注册流程，注册的时候填入token及url和一些runner的描述信息<br><img src=\"/blog/images/cicd/runner-register.png\" alt=\"注册runner\"></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clhu5qi4d00026oupfnqb8o9w","tag_id":"clhu5qi4n000a6oup1n2cewtq","_id":"clhu5qi4q000f6oupb85accdm"},{"post_id":"clhu5qi4h00046oupcq8ccshp","tag_id":"clhu5qi4p000e6oupczxxdc6c","_id":"clhu5qi4r000k6oup0nar0fks"},{"post_id":"clhu5qi4h00046oupcq8ccshp","tag_id":"clhu5qi4q000g6ouph1jbbjw7","_id":"clhu5qi4r000l6oup543i4scj"},{"post_id":"clhu5qi4h00046oupcq8ccshp","tag_id":"clhu5qi4q000h6ouphaf860rt","_id":"clhu5qi4s000n6oupanbb21qi"},{"post_id":"clhu5qi4h00046oupcq8ccshp","tag_id":"clhu5qi4r000i6oupadgm1jjf","_id":"clhu5qi4s000o6oupatasf17i"},{"post_id":"clhu5qi4j00056oup2vnfbwb7","tag_id":"clhu5qi4r000j6oup06oddev0","_id":"clhu5qi4s000q6oupammmbroi"},{"post_id":"clhu5qi4j00056oup2vnfbwb7","tag_id":"clhu5qi4s000m6oup5x3nbrjq","_id":"clhu5qi4s000r6oupft1eevo9"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"clhu5qi4u000x6oupeqsfhtkg"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4s000s6oupajhqbr33","_id":"clhu5qi4v000y6oup6sf4g1bq"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4t000t6oupc7ndf88i","_id":"clhu5qi4v00106oupg2w7dd9f"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4t000u6oup724qawhk","_id":"clhu5qi4v00116oup2mec64cl"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4t000v6oupdobdah5g","_id":"clhu5qi4v00136oupez1rgq9n"},{"post_id":"clhu5qi4l00086oup4lzp3qn0","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"clhu5qi4w00166oupbfjwbi4b"},{"post_id":"clhu5qi4l00086oup4lzp3qn0","tag_id":"clhu5qi4v000z6oupdzcdd11b","_id":"clhu5qi4w00176oupfkwshbov"},{"post_id":"clhu5qi4l00086oup4lzp3qn0","tag_id":"clhu5qi4v00126oup0ewr3gao","_id":"clhu5qi4w00196oup5kde0q47"},{"post_id":"clhu5qi4l00086oup4lzp3qn0","tag_id":"clhu5qi4v00146oup797864yh","_id":"clhu5qi4w001a6oup7ga66j6k"},{"post_id":"clhu5qi4m00096ouph3gy79jw","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"clhu5qi50001d6oup1ugsdg52"},{"post_id":"clhu5qi4m00096ouph3gy79jw","tag_id":"clhu5qi4w00186ouphn4r09ui","_id":"clhu5qi50001e6oupb0ce92v7"},{"post_id":"clhu5qi4m00096ouph3gy79jw","tag_id":"clhu5qi4w001b6oup1mn05jlb","_id":"clhu5qi50001g6oupbcnjed9i"},{"post_id":"clhu5qi4o000b6oup4yp3fdcf","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"clhu5qi51001h6oup2nmy752m"},{"post_id":"clhu5qi4o000b6oup4yp3fdcf","tag_id":"clhu5qi4t000v6oupdobdah5g","_id":"clhu5qi51001i6oup18kv0sim"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi54001k6ouphm3nbbk6","_id":"clhu5qi56001q6oupbxjt24b0"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi54001l6oupfzw93d4t","_id":"clhu5qi56001r6oupg7bthsfw"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi55001m6oup8tsiaq1x","_id":"clhu5qi56001s6oup5psdhmpz"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi55001n6oupc4n92q2a","_id":"clhu5qi56001t6oup31jzcg4f"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi55001o6oupfsxk0uye","_id":"clhu5qi56001u6oupcn9qgldi"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi56001p6oup5ih6dbr8","_id":"clhu5qi56001v6ouphkmkdnm8"},{"post_id":"cli2hque1000234up3mc2blmq","tag_id":"clhu5qi4g00036oupdvy51ix0","_id":"cli2hque4000434up3knidct1"},{"post_id":"cli2hque1000234up3mc2blmq","tag_id":"clhu5qi4l00076oupab804vck","_id":"cli2hque4000534upg3oi5xih"},{"post_id":"cli2hzoyt00014oup1bfc64vc","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"cli2hzoyx00024oupeairgsct"},{"post_id":"cli2hzoyt00014oup1bfc64vc","tag_id":"cli2hque2000334up9v241vsg","_id":"cli2hzoyx00034oup4eyjhypu"},{"post_id":"cli9ymnnb0000tkuphb5vf8jf","tag_id":"cli9ymnno0001tkup4ntah5c1","_id":"cli9ymnns0003tkup0pejegnq"},{"post_id":"cli9ymnnb0000tkuphb5vf8jf","tag_id":"cli9ymnnr0002tkupdqzl0el8","_id":"cli9ymnns0004tkupglp20zbk"},{"post_id":"cli9ymnnb0000tkuphb5vf8jf","tag_id":"clhu5qi4l00076oupab804vck","_id":"cli9ymnns0005tkup59hvd8x6"},{"post_id":"cli9ymnnu0006tkup7ci47rkf","tag_id":"cli9ymnno0001tkup4ntah5c1","_id":"cli9ymno0000atkup7ezw9a7p"},{"post_id":"cli9ymnnu0006tkup7ci47rkf","tag_id":"cli9ymnnr0002tkupdqzl0el8","_id":"cli9ymno0000btkup5n9x9raq"},{"post_id":"cli9ymnnu0006tkup7ci47rkf","tag_id":"cli9ymnny0008tkup0mw62q73","_id":"cli9ymno0000ctkup2mc7b3rj"},{"post_id":"cli9ymnnu0006tkup7ci47rkf","tag_id":"cli9ymno00009tkupbosm3mwm","_id":"cli9ymno1000dtkup2bv9a6v2"},{"post_id":"cljjmba830001jctn6fm186o1","tag_id":"clhu5qi4p000e6oupczxxdc6c","_id":"cljjmba850002jctngq5b500r"},{"post_id":"cljjmba830001jctn6fm186o1","tag_id":"clhu5qi4q000g6ouph1jbbjw7","_id":"cljjmba860003jctnburxf13a"},{"post_id":"cljjmba830001jctn6fm186o1","tag_id":"clhu5qi4q000h6ouphaf860rt","_id":"cljjmba870004jctn5nspae5e"},{"post_id":"cljjmba830001jctn6fm186o1","tag_id":"clhu5qi4r000i6oupadgm1jjf","_id":"cljjmba880005jctndp9k3j2g"},{"post_id":"cljjmba890006jctn6quz3wp8","tag_id":"cljjmba8b0007jctn5dd9cxie","_id":"cljjmba8e0009jctnefr12xty"},{"post_id":"cljjmba890006jctn6quz3wp8","tag_id":"cljjmba8d0008jctnao6sbwln","_id":"cljjmba8e000ajctned0954f5"},{"post_id":"clm0qb85o000020tnbt31dzfa","tag_id":"cli9ymnno0001tkup4ntah5c1","_id":"clm0qb85r000120tnescu2g7w"},{"post_id":"clm0qb85s000220tnczb0cg2c","tag_id":"clm0qb85u000320tn0vg24nq4","_id":"clm0qb85w000620tne8xsfz2p"},{"post_id":"clm0qb85s000220tnczb0cg2c","tag_id":"clm0qb85v000420tn9fo7gcl1","_id":"clm0qb85w000720tnaocx7lsg"},{"post_id":"clm0qb85s000220tnczb0cg2c","tag_id":"clm0qb85w000520tn155bbp3l","_id":"clm0qb85w000820tn707kgttb"}],"Tag":[{"name":"web","_id":"clhu5qi4g00036oupdvy51ix0"},{"name":"docker","_id":"clhu5qi4l00076oupab804vck"},{"name":"hexo","_id":"clhu5qi4n000a6oup1n2cewtq"},{"name":"k8s","_id":"clhu5qi4p000e6oupczxxdc6c"},{"name":"架构","_id":"clhu5qi4q000g6ouph1jbbjw7"},{"name":"集群","_id":"clhu5qi4q000h6ouphaf860rt"},{"name":"运开","_id":"clhu5qi4r000i6oupadgm1jjf"},{"name":"git","_id":"clhu5qi4r000j6oup06oddev0"},{"name":"fork","_id":"clhu5qi4s000m6oup5x3nbrjq"},{"name":"go","_id":"clhu5qi4s000p6ouphv5f839w"},{"name":"ioc","_id":"clhu5qi4s000s6oupajhqbr33"},{"name":"控制反转","_id":"clhu5qi4t000t6oupc7ndf88i"},{"name":"依赖注入","_id":"clhu5qi4t000u6oup724qawhk"},{"name":"reflect","_id":"clhu5qi4t000v6oupdobdah5g"},{"name":"gorus","_id":"clhu5qi4v000z6oupdzcdd11b"},{"name":"rotatelogs","_id":"clhu5qi4v00126oup0ewr3gao"},{"name":"ifshook","_id":"clhu5qi4v00146oup797864yh"},{"name":"pipe","_id":"clhu5qi4w00186ouphn4r09ui"},{"name":"channel","_id":"clhu5qi4w001b6oup1mn05jlb"},{"name":"redis","_id":"clhu5qi54001k6ouphm3nbbk6"},{"name":"string","_id":"clhu5qi54001l6oupfzw93d4t"},{"name":"list","_id":"clhu5qi55001m6oup8tsiaq1x"},{"name":"hash","_id":"clhu5qi55001n6oupc4n92q2a"},{"name":"set","_id":"clhu5qi55001o6oupfsxk0uye"},{"name":"zset","_id":"clhu5qi56001p6oup5ih6dbr8"},{"name":"grpc","_id":"cli2hque2000334up9v241vsg"},{"name":"linux","_id":"cli9ymnno0001tkup4ntah5c1"},{"name":"centos","_id":"cli9ymnnr0002tkupdqzl0el8"},{"name":"vmware","_id":"cli9ymnny0008tkup0mw62q73"},{"name":"network","_id":"cli9ymno00009tkupbosm3mwm"},{"name":"nodejs","_id":"cljjmba8b0007jctn5dd9cxie"},{"name":"framework","_id":"cljjmba8d0008jctnao6sbwln"},{"name":"ci","_id":"clm0qb85u000320tn0vg24nq4"},{"name":"cd","_id":"clm0qb85v000420tn9fo7gcl1"},{"name":"gitlab","_id":"clm0qb85w000520tn155bbp3l"}]}}