{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/docker/container-command.png","path":"images/docker/container-command.png","modified":0,"renderable":0},{"_id":"source/images/docker/composition.png","path":"images/docker/composition.png","modified":0,"renderable":0},{"_id":"source/images/docker/dockerfile.png","path":"images/docker/dockerfile.png","modified":0,"renderable":0},{"_id":"source/images/docker/container-options.png","path":"images/docker/container-options.png","modified":0,"renderable":0},{"_id":"source/images/git/fork-remote.png","path":"images/git/fork-remote.png","modified":0,"renderable":0},{"_id":"source/images/git/微信截图_20230327103738.png","path":"images/git/微信截图_20230327103738.png","modified":0,"renderable":0},{"_id":"source/images/redis/key.png","path":"images/redis/key.png","modified":0,"renderable":0},{"_id":"source/images/redis/memory.png","path":"images/redis/memory.png","modified":0,"renderable":0},{"_id":"source/images/redis/list.png","path":"images/redis/list.png","modified":0,"renderable":0},{"_id":"source/images/go/ioc/case1.png","path":"images/go/ioc/case1.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe3.png","path":"images/go/pipe/pipe3.png","modified":0,"renderable":0},{"_id":"source/images/go/ioc/case2.png","path":"images/go/ioc/case2.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe1.png","path":"images/go/pipe/pipe1.png","modified":0,"renderable":0},{"_id":"source/images/go/pipe/pipe2.png","path":"images/go/pipe/pipe2.png","modified":0,"renderable":0},{"_id":"themes/bear/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/images/check.svg","path":"images/check.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/index.js","path":"script/index.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/jquery.min.js","path":"script/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/bear/source/script/post.js","path":"script/post.js","modified":0,"renderable":1},{"_id":"themes/bear/source/styles/site.styl","path":"styles/site.styl","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/email.svg","path":"images/socials/email.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/facebook.svg","path":"images/socials/facebook.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/github.svg","path":"images/socials/github.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/flickr.svg","path":"images/socials/flickr.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/instagram.svg","path":"images/socials/instagram.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/wechat.svg","path":"images/socials/wechat.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/weibo.svg","path":"images/socials/weibo.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/images/socials/google.svg","path":"images/socials/google.svg","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_drafts/persistence.md","hash":"04483ea3242f8cbd8a5160a9623c1fe84b589b24","modified":1684314507377},{"_id":"source/_drafts/kubernetes/base.md","hash":"4b71a1a2b77e50fd9e9c64dc33fac7215562d1e3","modified":1684314514282},{"_id":"source/_drafts/hexo-command.md","hash":"f7b893aa86f2d12741b249dcee9cc7eca143bcd4","modified":1682062928162},{"_id":"source/images/docker/dockerfile.png","hash":"43920921835d74aba2c1ed6c96c2e1ec5acbb0c3","modified":1678096841936},{"_id":"source/_posts/docker.md","hash":"d81db0b888a6cda9df1e03f4a651ce301c271d8d","modified":1678241557893},{"_id":"source/images/git/fork-remote.png","hash":"4fc4ff99088c23b165d4e628efd7a8e3360c306a","modified":1678414964117},{"_id":"source/images/git/微信截图_20230327103738.png","hash":"4ea65f1b32bc8902d3ede33a308fb76376e85caa","modified":1679884660542},{"_id":"source/_posts/go/ioc.md","hash":"420e60b30bc72fdd2e991d009b6628c2b95f310f","modified":1684476781153},{"_id":"source/images/redis/list.png","hash":"63773914754e857095905d551e46587f12cdf862","modified":1680565828991},{"_id":"source/_posts/git/fork.md","hash":"3fdb8d2f4f302d0e93a959e54fe8a70796c74de7","modified":1678415869356},{"_id":"source/_posts/go/log.md","hash":"f3054b1b3e99b29f7b840244ed43ab419cf258d4","modified":1678519347178},{"_id":"source/_posts/go/pipe.md","hash":"06018d827fae22bd83ffe45bbdc569667a8fbc17","modified":1680155837353},{"_id":"source/images/go/ioc/case2.png","hash":"ca2f15145602dec4ccebb740f2268e668d140970","modified":1684461223097},{"_id":"source/images/go/ioc/case1.png","hash":"45576d7ffdfaad4440116c6536c92c30991098bf","modified":1684379937144},{"_id":"source/_posts/go/reflect.md","hash":"e6bbadb2f2bbf529f20b5f99ec50c7f3b70182b0","modified":1684314257193},{"_id":"source/_posts/redis/base.md","hash":"90261adc9eeed27a548597f33a5be24d43c094c4","modified":1681885648490},{"_id":"source/images/go/pipe/pipe1.png","hash":"0e88ba7c6a3d0f39d563bc877daf8505c8a0d90c","modified":1680068733330},{"_id":"source/images/go/pipe/pipe3.png","hash":"4f16d115f18c33bbbf9a97c25f07b28cad550c8a","modified":1680072633426},{"_id":"themes/bear/_config.yml","hash":"e7cf37c67e525e34f8685b5ac772dbd24ccf1ab0","modified":1678240819358},{"_id":"themes/bear/package.json","hash":"e3153c1f5b75e1799b753dcafb28e4e86ccc2197","modified":1678237840878},{"_id":"source/images/go/pipe/pipe2.png","hash":"5c71c9d47d927e1ea9eb7567817c1366ceb6fb13","modified":1680070417150},{"_id":"themes/bear/.DS_Store","hash":"83d7e57752db294868ca1b7c368b619f29c951ae","modified":1677829317036},{"_id":"themes/bear/README.md","hash":"df9ab18cad20f2a189ccc6c5082a9250ddbb5ee0","modified":1677829317036},{"_id":"themes/bear/_partial/footer.pug","hash":"b72a17a470dbe10bd291c4fd9f0545278b6599f5","modified":1677829317036},{"_id":"themes/bear/_partial/aboutme.pug","hash":"f5b14bf80997bd398f746c0e7072a8ab5e1c767a","modified":1678240033568},{"_id":"themes/bear/_partial/google-analytics.pug","hash":"c75e26872935030e2a7c7846f43e3bbf0b43a9ff","modified":1677829317036},{"_id":"themes/bear/_partial/header.pug","hash":"03bf88c5654f3071a757cb817ea794e9a2e09924","modified":1678241709288},{"_id":"themes/bear/layout/archive.pug","hash":"ac61917e785e06c9e715472f7fc58a7fb4aee7e7","modified":1678240694143},{"_id":"themes/bear/_partial/post_footer.pug","hash":"30127766cc23fcb74cc2064ab8f06df1aa3a717f","modified":1677829317036},{"_id":"themes/bear/_partial/layout.pug","hash":"db695bce2f7d7af9ded4818e4d183bfb26fa8dbe","modified":1678240070291},{"_id":"themes/bear/layout/index.pug","hash":"6747a6a707dcbd765f42a38b5593fe7c1384eddb","modified":1677829317036},{"_id":"themes/bear/layout/post.pug","hash":"cbe3d59af0b8486dfc63f53d3982ac4c4db307f7","modified":1677829317036},{"_id":"themes/bear/source/images/avatar.png","hash":"a7c68a10d1a1357e4ec55891fc8a22d744b653d2","modified":1677829317052},{"_id":"themes/bear/source/.DS_Store","hash":"a533b17b008db177bb92835a7fadb3012f268058","modified":1677829317036},{"_id":"themes/bear/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1677829317051},{"_id":"themes/bear/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1677829317036},{"_id":"themes/bear/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1677829317036},{"_id":"themes/bear/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1677829317051},{"_id":"themes/bear/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1677829317052},{"_id":"themes/bear/source/script/index.js","hash":"6cb1c4f7bf44d8fb4a4af7fd260d39c0439daadc","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1677829317052},{"_id":"themes/bear/source/script/post.js","hash":"6b057a9ae5bc7d06cc67110f9651a77ed2fe8046","modified":1677829317052},{"_id":"themes/bear/source/styles/_extend.styl","hash":"82ab5ec19935d3a1cb3022f5f5c245f6ff7efe03","modified":1677829317052},{"_id":"themes/bear/source/styles/site.styl","hash":"1ff8e1d4f8777c3d918824fa134830476de79f51","modified":1677829317052},{"_id":"themes/bear/source/styles/_variables.styl","hash":"283c80570908bf83b0efd6ae1f524699eb5036a2","modified":1677829317052},{"_id":"themes/bear/source/images/socials/email.svg","hash":"866629becff21ec0d0bfc5980937c0a973e04c15","modified":1677829317052},{"_id":"themes/bear/source/images/check.svg","hash":"9e891aa1036fdeaf556d50854bb70a0d7175724b","modified":1677829317052},{"_id":"themes/bear/source/images/socials/github.svg","hash":"1dce3ba17c25257e195f6935d7cb227340fd3022","modified":1677829317052},{"_id":"themes/bear/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1677829317052},{"_id":"themes/bear/source/images/socials/instagram.svg","hash":"4cc77b3b2c2118b9e24b91a02e370dbc8456d24c","modified":1677829317052},{"_id":"themes/bear/source/images/socials/flickr.svg","hash":"5cb21fb6aa9295f97010ba434171d5222a706c36","modified":1677829317052},{"_id":"themes/bear/source/images/socials/wechat.svg","hash":"5524c7d161217e60f5dab9939f5475782fa314a2","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1677829317052},{"_id":"themes/bear/source/images/socials/facebook.svg","hash":"cc023ecafafda29e079736b2e287e9bcd32a9e0f","modified":1677829317052},{"_id":"themes/bear/source/images/socials/google.svg","hash":"47521c7f23b71fd55e1a19b81e23ab9373fc0225","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/aboutme.styl","hash":"1622faeaa3c410878fcd1f7f9988c5230accc307","modified":1677829317052},{"_id":"themes/bear/source/images/socials/weibo.svg","hash":"afc8e42094cd45aaca15c243caaf337968ec426d","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/archive.styl","hash":"40692d9092f7e158465a79771d04fe3a8ec4bf72","modified":1678523083600},{"_id":"themes/bear/source/styles/_partial/article.styl","hash":"961969a243fbbab4a5b6a0a908222e940b781f2a","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/footer.styl","hash":"480bc266846cc534bea0583a909a15cf01752c2c","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/header.styl","hash":"d706f703001406b4991e86839b9624e7d64acd5e","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/highlight.styl","hash":"a7bd88c9fd067403f9fdfe69b0de992f364fe2e8","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1677829317052},{"_id":"themes/bear/source/styles/_partial/theme.styl","hash":"7d089d66ec5b05e0f0ea0a15ce09e9379818a350","modified":1677829317052},{"_id":"themes/bear/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1677829317052},{"_id":"source/images/docker/container-command.png","hash":"0743524fd1c2aa7e5143a199a46e548e833cc015","modified":1678060431357},{"_id":"source/images/docker/container-options.png","hash":"73805ec4eead8fb2207f6b42260e9440d5f2a2b4","modified":1678059380567},{"_id":"source/images/docker/composition.png","hash":"6abb4f461eeaac697f9cb09bc2cc5dc6cf94acea","modified":1677835017810},{"_id":"source/images/redis/memory.png","hash":"972e3bd9eff09d9a7d7da822c6cdf195654ae6b9","modified":1680604190250},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1677829317052},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1677829317052},{"_id":"themes/bear/pnpm-lock.yaml","hash":"af700ac4380664fc36b4276ad3f973cee3e6d0d7","modified":1678237840843},{"_id":"themes/bear/source/script/jquery.min.js","hash":"745ab5d6e434cf8d321779da3c527b6d301e2b50","modified":1677829317052},{"_id":"source/images/redis/key.png","hash":"e494d047a966f0b5cd58cef1be661025bf8f7d07","modified":1680478303635},{"_id":"themes/bear/package-lock.json","hash":"2333a1f3c896e122e9e039e82a92ed57fdb6ab42","modified":1677829317036},{"_id":"themes/bear/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1677829317052},{"_id":"themes/bear/screenshot.jpg","hash":"a5a295578ab8e324257f5618e41397c91403db5a","modified":1677829317036},{"_id":"themes/bear/screenshot2.jpg","hash":"56a02cf741ea2673e175254ef9a4d02ef369a1f5","modified":1677829317036},{"_id":"public/2023/05/17/go/reflect/index.html","hash":"742fd7115496ddeba9cee0a5ad536adf3a843bd2","modified":1684476364864},{"_id":"public/2023/03/10/go/log/index.html","hash":"279441b7dd6c62b1065c5528a75dc94a267b75f6","modified":1684476364864},{"_id":"public/2023/03/10/git/fork/index.html","hash":"2846b02fea9c0ba785c8cd9175d22495e8230479","modified":1684476364864},{"_id":"public/archives/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/archives/2023/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/archives/2023/03/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/archives/2023/04/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/archives/2023/05/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/web/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/docker/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/git/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/fork/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/go/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/ioc/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/控制反转/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/依赖注入/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/reflect/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/gorus/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/rotatelogs/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/ifshook/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/pipe/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/channel/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/redis/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/string/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/list/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/hash/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/set/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/tags/zset/index.html","hash":"f502648951bed7288776961fc59e19208bd11f64","modified":1684476787227},{"_id":"public/index.html","hash":"fc79c279f7a26f3bc50b66aa34f4ef0a7b9af6e0","modified":1684476787227},{"_id":"public/2023/05/19/go/ioc/index.html","hash":"f46c4eae43824e3812fa03f672349d37bf9a6681","modified":1684476787227},{"_id":"public/2023/04/02/redis/base/index.html","hash":"cebd3d5ec3501077c7ff1bb5357f9261a3dcba75","modified":1684476364864},{"_id":"public/2023/03/30/go/pipe/index.html","hash":"52955b9e983c728770f62abfb77af3ddd350f38c","modified":1684476364864},{"_id":"public/2023/03/03/docker/index.html","hash":"ad8e759400dbc0457b3659dd577391d92d0ed635","modified":1684476364864},{"_id":"public/images/git/fork-remote.png","hash":"4fc4ff99088c23b165d4e628efd7a8e3360c306a","modified":1684476364864},{"_id":"public/images/docker/dockerfile.png","hash":"43920921835d74aba2c1ed6c96c2e1ec5acbb0c3","modified":1684476364864},{"_id":"public/images/git/微信截图_20230327103738.png","hash":"4ea65f1b32bc8902d3ede33a308fb76376e85caa","modified":1684476364864},{"_id":"public/images/redis/list.png","hash":"63773914754e857095905d551e46587f12cdf862","modified":1684476364864},{"_id":"public/images/go/ioc/case1.png","hash":"45576d7ffdfaad4440116c6536c92c30991098bf","modified":1684476364864},{"_id":"public/images/go/pipe/pipe3.png","hash":"4f16d115f18c33bbbf9a97c25f07b28cad550c8a","modified":1684476364864},{"_id":"public/images/go/ioc/case2.png","hash":"ca2f15145602dec4ccebb740f2268e668d140970","modified":1684476364864},{"_id":"public/images/go/pipe/pipe2.png","hash":"5c71c9d47d927e1ea9eb7567817c1366ceb6fb13","modified":1684476364864},{"_id":"public/images/go/pipe/pipe1.png","hash":"0e88ba7c6a3d0f39d563bc877daf8505c8a0d90c","modified":1684476364864},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1684476364864},{"_id":"public/images/avatar.png","hash":"a7c68a10d1a1357e4ec55891fc8a22d744b653d2","modified":1684476364864},{"_id":"public/images/check.svg","hash":"9e891aa1036fdeaf556d50854bb70a0d7175724b","modified":1684476364864},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1684476364864},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1684476364864},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1684476364864},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1684476364864},{"_id":"public/images/socials/email.svg","hash":"866629becff21ec0d0bfc5980937c0a973e04c15","modified":1684476364864},{"_id":"public/images/socials/facebook.svg","hash":"cc023ecafafda29e079736b2e287e9bcd32a9e0f","modified":1684476364864},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1684476364864},{"_id":"public/images/socials/github.svg","hash":"1dce3ba17c25257e195f6935d7cb227340fd3022","modified":1684476364864},{"_id":"public/images/socials/flickr.svg","hash":"5cb21fb6aa9295f97010ba434171d5222a706c36","modified":1684476364864},{"_id":"public/images/socials/wechat.svg","hash":"5524c7d161217e60f5dab9939f5475782fa314a2","modified":1684476364864},{"_id":"public/images/socials/instagram.svg","hash":"4cc77b3b2c2118b9e24b91a02e370dbc8456d24c","modified":1684476364864},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1684476364864},{"_id":"public/images/socials/weibo.svg","hash":"afc8e42094cd45aaca15c243caaf337968ec426d","modified":1684476364864},{"_id":"public/images/socials/google.svg","hash":"47521c7f23b71fd55e1a19b81e23ab9373fc0225","modified":1684476364864},{"_id":"public/images/docker/container-command.png","hash":"0743524fd1c2aa7e5143a199a46e548e833cc015","modified":1684476364864},{"_id":"public/images/docker/composition.png","hash":"6abb4f461eeaac697f9cb09bc2cc5dc6cf94acea","modified":1684476364864},{"_id":"public/images/docker/container-options.png","hash":"73805ec4eead8fb2207f6b42260e9440d5f2a2b4","modified":1684476364864},{"_id":"public/images/redis/memory.png","hash":"972e3bd9eff09d9a7d7da822c6cdf195654ae6b9","modified":1684476364864},{"_id":"public/script/index.js","hash":"3be07c789aa4a521a31f3c59a98933ee9f8c85aa","modified":1684476364864},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1684476364864},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1684476364864},{"_id":"public/script/post.js","hash":"ad6bdffb5a7f722f469e65c2061e56a434479de5","modified":1684476364864},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1684476364864},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1684476364864},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1684476364864},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1684476364864},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1684476364864},{"_id":"public/styles/site.css","hash":"58fe37adeba5e0d30094e2770c0226caf229c100","modified":1684476364864},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1684476364864},{"_id":"public/script/jquery.min.js","hash":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d","modified":1684476364864},{"_id":"public/images/redis/key.png","hash":"e494d047a966f0b5cd58cef1be661025bf8f7d07","modified":1684476364864}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"前端开发者应该掌握的docker知识","date":"2023-03-03T09:01:39.000Z","excerpt":"身为前端开发者的我们应该怎样理解、掌握docker？","_content":"身为前端开发者的我们应该怎样理解、掌握docker？\n### docker的基本组成\nDocker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。![平台架构图-基础版](/images/docker/composition.png)\n#### 镜像（image）\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。\n它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”\n#### 容器（container）\nDocker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.\n#### 仓库（respository）\n仓库（Repository）是集中存放镜像文件的场所。\n\n### 下载\n1.[官网地址](https://www.docker.com/)\n2.[仓库地址](https://hub.docker.com/)\n\n### 基本命令\n1. 启动docker\n```bash\nsystemctl start docker\n```\n2. 停止docker\n```bash\nsystemctl stop docker\n```\n3. 重启docker\n```bash\nsystemctl restart docker\n```\n4. 查看docker状态\n```bash\nsystemctl status docker\n```\n5. 开机启动\n```bash\nsystemctl enable docker\n```\n6. 查看docker概要信息\n```bash\ndocker info\n```\n7. 帮助命令\n```bash\n# 查看总体帮助\ndocker help\n# 查看具体命令帮助\ndocker 命令 --help\n```\n### 镜像常用命令\n1. 查看本地镜像\n```bash\ndocker images [options]\n\noptions:\n-a 列出本地所有镜像\n-q 只显示镜像ID\n```\n2. 查找镜像\n```bash\ndocker search [options] 镜像名称\n\noptions:\n--limit N 列出n个\n```\n3. 拉取镜像\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker pull 镜像名称[:tag] \n```\n4. 查看镜像/容器/数据卷所占的空间\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker system df\n```\n5. 镜像删除\n```bash\n# 删除某个镜像\ndocker rmi -f 镜像ID\n\n# 删除多个镜像\ndocker rmi -f 镜像名1:tag 镜像名2:tag\n\n# 删除全部\ndocker rmi -f ${docker images -qa}\n```\n6. 提交容器副本使之成为新的镜像\n```bash\ndocker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]\n```\n7. 将指定镜像保存成 tar 归档文件\n```bash\ndocker save [OPTIONS] IMAGE [IMAGE...]\n\nOPTIONS：\n-o :输出到的文件\n```\n8. 导入使用 docker save 命令导出的镜像\n```bash\ndocker load [OPTIONS]\n举例 docker load < 镜像文件名\n\nOPTIONS：\n--input , -i : 指定导入的文件，代替 STDIN\n--quiet , -q : 精简输出信息\n```\n### 容器常用命令\n1. 新建/启动容器\n```bash\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...] \n\nOPTIONS:有些是一个减号有些是两个减号\n--name=\"容器新名字\" 为容器指定一个名称\n-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)\n-i：以交互模式运行容器，通常与 -t 同时使用\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)\n-P: 随机端口映射，大写P\n-p: 指定端口映射，小写p\n```\n![container-options](/images/docker/container-options.png)\n2. 列出当前正在运行的容器\n```bash\ndocker ps [OPTIONS]\n\nOPTIONS:\n-a :列出当前所有正在运行的容器+历史上运行过的\n-l :显示最近创建的容器\n-n :显示最近n个创建的容器\n-q :静默模式，只显示容器编号\n```\n3. 退出容器\n```bash\nexit run进入exit退出 容器停止\nctrl+p+q run进入ctrl+p+q退出 容器不停止\n```\n4. 启动已停止运行的容器\n```bash\ndocker start 容器ID/容器name\n```\n5. 重启容器\n```bash\ndocker restart 容器ID/容器name\n```\n6. 停止容器\n```bash\ndocker stop 容器ID/容器name\n```\n7. 强制停止容器\n```bash\ndocker kill 容器ID/容器name\n```\n8. 删除已停止的容器\n```bash\ndocker rm 容器ID/容器name\n```\n9. 启动守护式容器（后台服务器）\n```bash\ndocker run -it -d 容器ID\n```\n10. 查看容器日志\n```bash\ndocker logs 容器ID\n#跟踪查看最近100条日志\ndocker logs -f -n100\n```\n11. 查看容器内运行的进程\n```bash\ndocker top 容器ID\n```\n12. 查看容器内部细节\n```bash\ndocker inspect 容器ID\n```\n13. 进入正在运行的容器并以命令行交互\n```bash\ndocker exec -it 容器ID /bin/bash\n```\n14. 从容器内拷贝文件到主机上\n```bash\ndocker cp 容器id:容器内路径 宿主机路径\n```\n\n15. 常用命令总结\n![container-command](/images/docker/container-command.png)\n```bash\nattach    # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     # 通过 Dockerfile 定制镜像\n\ncommit    # 提交当前容器为新的镜像\n\ncp        #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    # 创建一个新的容器，同 run，但不启动容器\n\ndiff      # 查看 docker 容器变化\n\nevents    # 从 docker 服务获取容器实时事件\n\nexec      # 在已存在的容器上运行命令\n\nexport    # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   # 展示一个镜像形成历史\n\nimages    # 列出系统当前镜像\n\nimport    # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      # 显示系统相关信息\n\ninspect   # 查看容器详细信息\n\nkill      # kill 指定 docker 容器\n\nload      # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     # 注册或者登陆一个 docker 源服务器\n\nlogout    # 从当前 Docker registry 退出\n\nlogs      # 输出当前容器日志信息\n\nport      # 查看映射端口对应的容器内部源端口\n\npause     # 暂停容器\n\nps        # 列出容器列表\n\npull      # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   # 重启运行的容器\n\nrm        # 移除一个或者多个容器\n\nrmi       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       # 创建一个新的容器并运行一个命令\n\nsave      # 保存一个镜像为一个 tar 包[对应 load]\n\nsearch    # 在 docker hub 中搜索镜像\n\nstart     # 启动容器\n\nstop      # 停止容器\n\ntag       # 给源中镜像打标签\n\ntop       # 查看容器中运行的进程信息\n\nunpause   # 取消暂停容器\n\nversion   # 查看 docker 版本号\n\nwait      # 截取容器停止时的退出状态值\n```\n\n### 容器数据卷\n将docker容器中的数据保存到宿主机的磁盘中\n```bash\n# 一定要带上--privileged=true不然没有权限\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名\n```\n\n### DockerFile\nDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n#### DockerFile基础说明\n- 每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n- 指令按照顺序，从上到下顺序执行\n- #表示注释\n- 每条指令都会创建一个新的镜像层并对镜像进行提交\n\n#### docker执行DockerFile流程\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器进行修改\n3. 执行类似docker commit的操作提交一个新的镜像层\n4. docker再基于刚提交的镜像运行一个新容器\n5. 执行docker中的下一条指令直至所有指令完成\n\n#### 常用保留字指令\n1. FROM： 基础镜像\n2. MAINTAINER： 镜像维护者姓名和邮箱\n3. RUN： docker build时需要运行的命令\n4. EXPOSE：当前容器对外暴露的端口\n5. WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\n6. USER：指定容器以什么样的用户去执行，默认root\n7. ENV：用来在构建镜像过程中设置环境变量\n8. ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包\n9. COPY：类似ADD拷贝文件和目录到镜像中\n10. VOLUME：容器数据卷用于保存数据和数据持久化\n11. CMD：指定容器启动后要干的事情\n12. ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序\n![](/images/docker/dockerfile.png)","source":"_posts/docker.md","raw":"---\ntitle: 前端开发者应该掌握的docker知识\ndate: 2023-03-03 17:01:39\ntags: ['web','docker']\nexcerpt: 身为前端开发者的我们应该怎样理解、掌握docker？\n---\n身为前端开发者的我们应该怎样理解、掌握docker？\n### docker的基本组成\nDocker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。![平台架构图-基础版](/images/docker/composition.png)\n#### 镜像（image）\nDocker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。\n它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”\n#### 容器（container）\nDocker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.\n#### 仓库（respository）\n仓库（Repository）是集中存放镜像文件的场所。\n\n### 下载\n1.[官网地址](https://www.docker.com/)\n2.[仓库地址](https://hub.docker.com/)\n\n### 基本命令\n1. 启动docker\n```bash\nsystemctl start docker\n```\n2. 停止docker\n```bash\nsystemctl stop docker\n```\n3. 重启docker\n```bash\nsystemctl restart docker\n```\n4. 查看docker状态\n```bash\nsystemctl status docker\n```\n5. 开机启动\n```bash\nsystemctl enable docker\n```\n6. 查看docker概要信息\n```bash\ndocker info\n```\n7. 帮助命令\n```bash\n# 查看总体帮助\ndocker help\n# 查看具体命令帮助\ndocker 命令 --help\n```\n### 镜像常用命令\n1. 查看本地镜像\n```bash\ndocker images [options]\n\noptions:\n-a 列出本地所有镜像\n-q 只显示镜像ID\n```\n2. 查找镜像\n```bash\ndocker search [options] 镜像名称\n\noptions:\n--limit N 列出n个\n```\n3. 拉取镜像\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker pull 镜像名称[:tag] \n```\n4. 查看镜像/容器/数据卷所占的空间\n```bash\n# 不带tag默认拉取最新的镜像等同于:latest\ndocker system df\n```\n5. 镜像删除\n```bash\n# 删除某个镜像\ndocker rmi -f 镜像ID\n\n# 删除多个镜像\ndocker rmi -f 镜像名1:tag 镜像名2:tag\n\n# 删除全部\ndocker rmi -f ${docker images -qa}\n```\n6. 提交容器副本使之成为新的镜像\n```bash\ndocker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]\n```\n7. 将指定镜像保存成 tar 归档文件\n```bash\ndocker save [OPTIONS] IMAGE [IMAGE...]\n\nOPTIONS：\n-o :输出到的文件\n```\n8. 导入使用 docker save 命令导出的镜像\n```bash\ndocker load [OPTIONS]\n举例 docker load < 镜像文件名\n\nOPTIONS：\n--input , -i : 指定导入的文件，代替 STDIN\n--quiet , -q : 精简输出信息\n```\n### 容器常用命令\n1. 新建/启动容器\n```bash\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...] \n\nOPTIONS:有些是一个减号有些是两个减号\n--name=\"容器新名字\" 为容器指定一个名称\n-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)\n-i：以交互模式运行容器，通常与 -t 同时使用\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)\n-P: 随机端口映射，大写P\n-p: 指定端口映射，小写p\n```\n![container-options](/images/docker/container-options.png)\n2. 列出当前正在运行的容器\n```bash\ndocker ps [OPTIONS]\n\nOPTIONS:\n-a :列出当前所有正在运行的容器+历史上运行过的\n-l :显示最近创建的容器\n-n :显示最近n个创建的容器\n-q :静默模式，只显示容器编号\n```\n3. 退出容器\n```bash\nexit run进入exit退出 容器停止\nctrl+p+q run进入ctrl+p+q退出 容器不停止\n```\n4. 启动已停止运行的容器\n```bash\ndocker start 容器ID/容器name\n```\n5. 重启容器\n```bash\ndocker restart 容器ID/容器name\n```\n6. 停止容器\n```bash\ndocker stop 容器ID/容器name\n```\n7. 强制停止容器\n```bash\ndocker kill 容器ID/容器name\n```\n8. 删除已停止的容器\n```bash\ndocker rm 容器ID/容器name\n```\n9. 启动守护式容器（后台服务器）\n```bash\ndocker run -it -d 容器ID\n```\n10. 查看容器日志\n```bash\ndocker logs 容器ID\n#跟踪查看最近100条日志\ndocker logs -f -n100\n```\n11. 查看容器内运行的进程\n```bash\ndocker top 容器ID\n```\n12. 查看容器内部细节\n```bash\ndocker inspect 容器ID\n```\n13. 进入正在运行的容器并以命令行交互\n```bash\ndocker exec -it 容器ID /bin/bash\n```\n14. 从容器内拷贝文件到主机上\n```bash\ndocker cp 容器id:容器内路径 宿主机路径\n```\n\n15. 常用命令总结\n![container-command](/images/docker/container-command.png)\n```bash\nattach    # 当前 shell 下 attach 连接指定运行镜像\n\nbuild     # 通过 Dockerfile 定制镜像\n\ncommit    # 提交当前容器为新的镜像\n\ncp        #从容器中拷贝指定文件或者目录到宿主机中\n\ncreate    # 创建一个新的容器，同 run，但不启动容器\n\ndiff      # 查看 docker 容器变化\n\nevents    # 从 docker 服务获取容器实时事件\n\nexec      # 在已存在的容器上运行命令\n\nexport    # 导出容器的内容流作为一个 tar 归档文件[对应 import ]\n\nhistory   # 展示一个镜像形成历史\n\nimages    # 列出系统当前镜像\n\nimport    # 从tar包中的内容创建一个新的文件系统映像[对应export]\n\ninfo      # 显示系统相关信息\n\ninspect   # 查看容器详细信息\n\nkill      # kill 指定 docker 容器\n\nload      # 从一个 tar 包中加载一个镜像[对应 save]\n\nlogin     # 注册或者登陆一个 docker 源服务器\n\nlogout    # 从当前 Docker registry 退出\n\nlogs      # 输出当前容器日志信息\n\nport      # 查看映射端口对应的容器内部源端口\n\npause     # 暂停容器\n\nps        # 列出容器列表\n\npull      # 从docker镜像源服务器拉取指定镜像或者库镜像\n\npush      # 推送指定镜像或者库镜像至docker源服务器\n\nrestart   # 重启运行的容器\n\nrm        # 移除一个或者多个容器\n\nrmi       # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]\n\nrun       # 创建一个新的容器并运行一个命令\n\nsave      # 保存一个镜像为一个 tar 包[对应 load]\n\nsearch    # 在 docker hub 中搜索镜像\n\nstart     # 启动容器\n\nstop      # 停止容器\n\ntag       # 给源中镜像打标签\n\ntop       # 查看容器中运行的进程信息\n\nunpause   # 取消暂停容器\n\nversion   # 查看 docker 版本号\n\nwait      # 截取容器停止时的退出状态值\n```\n\n### 容器数据卷\n将docker容器中的数据保存到宿主机的磁盘中\n```bash\n# 一定要带上--privileged=true不然没有权限\ndocker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名\n```\n\n### DockerFile\nDockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n#### DockerFile基础说明\n- 每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n- 指令按照顺序，从上到下顺序执行\n- #表示注释\n- 每条指令都会创建一个新的镜像层并对镜像进行提交\n\n#### docker执行DockerFile流程\n1. docker从基础镜像运行一个容器\n2. 执行一条指令并对容器进行修改\n3. 执行类似docker commit的操作提交一个新的镜像层\n4. docker再基于刚提交的镜像运行一个新容器\n5. 执行docker中的下一条指令直至所有指令完成\n\n#### 常用保留字指令\n1. FROM： 基础镜像\n2. MAINTAINER： 镜像维护者姓名和邮箱\n3. RUN： docker build时需要运行的命令\n4. EXPOSE：当前容器对外暴露的端口\n5. WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\n6. USER：指定容器以什么样的用户去执行，默认root\n7. ENV：用来在构建镜像过程中设置环境变量\n8. ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包\n9. COPY：类似ADD拷贝文件和目录到镜像中\n10. VOLUME：容器数据卷用于保存数据和数据持久化\n11. CMD：指定容器启动后要干的事情\n12. ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序\n![](/images/docker/dockerfile.png)","slug":"docker","published":1,"updated":"2023-03-08T02:12:37.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi4b00016oup4oeh1kot","content":"<p>身为前端开发者的我们应该怎样理解、掌握docker？</p>\n<h3 id=\"docker的基本组成\"><a href=\"#docker的基本组成\" class=\"headerlink\" title=\"docker的基本组成\"></a>docker的基本组成</h3><p>Docker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。<img src=\"/blog/images/docker/composition.png\" alt=\"平台架构图-基础版\"></p>\n<h4 id=\"镜像（image）\"><a href=\"#镜像（image）\" class=\"headerlink\" title=\"镜像（image）\"></a>镜像（image）</h4><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。<br>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”</p>\n<h4 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h4><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.</p>\n<h4 id=\"仓库（respository）\"><a href=\"#仓库（respository）\" class=\"headerlink\" title=\"仓库（respository）\"></a>仓库（respository）</h4><p>仓库（Repository）是集中存放镜像文件的场所。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>1.<a href=\"https://www.docker.com/\">官网地址</a><br>2.<a href=\"https://hub.docker.com/\">仓库地址</a></p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ol>\n<li>启动docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure></li>\n<li>停止docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop docker</span><br></pre></td></tr></table></figure></li>\n<li>重启docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker状态<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker</span><br></pre></td></tr></table></figure></li>\n<li>开机启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker概要信息<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure></li>\n<li>帮助命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看总体帮助</span></span><br><span class=\"line\">docker <span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\"># 查看具体命令帮助</span></span><br><span class=\"line\">docker 命令 --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"镜像常用命令\"><a href=\"#镜像常用命令\" class=\"headerlink\" title=\"镜像常用命令\"></a>镜像常用命令</h3><ol>\n<li>查看本地镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images [options]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-a 列出本地所有镜像</span><br><span class=\"line\">-q 只显示镜像ID</span><br></pre></td></tr></table></figure></li>\n<li>查找镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search [options] 镜像名称</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">--<span class=\"built_in\">limit</span> N 列出n个</span><br></pre></td></tr></table></figure></li>\n<li>拉取镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker pull 镜像名称[:tag] </span><br></pre></td></tr></table></figure></li>\n<li>查看镜像&#x2F;容器&#x2F;数据卷所占的空间<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker system <span class=\"built_in\">df</span></span><br></pre></td></tr></table></figure></li>\n<li>镜像删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除某个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像ID</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除多个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像名1:tag 镜像名2:tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除全部</span></span><br><span class=\"line\">docker rmi -f <span class=\"variable\">$&#123;docker images -qa&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>提交容器副本使之成为新的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure></li>\n<li>将指定镜像保存成 tar 归档文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">-o :输出到的文件</span><br></pre></td></tr></table></figure></li>\n<li>导入使用 docker save 命令导出的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load [OPTIONS]</span><br><span class=\"line\">举例 docker load &lt; 镜像文件名</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">--input , -i : 指定导入的文件，代替 STDIN</span><br><span class=\"line\">--quiet , -q : 精简输出信息</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器常用命令\"><a href=\"#容器常用命令\" class=\"headerlink\" title=\"容器常用命令\"></a>容器常用命令</h3><ol>\n<li><p>新建&#x2F;启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...] </span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:有些是一个减号有些是两个减号</span><br><span class=\"line\">--name=<span class=\"string\">&quot;容器新名字&quot;</span> 为容器指定一个名称</span><br><span class=\"line\">-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)</span><br><span class=\"line\">-i：以交互模式运行容器，通常与 -t 同时使用</span><br><span class=\"line\">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)</span><br><span class=\"line\">-P: 随机端口映射，大写P</span><br><span class=\"line\">-p: 指定端口映射，小写p</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/docker/container-options.png\" alt=\"container-options\"></p>\n</li>\n<li><p>列出当前正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:</span><br><span class=\"line\">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class=\"line\">-l :显示最近创建的容器</span><br><span class=\"line\">-n :显示最近n个创建的容器</span><br><span class=\"line\">-q :静默模式，只显示容器编号</span><br></pre></td></tr></table></figure></li>\n<li><p>退出容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exit</span> run进入<span class=\"built_in\">exit</span>退出 容器停止</span><br><span class=\"line\">ctrl+p+q run进入ctrl+p+q退出 容器不停止</span><br></pre></td></tr></table></figure></li>\n<li><p>启动已停止运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>重启容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>强制停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">kill</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>删除已停止的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>启动守护式容器（后台服务器）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -d 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker logs 容器ID</span><br><span class=\"line\"><span class=\"comment\">#跟踪查看最近100条日志</span></span><br><span class=\"line\">docker logs -f -n100</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内运行的进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker top 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内部细节</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>进入正在运行的容器并以命令行交互</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure></li>\n<li><p>从容器内拷贝文件到主机上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">cp</span> 容器<span class=\"built_in\">id</span>:容器内路径 宿主机路径</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用命令总结<br><img src=\"/blog/images/docker/container-command.png\" alt=\"container-command\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attach    <span class=\"comment\"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">build     <span class=\"comment\"># 通过 Dockerfile 定制镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit    <span class=\"comment\"># 提交当前容器为新的镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span>        <span class=\"comment\">#从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class=\"line\"></span><br><span class=\"line\">create    <span class=\"comment\"># 创建一个新的容器，同 run，但不启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">diff      <span class=\"comment\"># 查看 docker 容器变化</span></span><br><span class=\"line\"></span><br><span class=\"line\">events    <span class=\"comment\"># 从 docker 服务获取容器实时事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exec</span>      <span class=\"comment\"># 在已存在的容器上运行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span>    <span class=\"comment\"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">history</span>   <span class=\"comment\"># 展示一个镜像形成历史</span></span><br><span class=\"line\"></span><br><span class=\"line\">images    <span class=\"comment\"># 列出系统当前镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">import    <span class=\"comment\"># 从tar包中的内容创建一个新的文件系统映像[对应export]</span></span><br><span class=\"line\"></span><br><span class=\"line\">info      <span class=\"comment\"># 显示系统相关信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">inspect   <span class=\"comment\"># 查看容器详细信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span>      <span class=\"comment\"># kill 指定 docker 容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">load      <span class=\"comment\"># 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class=\"line\"></span><br><span class=\"line\">login     <span class=\"comment\"># 注册或者登陆一个 docker 源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">logout</span>    <span class=\"comment\"># 从当前 Docker registry 退出</span></span><br><span class=\"line\"></span><br><span class=\"line\">logs      <span class=\"comment\"># 输出当前容器日志信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">port      <span class=\"comment\"># 查看映射端口对应的容器内部源端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">pause     <span class=\"comment\"># 暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">ps        <span class=\"comment\"># 列出容器列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">pull      <span class=\"comment\"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">push      <span class=\"comment\"># 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\">restart   <span class=\"comment\"># 重启运行的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rm</span>        <span class=\"comment\"># 移除一个或者多个容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">rmi       <span class=\"comment\"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class=\"line\"></span><br><span class=\"line\">run       <span class=\"comment\"># 创建一个新的容器并运行一个命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">save      <span class=\"comment\"># 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class=\"line\"></span><br><span class=\"line\">search    <span class=\"comment\"># 在 docker hub 中搜索镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">start     <span class=\"comment\"># 启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">stop      <span class=\"comment\"># 停止容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">tag       <span class=\"comment\"># 给源中镜像打标签</span></span><br><span class=\"line\"></span><br><span class=\"line\">top       <span class=\"comment\"># 查看容器中运行的进程信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">unpause   <span class=\"comment\"># 取消暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">version   <span class=\"comment\"># 查看 docker 版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">wait</span>      <span class=\"comment\"># 截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h3><p>将docker容器中的数据保存到宿主机的磁盘中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一定要带上--privileged=true不然没有权限</span></span><br><span class=\"line\">docker run -it --privileged=<span class=\"literal\">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h3><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<h4 id=\"DockerFile基础说明\"><a href=\"#DockerFile基础说明\" class=\"headerlink\" title=\"DockerFile基础说明\"></a>DockerFile基础说明</h4><ul>\n<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>\n<li>指令按照顺序，从上到下顺序执行</li>\n<li>#表示注释</li>\n<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>\n</ul>\n<h4 id=\"docker执行DockerFile流程\"><a href=\"#docker执行DockerFile流程\" class=\"headerlink\" title=\"docker执行DockerFile流程\"></a>docker执行DockerFile流程</h4><ol>\n<li>docker从基础镜像运行一个容器</li>\n<li>执行一条指令并对容器进行修改</li>\n<li>执行类似docker commit的操作提交一个新的镜像层</li>\n<li>docker再基于刚提交的镜像运行一个新容器</li>\n<li>执行docker中的下一条指令直至所有指令完成</li>\n</ol>\n<h4 id=\"常用保留字指令\"><a href=\"#常用保留字指令\" class=\"headerlink\" title=\"常用保留字指令\"></a>常用保留字指令</h4><ol>\n<li>FROM： 基础镜像</li>\n<li>MAINTAINER： 镜像维护者姓名和邮箱</li>\n<li>RUN： docker build时需要运行的命令</li>\n<li>EXPOSE：当前容器对外暴露的端口</li>\n<li>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</li>\n<li>USER：指定容器以什么样的用户去执行，默认root</li>\n<li>ENV：用来在构建镜像过程中设置环境变量</li>\n<li>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li>\n<li>COPY：类似ADD拷贝文件和目录到镜像中</li>\n<li>VOLUME：容器数据卷用于保存数据和数据持久化</li>\n<li>CMD：指定容器启动后要干的事情</li>\n<li>ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序<br><img src=\"/blog/images/docker/dockerfile.png\"></li>\n</ol>\n","site":{"data":{}},"more":"<p>身为前端开发者的我们应该怎样理解、掌握docker？</p>\n<h3 id=\"docker的基本组成\"><a href=\"#docker的基本组成\" class=\"headerlink\" title=\"docker的基本组成\"></a>docker的基本组成</h3><p>Docker平台架构图解：docker的基本组成包含镜像（image）、容器（container）、仓库（respository）。<img src=\"/blog/images/docker/composition.png\" alt=\"平台架构图-基础版\"></p>\n<h4 id=\"镜像（image）\"><a href=\"#镜像（image）\" class=\"headerlink\" title=\"镜像（image）\"></a>镜像（image）</h4><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。<br>它也相当于是一个root文件系统。比如官方镜像 centos:7 就包含了完整的一套 centos:7 最小系统的 root 文件系统。 相当于容器的“源代码”</p>\n<h4 id=\"容器（container）\"><a href=\"#容器（container）\" class=\"headerlink\" title=\"容器（container）\"></a>容器（container）</h4><p>Docker 利用容器（Container）独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。就像是Java中的类和实例对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台.</p>\n<h4 id=\"仓库（respository）\"><a href=\"#仓库（respository）\" class=\"headerlink\" title=\"仓库（respository）\"></a>仓库（respository）</h4><p>仓库（Repository）是集中存放镜像文件的场所。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>1.<a href=\"https://www.docker.com/\">官网地址</a><br>2.<a href=\"https://hub.docker.com/\">仓库地址</a></p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><ol>\n<li>启动docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start docker</span><br></pre></td></tr></table></figure></li>\n<li>停止docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl stop docker</span><br></pre></td></tr></table></figure></li>\n<li>重启docker<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker状态<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker</span><br></pre></td></tr></table></figure></li>\n<li>开机启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure></li>\n<li>查看docker概要信息<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure></li>\n<li>帮助命令<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看总体帮助</span></span><br><span class=\"line\">docker <span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"comment\"># 查看具体命令帮助</span></span><br><span class=\"line\">docker 命令 --<span class=\"built_in\">help</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"镜像常用命令\"><a href=\"#镜像常用命令\" class=\"headerlink\" title=\"镜像常用命令\"></a>镜像常用命令</h3><ol>\n<li>查看本地镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images [options]</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">-a 列出本地所有镜像</span><br><span class=\"line\">-q 只显示镜像ID</span><br></pre></td></tr></table></figure></li>\n<li>查找镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker search [options] 镜像名称</span><br><span class=\"line\"></span><br><span class=\"line\">options:</span><br><span class=\"line\">--<span class=\"built_in\">limit</span> N 列出n个</span><br></pre></td></tr></table></figure></li>\n<li>拉取镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker pull 镜像名称[:tag] </span><br></pre></td></tr></table></figure></li>\n<li>查看镜像&#x2F;容器&#x2F;数据卷所占的空间<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不带tag默认拉取最新的镜像等同于:latest</span></span><br><span class=\"line\">docker system <span class=\"built_in\">df</span></span><br></pre></td></tr></table></figure></li>\n<li>镜像删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除某个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像ID</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除多个镜像</span></span><br><span class=\"line\">docker rmi -f 镜像名1:tag 镜像名2:tag</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除全部</span></span><br><span class=\"line\">docker rmi -f <span class=\"variable\">$&#123;docker images -qa&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>提交容器副本使之成为新的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=描述信息 -a=作者 容器ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure></li>\n<li>将指定镜像保存成 tar 归档文件<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">-o :输出到的文件</span><br></pre></td></tr></table></figure></li>\n<li>导入使用 docker save 命令导出的镜像<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker load [OPTIONS]</span><br><span class=\"line\">举例 docker load &lt; 镜像文件名</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS：</span><br><span class=\"line\">--input , -i : 指定导入的文件，代替 STDIN</span><br><span class=\"line\">--quiet , -q : 精简输出信息</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器常用命令\"><a href=\"#容器常用命令\" class=\"headerlink\" title=\"容器常用命令\"></a>容器常用命令</h3><ol>\n<li><p>新建&#x2F;启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...] </span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:有些是一个减号有些是两个减号</span><br><span class=\"line\">--name=<span class=\"string\">&quot;容器新名字&quot;</span> 为容器指定一个名称</span><br><span class=\"line\">-d: 后台运行容器并返回容器ID也即启动守护式容器(后台运行)</span><br><span class=\"line\">-i：以交互模式运行容器，通常与 -t 同时使用</span><br><span class=\"line\">-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用，也即启动交互式容器(前台有伪终端，等待交互)</span><br><span class=\"line\">-P: 随机端口映射，大写P</span><br><span class=\"line\">-p: 指定端口映射，小写p</span><br></pre></td></tr></table></figure>\n<p><img src=\"/blog/images/docker/container-options.png\" alt=\"container-options\"></p>\n</li>\n<li><p>列出当前正在运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">OPTIONS:</span><br><span class=\"line\">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class=\"line\">-l :显示最近创建的容器</span><br><span class=\"line\">-n :显示最近n个创建的容器</span><br><span class=\"line\">-q :静默模式，只显示容器编号</span><br></pre></td></tr></table></figure></li>\n<li><p>退出容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exit</span> run进入<span class=\"built_in\">exit</span>退出 容器停止</span><br><span class=\"line\">ctrl+p+q run进入ctrl+p+q退出 容器不停止</span><br></pre></td></tr></table></figure></li>\n<li><p>启动已停止运行的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>重启容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker restart 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>强制停止容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">kill</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>删除已停止的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">rm</span> 容器ID/容器name</span><br></pre></td></tr></table></figure></li>\n<li><p>启动守护式容器（后台服务器）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -d 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器日志</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker logs 容器ID</span><br><span class=\"line\"><span class=\"comment\">#跟踪查看最近100条日志</span></span><br><span class=\"line\">docker logs -f -n100</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内运行的进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker top 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>查看容器内部细节</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect 容器ID</span><br></pre></td></tr></table></figure></li>\n<li><p>进入正在运行的容器并以命令行交互</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure></li>\n<li><p>从容器内拷贝文件到主机上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">cp</span> 容器<span class=\"built_in\">id</span>:容器内路径 宿主机路径</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用命令总结<br><img src=\"/blog/images/docker/container-command.png\" alt=\"container-command\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attach    <span class=\"comment\"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">build     <span class=\"comment\"># 通过 Dockerfile 定制镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">commit    <span class=\"comment\"># 提交当前容器为新的镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cp</span>        <span class=\"comment\">#从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class=\"line\"></span><br><span class=\"line\">create    <span class=\"comment\"># 创建一个新的容器，同 run，但不启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">diff      <span class=\"comment\"># 查看 docker 容器变化</span></span><br><span class=\"line\"></span><br><span class=\"line\">events    <span class=\"comment\"># 从 docker 服务获取容器实时事件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">exec</span>      <span class=\"comment\"># 在已存在的容器上运行命令</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">export</span>    <span class=\"comment\"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">history</span>   <span class=\"comment\"># 展示一个镜像形成历史</span></span><br><span class=\"line\"></span><br><span class=\"line\">images    <span class=\"comment\"># 列出系统当前镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">import    <span class=\"comment\"># 从tar包中的内容创建一个新的文件系统映像[对应export]</span></span><br><span class=\"line\"></span><br><span class=\"line\">info      <span class=\"comment\"># 显示系统相关信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">inspect   <span class=\"comment\"># 查看容器详细信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">kill</span>      <span class=\"comment\"># kill 指定 docker 容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">load      <span class=\"comment\"># 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class=\"line\"></span><br><span class=\"line\">login     <span class=\"comment\"># 注册或者登陆一个 docker 源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">logout</span>    <span class=\"comment\"># 从当前 Docker registry 退出</span></span><br><span class=\"line\"></span><br><span class=\"line\">logs      <span class=\"comment\"># 输出当前容器日志信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">port      <span class=\"comment\"># 查看映射端口对应的容器内部源端口</span></span><br><span class=\"line\"></span><br><span class=\"line\">pause     <span class=\"comment\"># 暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">ps        <span class=\"comment\"># 列出容器列表</span></span><br><span class=\"line\"></span><br><span class=\"line\">pull      <span class=\"comment\"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">push      <span class=\"comment\"># 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class=\"line\"></span><br><span class=\"line\">restart   <span class=\"comment\"># 重启运行的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">rm</span>        <span class=\"comment\"># 移除一个或者多个容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">rmi       <span class=\"comment\"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class=\"line\"></span><br><span class=\"line\">run       <span class=\"comment\"># 创建一个新的容器并运行一个命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">save      <span class=\"comment\"># 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class=\"line\"></span><br><span class=\"line\">search    <span class=\"comment\"># 在 docker hub 中搜索镜像</span></span><br><span class=\"line\"></span><br><span class=\"line\">start     <span class=\"comment\"># 启动容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">stop      <span class=\"comment\"># 停止容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">tag       <span class=\"comment\"># 给源中镜像打标签</span></span><br><span class=\"line\"></span><br><span class=\"line\">top       <span class=\"comment\"># 查看容器中运行的进程信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">unpause   <span class=\"comment\"># 取消暂停容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">version   <span class=\"comment\"># 查看 docker 版本号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">wait</span>      <span class=\"comment\"># 截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h3><p>将docker容器中的数据保存到宿主机的磁盘中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一定要带上--privileged=true不然没有权限</span></span><br><span class=\"line\">docker run -it --privileged=<span class=\"literal\">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h3><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>\n<h4 id=\"DockerFile基础说明\"><a href=\"#DockerFile基础说明\" class=\"headerlink\" title=\"DockerFile基础说明\"></a>DockerFile基础说明</h4><ul>\n<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>\n<li>指令按照顺序，从上到下顺序执行</li>\n<li>#表示注释</li>\n<li>每条指令都会创建一个新的镜像层并对镜像进行提交</li>\n</ul>\n<h4 id=\"docker执行DockerFile流程\"><a href=\"#docker执行DockerFile流程\" class=\"headerlink\" title=\"docker执行DockerFile流程\"></a>docker执行DockerFile流程</h4><ol>\n<li>docker从基础镜像运行一个容器</li>\n<li>执行一条指令并对容器进行修改</li>\n<li>执行类似docker commit的操作提交一个新的镜像层</li>\n<li>docker再基于刚提交的镜像运行一个新容器</li>\n<li>执行docker中的下一条指令直至所有指令完成</li>\n</ol>\n<h4 id=\"常用保留字指令\"><a href=\"#常用保留字指令\" class=\"headerlink\" title=\"常用保留字指令\"></a>常用保留字指令</h4><ol>\n<li>FROM： 基础镜像</li>\n<li>MAINTAINER： 镜像维护者姓名和邮箱</li>\n<li>RUN： docker build时需要运行的命令</li>\n<li>EXPOSE：当前容器对外暴露的端口</li>\n<li>WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</li>\n<li>USER：指定容器以什么样的用户去执行，默认root</li>\n<li>ENV：用来在构建镜像过程中设置环境变量</li>\n<li>ADD：将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</li>\n<li>COPY：类似ADD拷贝文件和目录到镜像中</li>\n<li>VOLUME：容器数据卷用于保存数据和数据持久化</li>\n<li>CMD：指定容器启动后要干的事情</li>\n<li>ENTRYPOINT：用来指定一个容器启动时要运行的命令，类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序<br><img src=\"/blog/images/docker/dockerfile.png\"></li>\n</ol>\n"},{"title":"hexo-command","_content":"\n### 基本命令\n\n```bash\n# 生成静态文件\nhexo g \n# 启动本地服务\nhexo s\n# 提交到gitee\nhexo d\n# 清除缓存\nhexo clean\n\n# 通过模板生成文章\nhexo new page --path \"redis/base\"\n\n# 创建草稿\nhexo new draft <filename>\n\n# 本机预览草稿\nhexo S --draft\n\n# 草稿发布为正式文章\nhexo P <filename>\n```","source":"_drafts/hexo-command.md","raw":"---\ntitle: hexo-command\ntags: [\"hexo\"]\n---\n\n### 基本命令\n\n```bash\n# 生成静态文件\nhexo g \n# 启动本地服务\nhexo s\n# 提交到gitee\nhexo d\n# 清除缓存\nhexo clean\n\n# 通过模板生成文章\nhexo new page --path \"redis/base\"\n\n# 创建草稿\nhexo new draft <filename>\n\n# 本机预览草稿\nhexo S --draft\n\n# 草稿发布为正式文章\nhexo P <filename>\n```","slug":"hexo-command","published":0,"date":"2023-04-21T07:39:10.612Z","updated":"2023-04-21T07:42:08.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi4d00026oupfnqb8o9w","content":"<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成静态文件</span></span><br><span class=\"line\">hexo g </span><br><span class=\"line\"><span class=\"comment\"># 启动本地服务</span></span><br><span class=\"line\">hexo s</span><br><span class=\"line\"><span class=\"comment\"># 提交到gitee</span></span><br><span class=\"line\">hexo d</span><br><span class=\"line\"><span class=\"comment\"># 清除缓存</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过模板生成文章</span></span><br><span class=\"line\">hexo new page --path <span class=\"string\">&quot;redis/base&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建草稿</span></span><br><span class=\"line\">hexo new draft &lt;filename&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本机预览草稿</span></span><br><span class=\"line\">hexo S --draft</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 草稿发布为正式文章</span></span><br><span class=\"line\">hexo P &lt;filename&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成静态文件</span></span><br><span class=\"line\">hexo g </span><br><span class=\"line\"><span class=\"comment\"># 启动本地服务</span></span><br><span class=\"line\">hexo s</span><br><span class=\"line\"><span class=\"comment\"># 提交到gitee</span></span><br><span class=\"line\">hexo d</span><br><span class=\"line\"><span class=\"comment\"># 清除缓存</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 通过模板生成文章</span></span><br><span class=\"line\">hexo new page --path <span class=\"string\">&quot;redis/base&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建草稿</span></span><br><span class=\"line\">hexo new draft &lt;filename&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本机预览草稿</span></span><br><span class=\"line\">hexo S --draft</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 草稿发布为正式文章</span></span><br><span class=\"line\">hexo P &lt;filename&gt;</span><br></pre></td></tr></table></figure>"},{"title":"K8s","date":"2023-05-09T13:46:14.000Z","excerpt":"作为软件开发工程师对于k8s你可以不精通，但是不能不会。","_content":"## K8s","source":"_drafts/kubernetes/base.md","raw":"---\ntitle: K8s\ndate: 2023-05-09 21:46:14\ntags: [\"k8s\", \"架构\", \"集群\", \"运开\"]\nexcerpt: 作为软件开发工程师对于k8s你可以不精通，但是不能不会。\n---\n## K8s","slug":"kubernetes/base","published":0,"updated":"2023-05-17T09:08:34.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi4h00046oupcq8ccshp","content":"<h2 id=\"K8s\"><a href=\"#K8s\" class=\"headerlink\" title=\"K8s\"></a>K8s</h2>","site":{"data":{}},"more":"<h2 id=\"K8s\"><a href=\"#K8s\" class=\"headerlink\" title=\"K8s\"></a>K8s</h2>"},{"title":"fork之后的仓库如何同步源仓库的最新代码","date":"2023-03-10T01:38:28.000Z","excerpt":"git fork仓库之后， 源仓库代码进行了更新 fork后的仓库如何同步源仓库代码呢？","_content":"fork之后的仓库如何同步源仓库的最新代码\n\n1. 首先进入项目根目录运行`git remote -v`查看本地仓库的远程路径。\n2. 添加源仓库（上游仓库）的远程路径,命令格式`git remote add upstream ADDR`\n```git \ngit remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git\n```\n3. 查看源仓库（上游仓库）是否关联成功`git remote -v`。\n![git remote -v](/images/git/fork-remote.png)\n4. `git status`查看本事是否有代码没有commit，若有改动及时commit或者回滚。\n5. 执行`git fetch upstream`抓取源仓库（上游仓库）的最新代码。\n6. 执行`git merge upstream/master`命令合并master分支的代码。\n","source":"_posts/git/fork.md","raw":"---\ntitle: fork之后的仓库如何同步源仓库的最新代码\ndate: 2023-03-10 09:38:28\ntags: [\"git\", \"fork\"]\nexcerpt: git fork仓库之后， 源仓库代码进行了更新 fork后的仓库如何同步源仓库代码呢？\n---\nfork之后的仓库如何同步源仓库的最新代码\n\n1. 首先进入项目根目录运行`git remote -v`查看本地仓库的远程路径。\n2. 添加源仓库（上游仓库）的远程路径,命令格式`git remote add upstream ADDR`\n```git \ngit remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git\n```\n3. 查看源仓库（上游仓库）是否关联成功`git remote -v`。\n![git remote -v](/images/git/fork-remote.png)\n4. `git status`查看本事是否有代码没有commit，若有改动及时commit或者回滚。\n5. 执行`git fetch upstream`抓取源仓库（上游仓库）的最新代码。\n6. 执行`git merge upstream/master`命令合并master分支的代码。\n","slug":"git/fork","published":1,"updated":"2023-03-10T02:37:49.356Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi4j00056oup2vnfbwb7","content":"<p>fork之后的仓库如何同步源仓库的最新代码</p>\n<ol>\n<li>首先进入项目根目录运行<code>git remote -v</code>查看本地仓库的远程路径。</li>\n<li>添加源仓库（上游仓库）的远程路径,命令格式<code>git remote add upstream ADDR</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git</span><br></pre></td></tr></table></figure></li>\n<li>查看源仓库（上游仓库）是否关联成功<code>git remote -v</code>。<br><img src=\"/blog/images/git/fork-remote.png\" alt=\"git remote -v\"></li>\n<li><code>git status</code>查看本事是否有代码没有commit，若有改动及时commit或者回滚。</li>\n<li>执行<code>git fetch upstream</code>抓取源仓库（上游仓库）的最新代码。</li>\n<li>执行<code>git merge upstream/master</code>命令合并master分支的代码。</li>\n</ol>\n","site":{"data":{}},"more":"<p>fork之后的仓库如何同步源仓库的最新代码</p>\n<ol>\n<li>首先进入项目根目录运行<code>git remote -v</code>查看本地仓库的远程路径。</li>\n<li>添加源仓库（上游仓库）的远程路径,命令格式<code>git remote add upstream ADDR</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream https://gitlab.hddata.cn/T-Series/Web/gw-web-react.git</span><br></pre></td></tr></table></figure></li>\n<li>查看源仓库（上游仓库）是否关联成功<code>git remote -v</code>。<br><img src=\"/blog/images/git/fork-remote.png\" alt=\"git remote -v\"></li>\n<li><code>git status</code>查看本事是否有代码没有commit，若有改动及时commit或者回滚。</li>\n<li>执行<code>git fetch upstream</code>抓取源仓库（上游仓库）的最新代码。</li>\n<li>执行<code>git merge upstream/master</code>命令合并master分支的代码。</li>\n</ol>\n"},{"title":"go实现IoC容器","excerpt":"使用go写一个简单好用IoC容器的方法，主要演示的是思路及封装","date":"2023-05-19T06:00:18.000Z","_content":"\n## IoC\n控制反转（Inversion of Control，IoC）是一种软件设计原则，用于实现松耦合的组件之间的交互。它的核心思想是将控制权从调用者转移到外部容器或框架，由容器负责创建和管理对象的生命周期以及它们之间的依赖关系，而不是由调用者直接控制。\n所谓的容器在go里面就是map对象或者切片。\n\n## 设计\n设计Ioc初步雏形：基于类型的存储。使用map来充当容器key:reflect.Type value:reflect.value\n\n```golang\ntype BeanMapper map[reflect.Type]reflect.Value\n```\n1. 容器定义\n```golang\npackage injector\n\nimport \"reflect\"\n// 定义容器类型 key使用仿射类型 value使用反射值\ntype BeanMapper map[reflect.Type]reflect.Value\n\n// 往容器中添加元素\nfunc (this BeanMapper) add(bean interface{}) {\n\tt := reflect.TypeOf(bean)\n\tif t.Kind() != reflect.Ptr {\n\t\tpanic(\"require ptr object\")\n\t}\n\tthis[t] = reflect.ValueOf(bean)\n}\n\n// 获取容器中的bean\nfunc (this BeanMapper) get(bean interface{}) reflect.Value {\n\tvar t reflect.Type\n\tif bt, ok := bean.(reflect.Type); ok {\n\t\tt = bt\n\t} else {\n\t\tt = reflect.TypeOf(bean)\n\t}\n\tif value, ok := this[t]; ok {\n\t\treturn value\n\t}\n\t// 处理接口继承（接口方式注入） service主要实现了接口就返回\n\t// FIXME 容器中如果有多个元素实现了该接口，这里只会返回容器中匹配到的第一个元素\n\tfmt.Println(t.Kind())\n\tfmt.Println(t)\n\tfor k, v := range this {\n\t\tif t.Kind() == reflect.Interface && k.Implements(t) {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn reflect.Value{}\n}\n```\n\n2. 创建一个BeanFactory文件负责往容器中添加bean、获取bean以及依赖注入\n```golang\npackage injector\n\nimport (\n\t\"github.com/shenyisyn/goft-expr/src/expr\"\n\t\"log\"\n\t\"reflect\"\n)\n\nvar BeanFactory *BeanFactoryImpl\n\n// 引用文件的时候初始化BeanFactory\nfunc init() {\n\tBeanFactory = NewBeanFactory()\n}\n\ntype BeanFactoryImpl struct {\n\tbeanMapper BeanMapper\n\t// 字符串表达式解析\n\tExprMap map[string]interface{}\n}\n\n// NewBeanFactory 初始化容器BeanMapper对象 初始化字符串表达式映射\nfunc NewBeanFactory() *BeanFactoryImpl {\n\treturn &BeanFactoryImpl{beanMapper: make(BeanMapper), ExprMap: make(map[string]interface{})}\n}\n\nfunc (this *BeanFactoryImpl) Set(beans ...interface{}) {\n\tif beans == nil || len(beans) == 0 {\n\t\treturn\n\t}\n\tfor _, bean := range beans {\n\t\tthis.beanMapper.add(bean)\n\t}\n}\n\nfunc (this *BeanFactoryImpl) Get(val interface{}) interface{} {\n\tif val == nil {\n\t\treturn nil\n\t}\n\tgetVal := this.beanMapper.get(val)\n\tif getVal.IsValid() {\n\t\treturn getVal.Interface()\n\t}\n\treturn nil\n}\n```\n\n2. 处理依赖注入，动态注入bean（BeanFactory.go）\n![case](/images/go/ioc/case1.png)\n```golang\n// Apply 处理依赖注入 根据tag名inject以及元素类型进行注入\nfunc (this *BeanFactoryImpl) Apply(bean interface{}) {\n\tif bean == nil {\n\t\treturn\n\t}\n\tv := reflect.ValueOf(bean)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.Kind() != reflect.Struct {\n\t\treturn\n\t}\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tfield := v.Type().Field(i)\n\t\t// 判断bean首字母是否为大写，并且拥有inject标签且不能为空字符\n\t\tif v.Field(i).CanSet() && field.Tag.Get(\"inject\") != \"\" {\n\t\t\tif field.Tag.Get(\"inject\") != \"-\" {\n\t\t\t\t// 多例模式\n\t\t\t\t// 表达式方式注入\n\t\t\t\t// 字符串表达式解析执行\n\t\t\t\tlog.Println(\"使用了表达式的方式\")\n\t\t\t\t// expr用来解析执行字符串\n\t\t\t\tret := expr.BeanExpr(field.Tag.Get(\"inject\"), this.ExprMap)\n\t\t\t\tif ret != nil && !ret.IsEmpty() {\n\t\t\t\t\tretValue := ret[0]\n\t\t\t\t\tif retValue != nil {\n\t\t\t\t\t\t//this.Set(retValue)\n\t\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(retValue))\n\t\t\t\t\t\t// 递归执行依赖注入\n\t\t\t\t\t\tthis.Apply(retValue)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 单例模式\n\t\t\t\t// 兼容直接Set单个实例对象方式注入，比如Set(NewOrderService())\n\t\t\t\tif val := this.Get(field.Type); val != nil {\n\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(val))\n\t\t\t\t\t// 递归执行依赖注入\n\t\t\t\t\tthis.Apply(val)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n3. 容器初始化\n如果容器初始化bean很多，使用set方法创建bean，手动写很麻烦，如何优雅进行容器bean的加载？使用一个ConfigService.go文件用来配置所有的bean，再解析这个文件的方法，具体看如下的代码\n![case](/images/go/ioc/case2.png)\n```golang\npackage config\n\nimport \"go-ioc/src/services\"\n\ntype ServiceConfig struct {\n}\n\nfunc NewServiceConfig() *ServiceConfig {\n\treturn &ServiceConfig{}\n}\n\nfunc (this *ServiceConfig) OrderService() *services.OrderService {\n\treturn services.NewOrderService()\n}\nfunc (this *ServiceConfig) DBService() *services.DBService {\n\treturn services.NewDBService()\n}\n```\n\n加载ConfigService.go文件，容器加载所有config文件中配置的bean\n\n```golang\nfunc (this *BeanFactoryImpl) Config(cfgs ...interface{}) {\n\tfor _, cfg := range cfgs {\n\t\tt := reflect.TypeOf(cfg)\n\t\tif t.Kind() != reflect.Ptr {\n\t\t\tpanic(\"require ptr object\")\n\t\t}\n\t\tthis.Set(cfg)                       // config本身加入容器\n\t\tthis.ExprMap[t.Elem().Name()] = cfg // 自动构建ExprMap\n\n\t\tv := reflect.ValueOf(cfg)\n\t\tfor i := 0; i < v.NumMethod(); i++ {\n\t\t\tmethod := v.Method(i)\n\t\t\tcallRet := method.Call(nil)\n\t\t\tif callRet != nil && len(callRet) == 1 {\n\t\t\t\tthis.Set(callRet[0].Interface())\n\t\t\t}\n\t\t}\n\t}\n}\n```","source":"_posts/go/ioc.md","raw":"---\ntitle: go实现IoC容器\ntags:\n  - go\n  - ioc\n  - 控制反转\n  - 依赖注入\n  - reflect\nexcerpt: 使用go写一个简单好用IoC容器的方法，主要演示的是思路及封装\ndate: 2023-05-19 14:00:18\n---\n\n## IoC\n控制反转（Inversion of Control，IoC）是一种软件设计原则，用于实现松耦合的组件之间的交互。它的核心思想是将控制权从调用者转移到外部容器或框架，由容器负责创建和管理对象的生命周期以及它们之间的依赖关系，而不是由调用者直接控制。\n所谓的容器在go里面就是map对象或者切片。\n\n## 设计\n设计Ioc初步雏形：基于类型的存储。使用map来充当容器key:reflect.Type value:reflect.value\n\n```golang\ntype BeanMapper map[reflect.Type]reflect.Value\n```\n1. 容器定义\n```golang\npackage injector\n\nimport \"reflect\"\n// 定义容器类型 key使用仿射类型 value使用反射值\ntype BeanMapper map[reflect.Type]reflect.Value\n\n// 往容器中添加元素\nfunc (this BeanMapper) add(bean interface{}) {\n\tt := reflect.TypeOf(bean)\n\tif t.Kind() != reflect.Ptr {\n\t\tpanic(\"require ptr object\")\n\t}\n\tthis[t] = reflect.ValueOf(bean)\n}\n\n// 获取容器中的bean\nfunc (this BeanMapper) get(bean interface{}) reflect.Value {\n\tvar t reflect.Type\n\tif bt, ok := bean.(reflect.Type); ok {\n\t\tt = bt\n\t} else {\n\t\tt = reflect.TypeOf(bean)\n\t}\n\tif value, ok := this[t]; ok {\n\t\treturn value\n\t}\n\t// 处理接口继承（接口方式注入） service主要实现了接口就返回\n\t// FIXME 容器中如果有多个元素实现了该接口，这里只会返回容器中匹配到的第一个元素\n\tfmt.Println(t.Kind())\n\tfmt.Println(t)\n\tfor k, v := range this {\n\t\tif t.Kind() == reflect.Interface && k.Implements(t) {\n\t\t\treturn v\n\t\t}\n\t}\n\treturn reflect.Value{}\n}\n```\n\n2. 创建一个BeanFactory文件负责往容器中添加bean、获取bean以及依赖注入\n```golang\npackage injector\n\nimport (\n\t\"github.com/shenyisyn/goft-expr/src/expr\"\n\t\"log\"\n\t\"reflect\"\n)\n\nvar BeanFactory *BeanFactoryImpl\n\n// 引用文件的时候初始化BeanFactory\nfunc init() {\n\tBeanFactory = NewBeanFactory()\n}\n\ntype BeanFactoryImpl struct {\n\tbeanMapper BeanMapper\n\t// 字符串表达式解析\n\tExprMap map[string]interface{}\n}\n\n// NewBeanFactory 初始化容器BeanMapper对象 初始化字符串表达式映射\nfunc NewBeanFactory() *BeanFactoryImpl {\n\treturn &BeanFactoryImpl{beanMapper: make(BeanMapper), ExprMap: make(map[string]interface{})}\n}\n\nfunc (this *BeanFactoryImpl) Set(beans ...interface{}) {\n\tif beans == nil || len(beans) == 0 {\n\t\treturn\n\t}\n\tfor _, bean := range beans {\n\t\tthis.beanMapper.add(bean)\n\t}\n}\n\nfunc (this *BeanFactoryImpl) Get(val interface{}) interface{} {\n\tif val == nil {\n\t\treturn nil\n\t}\n\tgetVal := this.beanMapper.get(val)\n\tif getVal.IsValid() {\n\t\treturn getVal.Interface()\n\t}\n\treturn nil\n}\n```\n\n2. 处理依赖注入，动态注入bean（BeanFactory.go）\n![case](/images/go/ioc/case1.png)\n```golang\n// Apply 处理依赖注入 根据tag名inject以及元素类型进行注入\nfunc (this *BeanFactoryImpl) Apply(bean interface{}) {\n\tif bean == nil {\n\t\treturn\n\t}\n\tv := reflect.ValueOf(bean)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.Kind() != reflect.Struct {\n\t\treturn\n\t}\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tfield := v.Type().Field(i)\n\t\t// 判断bean首字母是否为大写，并且拥有inject标签且不能为空字符\n\t\tif v.Field(i).CanSet() && field.Tag.Get(\"inject\") != \"\" {\n\t\t\tif field.Tag.Get(\"inject\") != \"-\" {\n\t\t\t\t// 多例模式\n\t\t\t\t// 表达式方式注入\n\t\t\t\t// 字符串表达式解析执行\n\t\t\t\tlog.Println(\"使用了表达式的方式\")\n\t\t\t\t// expr用来解析执行字符串\n\t\t\t\tret := expr.BeanExpr(field.Tag.Get(\"inject\"), this.ExprMap)\n\t\t\t\tif ret != nil && !ret.IsEmpty() {\n\t\t\t\t\tretValue := ret[0]\n\t\t\t\t\tif retValue != nil {\n\t\t\t\t\t\t//this.Set(retValue)\n\t\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(retValue))\n\t\t\t\t\t\t// 递归执行依赖注入\n\t\t\t\t\t\tthis.Apply(retValue)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 单例模式\n\t\t\t\t// 兼容直接Set单个实例对象方式注入，比如Set(NewOrderService())\n\t\t\t\tif val := this.Get(field.Type); val != nil {\n\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(val))\n\t\t\t\t\t// 递归执行依赖注入\n\t\t\t\t\tthis.Apply(val)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n3. 容器初始化\n如果容器初始化bean很多，使用set方法创建bean，手动写很麻烦，如何优雅进行容器bean的加载？使用一个ConfigService.go文件用来配置所有的bean，再解析这个文件的方法，具体看如下的代码\n![case](/images/go/ioc/case2.png)\n```golang\npackage config\n\nimport \"go-ioc/src/services\"\n\ntype ServiceConfig struct {\n}\n\nfunc NewServiceConfig() *ServiceConfig {\n\treturn &ServiceConfig{}\n}\n\nfunc (this *ServiceConfig) OrderService() *services.OrderService {\n\treturn services.NewOrderService()\n}\nfunc (this *ServiceConfig) DBService() *services.DBService {\n\treturn services.NewDBService()\n}\n```\n\n加载ConfigService.go文件，容器加载所有config文件中配置的bean\n\n```golang\nfunc (this *BeanFactoryImpl) Config(cfgs ...interface{}) {\n\tfor _, cfg := range cfgs {\n\t\tt := reflect.TypeOf(cfg)\n\t\tif t.Kind() != reflect.Ptr {\n\t\t\tpanic(\"require ptr object\")\n\t\t}\n\t\tthis.Set(cfg)                       // config本身加入容器\n\t\tthis.ExprMap[t.Elem().Name()] = cfg // 自动构建ExprMap\n\n\t\tv := reflect.ValueOf(cfg)\n\t\tfor i := 0; i < v.NumMethod(); i++ {\n\t\t\tmethod := v.Method(i)\n\t\t\tcallRet := method.Call(nil)\n\t\t\tif callRet != nil && len(callRet) == 1 {\n\t\t\t\tthis.Set(callRet[0].Interface())\n\t\t\t}\n\t\t}\n\t}\n}\n```","slug":"go/ioc","published":1,"updated":"2023-05-19T06:13:01.153Z","_id":"clhu5qi4k00066oup9rkrfugu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h2><p>控制反转（Inversion of Control，IoC）是一种软件设计原则，用于实现松耦合的组件之间的交互。它的核心思想是将控制权从调用者转移到外部容器或框架，由容器负责创建和管理对象的生命周期以及它们之间的依赖关系，而不是由调用者直接控制。<br>所谓的容器在go里面就是map对象或者切片。</p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p>设计Ioc初步雏形：基于类型的存储。使用map来充当容器key:reflect.Type value:reflect.value</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BeanMapper <span class=\"keyword\">map</span>[reflect.Type]reflect.Value</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>容器定义</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> injector</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 定义容器类型 key使用仿射类型 value使用反射值</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> BeanMapper <span class=\"keyword\">map</span>[reflect.Type]reflect.Value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 往容器中添加元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this BeanMapper)</span></span> add(bean <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\tt := reflect.TypeOf(bean)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;require ptr object&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis[t] = reflect.ValueOf(bean)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取容器中的bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this BeanMapper)</span></span> get(bean <span class=\"keyword\">interface</span>&#123;&#125;) reflect.Value &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t reflect.Type</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bt, ok := bean.(reflect.Type); ok &#123;</span><br><span class=\"line\">\t\tt = bt</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tt = reflect.TypeOf(bean)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> value, ok := this[t]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> value</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理接口继承（接口方式注入） service主要实现了接口就返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// FIXME 容器中如果有多个元素实现了该接口，这里只会返回容器中匹配到的第一个元素</span></span><br><span class=\"line\">\tfmt.Println(t.Kind())</span><br><span class=\"line\">\tfmt.Println(t)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> this &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Kind() == reflect.Interface &amp;&amp; k.Implements(t) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> reflect.Value&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个BeanFactory文件负责往容器中添加bean、获取bean以及依赖注入</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> injector</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/shenyisyn/goft-expr/src/expr&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> BeanFactory *BeanFactoryImpl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用文件的时候初始化BeanFactory</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tBeanFactory = NewBeanFactory()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> BeanFactoryImpl <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbeanMapper BeanMapper</span><br><span class=\"line\">\t<span class=\"comment\">// 字符串表达式解析</span></span><br><span class=\"line\">\tExprMap <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewBeanFactory 初始化容器BeanMapper对象 初始化字符串表达式映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBeanFactory</span><span class=\"params\">()</span></span> *BeanFactoryImpl &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;BeanFactoryImpl&#123;beanMapper: <span class=\"built_in\">make</span>(BeanMapper), ExprMap: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Set(beans ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> beans == <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(beans) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, bean := <span class=\"keyword\">range</span> beans &#123;</span><br><span class=\"line\">\t\tthis.beanMapper.add(bean)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Get(val <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> val == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetVal := this.beanMapper.get(val)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> getVal.IsValid() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> getVal.Interface()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理依赖注入，动态注入bean（BeanFactory.go）<br><img src=\"/blog/images/go/ioc/case1.png\" alt=\"case\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Apply 处理依赖注入 根据tag名inject以及元素类型进行注入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Apply(bean <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bean == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tv := reflect.ValueOf(bean)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">\t\tv = v.Elem()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v.Kind() != reflect.Struct &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class=\"line\">\t\tfield := v.Type().Field(i)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断bean首字母是否为大写，并且拥有inject标签且不能为空字符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v.Field(i).CanSet() &amp;&amp; field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>) != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>) != <span class=\"string\">&quot;-&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 多例模式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 表达式方式注入</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 字符串表达式解析执行</span></span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;使用了表达式的方式&quot;</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// expr用来解析执行字符串</span></span><br><span class=\"line\">\t\t\t\tret := expr.BeanExpr(field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>), this.ExprMap)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ret != <span class=\"literal\">nil</span> &amp;&amp; !ret.IsEmpty() &#123;</span><br><span class=\"line\">\t\t\t\t\tretValue := ret[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> retValue != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//this.Set(retValue)</span></span><br><span class=\"line\">\t\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(retValue))</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 递归执行依赖注入</span></span><br><span class=\"line\">\t\t\t\t\t\tthis.Apply(retValue)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 单例模式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 兼容直接Set单个实例对象方式注入，比如Set(NewOrderService())</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> val := this.Get(field.Type); val != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(val))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 递归执行依赖注入</span></span><br><span class=\"line\">\t\t\t\t\tthis.Apply(val)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>容器初始化<br>如果容器初始化bean很多，使用set方法创建bean，手动写很麻烦，如何优雅进行容器bean的加载？使用一个ConfigService.go文件用来配置所有的bean，再解析这个文件的方法，具体看如下的代码<br><img src=\"/blog/images/go/ioc/case2.png\" alt=\"case\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;go-ioc/src/services&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ServiceConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServiceConfig</span><span class=\"params\">()</span></span> *ServiceConfig &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ServiceConfig&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ServiceConfig)</span></span> OrderService() *services.OrderService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> services.NewOrderService()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ServiceConfig)</span></span> DBService() *services.DBService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> services.NewDBService()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>加载ConfigService.go文件，容器加载所有config文件中配置的bean</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Config(cfgs ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cfg := <span class=\"keyword\">range</span> cfgs &#123;</span><br><span class=\"line\">\t\tt := reflect.TypeOf(cfg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;require ptr object&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthis.Set(cfg)                       <span class=\"comment\">// config本身加入容器</span></span><br><span class=\"line\">\t\tthis.ExprMap[t.Elem().Name()] = cfg <span class=\"comment\">// 自动构建ExprMap</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tv := reflect.ValueOf(cfg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class=\"line\">\t\t\tmethod := v.Method(i)</span><br><span class=\"line\">\t\t\tcallRet := method.Call(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> callRet != <span class=\"literal\">nil</span> &amp;&amp; <span class=\"built_in\">len</span>(callRet) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\tthis.Set(callRet[<span class=\"number\">0</span>].Interface())</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"more":"<h2 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h2><p>控制反转（Inversion of Control，IoC）是一种软件设计原则，用于实现松耦合的组件之间的交互。它的核心思想是将控制权从调用者转移到外部容器或框架，由容器负责创建和管理对象的生命周期以及它们之间的依赖关系，而不是由调用者直接控制。<br>所谓的容器在go里面就是map对象或者切片。</p>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p>设计Ioc初步雏形：基于类型的存储。使用map来充当容器key:reflect.Type value:reflect.value</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> BeanMapper <span class=\"keyword\">map</span>[reflect.Type]reflect.Value</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>容器定义</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> injector</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 定义容器类型 key使用仿射类型 value使用反射值</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> BeanMapper <span class=\"keyword\">map</span>[reflect.Type]reflect.Value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 往容器中添加元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this BeanMapper)</span></span> add(bean <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\tt := reflect.TypeOf(bean)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;require ptr object&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tthis[t] = reflect.ValueOf(bean)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取容器中的bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this BeanMapper)</span></span> get(bean <span class=\"keyword\">interface</span>&#123;&#125;) reflect.Value &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t reflect.Type</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bt, ok := bean.(reflect.Type); ok &#123;</span><br><span class=\"line\">\t\tt = bt</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tt = reflect.TypeOf(bean)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> value, ok := this[t]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> value</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理接口继承（接口方式注入） service主要实现了接口就返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// FIXME 容器中如果有多个元素实现了该接口，这里只会返回容器中匹配到的第一个元素</span></span><br><span class=\"line\">\tfmt.Println(t.Kind())</span><br><span class=\"line\">\tfmt.Println(t)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> this &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Kind() == reflect.Interface &amp;&amp; k.Implements(t) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> reflect.Value&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个BeanFactory文件负责往容器中添加bean、获取bean以及依赖注入</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> injector</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/shenyisyn/goft-expr/src/expr&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> BeanFactory *BeanFactoryImpl</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引用文件的时候初始化BeanFactory</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tBeanFactory = NewBeanFactory()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> BeanFactoryImpl <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbeanMapper BeanMapper</span><br><span class=\"line\">\t<span class=\"comment\">// 字符串表达式解析</span></span><br><span class=\"line\">\tExprMap <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewBeanFactory 初始化容器BeanMapper对象 初始化字符串表达式映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewBeanFactory</span><span class=\"params\">()</span></span> *BeanFactoryImpl &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;BeanFactoryImpl&#123;beanMapper: <span class=\"built_in\">make</span>(BeanMapper), ExprMap: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Set(beans ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> beans == <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(beans) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, bean := <span class=\"keyword\">range</span> beans &#123;</span><br><span class=\"line\">\t\tthis.beanMapper.add(bean)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Get(val <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> val == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgetVal := this.beanMapper.get(val)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> getVal.IsValid() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> getVal.Interface()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理依赖注入，动态注入bean（BeanFactory.go）<br><img src=\"/blog/images/go/ioc/case1.png\" alt=\"case\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Apply 处理依赖注入 根据tag名inject以及元素类型进行注入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Apply(bean <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> bean == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tv := reflect.ValueOf(bean)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">\t\tv = v.Elem()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v.Kind() != reflect.Struct &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class=\"line\">\t\tfield := v.Type().Field(i)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断bean首字母是否为大写，并且拥有inject标签且不能为空字符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> v.Field(i).CanSet() &amp;&amp; field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>) != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>) != <span class=\"string\">&quot;-&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 多例模式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 表达式方式注入</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 字符串表达式解析执行</span></span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;使用了表达式的方式&quot;</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// expr用来解析执行字符串</span></span><br><span class=\"line\">\t\t\t\tret := expr.BeanExpr(field.Tag.Get(<span class=\"string\">&quot;inject&quot;</span>), this.ExprMap)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ret != <span class=\"literal\">nil</span> &amp;&amp; !ret.IsEmpty() &#123;</span><br><span class=\"line\">\t\t\t\t\tretValue := ret[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> retValue != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">//this.Set(retValue)</span></span><br><span class=\"line\">\t\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(retValue))</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 递归执行依赖注入</span></span><br><span class=\"line\">\t\t\t\t\t\tthis.Apply(retValue)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 单例模式</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 兼容直接Set单个实例对象方式注入，比如Set(NewOrderService())</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> val := this.Get(field.Type); val != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tv.Field(i).Set(reflect.ValueOf(val))</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 递归执行依赖注入</span></span><br><span class=\"line\">\t\t\t\t\tthis.Apply(val)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>容器初始化<br>如果容器初始化bean很多，使用set方法创建bean，手动写很麻烦，如何优雅进行容器bean的加载？使用一个ConfigService.go文件用来配置所有的bean，再解析这个文件的方法，具体看如下的代码<br><img src=\"/blog/images/go/ioc/case2.png\" alt=\"case\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;go-ioc/src/services&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ServiceConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServiceConfig</span><span class=\"params\">()</span></span> *ServiceConfig &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;ServiceConfig&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ServiceConfig)</span></span> OrderService() *services.OrderService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> services.NewOrderService()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *ServiceConfig)</span></span> DBService() *services.DBService &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> services.NewDBService()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>加载ConfigService.go文件，容器加载所有config文件中配置的bean</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *BeanFactoryImpl)</span></span> Config(cfgs ...<span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, cfg := <span class=\"keyword\">range</span> cfgs &#123;</span><br><span class=\"line\">\t\tt := reflect.TypeOf(cfg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> t.Kind() != reflect.Ptr &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;require ptr object&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthis.Set(cfg)                       <span class=\"comment\">// config本身加入容器</span></span><br><span class=\"line\">\t\tthis.ExprMap[t.Elem().Name()] = cfg <span class=\"comment\">// 自动构建ExprMap</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tv := reflect.ValueOf(cfg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class=\"line\">\t\t\tmethod := v.Method(i)</span><br><span class=\"line\">\t\t\tcallRet := method.Call(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> callRet != <span class=\"literal\">nil</span> &amp;&amp; <span class=\"built_in\">len</span>(callRet) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\tthis.Set(callRet[<span class=\"number\">0</span>].Interface())</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"go 日志记录最佳实践","date":"2023-03-10T02:44:27.000Z","excerpt":"golang项目中使用gorus + rotatelogs + ifshook实现日志记录","_content":"- [logrus](https://github.com/sirupsen/logrus)是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。\n- [file-rotatelogs](https://github.com/lestrrat-go/file-rotatelogs)实现了 io.Writer 接口，并且提供了文件的切割功能。\n- [lfshook](https://github.com/rifflock/lfshook)决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT / JSON）。\n\n- 完整示例代码\n```golang\npackage pkg\n\nimport (\n\trotatelogs \"github.com/lestrrat-go/file-rotatelogs\"\n\t\"github.com/rifflock/lfshook\"\n\t\"github.com/sirupsen/logrus\"\n\t\"go-package/config\"\n\t\"os\"\n\t\"path\"\n\t\"time\"\n)\n\nvar (\n\tLogger      *logrus.Logger\n\tlogFileName string = \"server_log\"\n\tLocation, _        = time.LoadLocation(\"Asia/Shanghai\")\n)\n\nfunc InitLogger() {\n\t// 实例化logrus\n\tLogger = logrus.New()\n\t// 设置日志级别\n\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)\n\tif err != nil {\n\t\tlevel = logrus.InfoLevel\n\t}\n\tLogger.SetLevel(level)\n\n\tlogFileStat()\n\n\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)\n\t// 使用rotatelogs进行日志切割\n\tlogWriter, err := rotatelogs.New(\n\t\tfileName+\".%Y%m%d%H%M.log\",\n\t\t// 生成软链，指向最新日志文件\n\t\trotatelogs.WithLinkName(fileName),\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\tdebugWriter, err := rotatelogs.New(\n\t\tfileName+\"_debug\"+\".%Y%m%d%H%M.log\",\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\n\t// 使用lfshook设置不同类型日志进行不同的切割方式\n\twriteMap := lfshook.WriterMap{\n\t\tlogrus.InfoLevel:  logWriter,\n\t\tlogrus.FatalLevel: logWriter,\n\t\tlogrus.DebugLevel: debugWriter,\n\t\tlogrus.WarnLevel:  logWriter,\n\t\tlogrus.ErrorLevel: logWriter,\n\t\tlogrus.PanicLevel: logWriter,\n\t}\n\tLogger.AddHook(lfshook.NewHook(writeMap, &logrus.JSONFormatter{\n\t\tTimestampFormat: \"2006-01-02 15:04:05\",\n\t}))\n}\n\n/**\n * 检测日志文件是否存在\n */\nfunc logFileStat() {\n\tlogPath := path.Join(config.Cfg.Server.LogPath)\n\tif _, err := os.Stat(logPath); os.IsNotExist(err) {\n\t\tos.Mkdir(logPath, os.ModePerm)\n\t\tos.Chmod(logPath, 0755)\n\t}\n}\n```","source":"_posts/go/log.md","raw":"---\ntitle: go 日志记录最佳实践\ndate: 2023-03-10 10:44:27\ntags: [\"go\", \"gorus\", \"rotatelogs\", \"ifshook\"]\nexcerpt: golang项目中使用gorus + rotatelogs + ifshook实现日志记录\n---\n- [logrus](https://github.com/sirupsen/logrus)是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。\n- [file-rotatelogs](https://github.com/lestrrat-go/file-rotatelogs)实现了 io.Writer 接口，并且提供了文件的切割功能。\n- [lfshook](https://github.com/rifflock/lfshook)决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT / JSON）。\n\n- 完整示例代码\n```golang\npackage pkg\n\nimport (\n\trotatelogs \"github.com/lestrrat-go/file-rotatelogs\"\n\t\"github.com/rifflock/lfshook\"\n\t\"github.com/sirupsen/logrus\"\n\t\"go-package/config\"\n\t\"os\"\n\t\"path\"\n\t\"time\"\n)\n\nvar (\n\tLogger      *logrus.Logger\n\tlogFileName string = \"server_log\"\n\tLocation, _        = time.LoadLocation(\"Asia/Shanghai\")\n)\n\nfunc InitLogger() {\n\t// 实例化logrus\n\tLogger = logrus.New()\n\t// 设置日志级别\n\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)\n\tif err != nil {\n\t\tlevel = logrus.InfoLevel\n\t}\n\tLogger.SetLevel(level)\n\n\tlogFileStat()\n\n\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)\n\t// 使用rotatelogs进行日志切割\n\tlogWriter, err := rotatelogs.New(\n\t\tfileName+\".%Y%m%d%H%M.log\",\n\t\t// 生成软链，指向最新日志文件\n\t\trotatelogs.WithLinkName(fileName),\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\tdebugWriter, err := rotatelogs.New(\n\t\tfileName+\"_debug\"+\".%Y%m%d%H%M.log\",\n\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*24),\n\t\trotatelogs.WithRotationTime(24*time.Hour),\n\t)\n\tif err != nil {\n\t\tlogrus.Fatal(\"logger rotatelogs.New error:\", err)\n\t}\n\n\t// 使用lfshook设置不同类型日志进行不同的切割方式\n\twriteMap := lfshook.WriterMap{\n\t\tlogrus.InfoLevel:  logWriter,\n\t\tlogrus.FatalLevel: logWriter,\n\t\tlogrus.DebugLevel: debugWriter,\n\t\tlogrus.WarnLevel:  logWriter,\n\t\tlogrus.ErrorLevel: logWriter,\n\t\tlogrus.PanicLevel: logWriter,\n\t}\n\tLogger.AddHook(lfshook.NewHook(writeMap, &logrus.JSONFormatter{\n\t\tTimestampFormat: \"2006-01-02 15:04:05\",\n\t}))\n}\n\n/**\n * 检测日志文件是否存在\n */\nfunc logFileStat() {\n\tlogPath := path.Join(config.Cfg.Server.LogPath)\n\tif _, err := os.Stat(logPath); os.IsNotExist(err) {\n\t\tos.Mkdir(logPath, os.ModePerm)\n\t\tos.Chmod(logPath, 0755)\n\t}\n}\n```","slug":"go/log","published":1,"updated":"2023-03-11T07:22:27.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi4l00086oup4lzp3qn0","content":"<ul>\n<li><p><a href=\"https://github.com/sirupsen/logrus\">logrus</a>是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。</p>\n</li>\n<li><p><a href=\"https://github.com/lestrrat-go/file-rotatelogs\">file-rotatelogs</a>实现了 io.Writer 接口，并且提供了文件的切割功能。</p>\n</li>\n<li><p><a href=\"https://github.com/rifflock/lfshook\">lfshook</a>决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT &#x2F; JSON）。</p>\n</li>\n<li><p>完整示例代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\trotatelogs <span class=\"string\">&quot;github.com/lestrrat-go/file-rotatelogs&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/rifflock/lfshook&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;go-package/config&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tLogger      *logrus.Logger</span><br><span class=\"line\">\tlogFileName <span class=\"type\">string</span> = <span class=\"string\">&quot;server_log&quot;</span></span><br><span class=\"line\">\tLocation, _        = time.LoadLocation(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitLogger</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例化logrus</span></span><br><span class=\"line\">\tLogger = logrus.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 设置日志级别</span></span><br><span class=\"line\">\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlevel = logrus.InfoLevel</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.SetLevel(level)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlogFileStat()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)</span><br><span class=\"line\">\t<span class=\"comment\">// 使用rotatelogs进行日志切割</span></span><br><span class=\"line\">\tlogWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 生成软链，指向最新日志文件</span></span><br><span class=\"line\">\t\trotatelogs.WithLinkName(fileName),</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdebugWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;_debug&quot;</span>+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用lfshook设置不同类型日志进行不同的切割方式</span></span><br><span class=\"line\">\twriteMap := lfshook.WriterMap&#123;</span><br><span class=\"line\">\t\tlogrus.InfoLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.FatalLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.DebugLevel: debugWriter,</span><br><span class=\"line\">\t\tlogrus.WarnLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.ErrorLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.PanicLevel: logWriter,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.AddHook(lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123;</span><br><span class=\"line\">\t\tTimestampFormat: <span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span>,</span><br><span class=\"line\">\t&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检测日志文件是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logFileStat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlogPath := path.Join(config.Cfg.Server.LogPath)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(logPath); os.IsNotExist(err) &#123;</span><br><span class=\"line\">\t\tos.Mkdir(logPath, os.ModePerm)</span><br><span class=\"line\">\t\tos.Chmod(logPath, <span class=\"number\">0755</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"more":"<ul>\n<li><p><a href=\"https://github.com/sirupsen/logrus\">logrus</a>是一个用于Go（golang）的结构化记录器，与标准库记录器完全API兼容。</p>\n</li>\n<li><p><a href=\"https://github.com/lestrrat-go/file-rotatelogs\">file-rotatelogs</a>实现了 io.Writer 接口，并且提供了文件的切割功能。</p>\n</li>\n<li><p><a href=\"https://github.com/rifflock/lfshook\">lfshook</a>决定哪些级别的日志可以使用rotatelogs的切割设置，并决定输出格式（TEXT &#x2F; JSON）。</p>\n</li>\n<li><p>完整示例代码</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\trotatelogs <span class=\"string\">&quot;github.com/lestrrat-go/file-rotatelogs&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/rifflock/lfshook&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;go-package/config&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;path&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tLogger      *logrus.Logger</span><br><span class=\"line\">\tlogFileName <span class=\"type\">string</span> = <span class=\"string\">&quot;server_log&quot;</span></span><br><span class=\"line\">\tLocation, _        = time.LoadLocation(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitLogger</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 实例化logrus</span></span><br><span class=\"line\">\tLogger = logrus.New()</span><br><span class=\"line\">\t<span class=\"comment\">// 设置日志级别</span></span><br><span class=\"line\">\tlevel, err := logrus.ParseLevel(config.Cfg.Server.LogLevel)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlevel = logrus.InfoLevel</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.SetLevel(level)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlogFileStat()</span><br><span class=\"line\"></span><br><span class=\"line\">\tfileName := path.Join(config.Cfg.Server.LogPath, logFileName)</span><br><span class=\"line\">\t<span class=\"comment\">// 使用rotatelogs进行日志切割</span></span><br><span class=\"line\">\tlogWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// 生成软链，指向最新日志文件</span></span><br><span class=\"line\">\t\trotatelogs.WithLinkName(fileName),</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdebugWriter, err := rotatelogs.New(</span><br><span class=\"line\">\t\tfileName+<span class=\"string\">&quot;_debug&quot;</span>+<span class=\"string\">&quot;.%Y%m%d%H%M.log&quot;</span>,</span><br><span class=\"line\">\t\trotatelogs.WithMaxAge(time.Duration(config.Cfg.Server.LogExpired)*time.Hour*<span class=\"number\">24</span>),</span><br><span class=\"line\">\t\trotatelogs.WithRotationTime(<span class=\"number\">24</span>*time.Hour),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlogrus.Fatal(<span class=\"string\">&quot;logger rotatelogs.New error:&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用lfshook设置不同类型日志进行不同的切割方式</span></span><br><span class=\"line\">\twriteMap := lfshook.WriterMap&#123;</span><br><span class=\"line\">\t\tlogrus.InfoLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.FatalLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.DebugLevel: debugWriter,</span><br><span class=\"line\">\t\tlogrus.WarnLevel:  logWriter,</span><br><span class=\"line\">\t\tlogrus.ErrorLevel: logWriter,</span><br><span class=\"line\">\t\tlogrus.PanicLevel: logWriter,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tLogger.AddHook(lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123;</span><br><span class=\"line\">\t\tTimestampFormat: <span class=\"string\">&quot;2006-01-02 15:04:05&quot;</span>,</span><br><span class=\"line\">\t&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检测日志文件是否存在</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logFileStat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tlogPath := path.Join(config.Cfg.Server.LogPath)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, err := os.Stat(logPath); os.IsNotExist(err) &#123;</span><br><span class=\"line\">\t\tos.Mkdir(logPath, os.ModePerm)</span><br><span class=\"line\">\t\tos.Chmod(logPath, <span class=\"number\">0755</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"go高并发模式之管道模式","date":"2023-03-29T23:48:00.000Z","excerpt":"go语言精髓之一就是高度支持并发性，以下就是结合设计模式的管道模式演绎下golang的高并发场景处理。","_content":"\n### 什么是管道模式？\n白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。\n```bash\n#Linux命令举例\ncat log.txt | grep \"hello\" | head xx\n```\n\n### go当中的管道模式形式\n举例：\n\n从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：\n\n![流程图](/images/go/pipe/pipe1.png)\n\n使用go编写类似于管道的形式的代码大概如下所示：\n```golang\nimport \"fmt\"\n\n// Events 找出偶数\nfunc Events(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        if input[i]%2 == 0 {\n        out = append(out, input[i])\n    }\n    return out\n}\n\n// M2 数字乘2\nfunc M2(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*2)\n    }\n    return out\n}\n\n// M5 数字乘5\nfunc M5(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*5)\n    }\n    return out\n}\n\n// Cmd 定义管道函数的参数类型\ntype Cmd func(list []int) (ret []int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 Cmd, f3 Cmd) []int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    res := Pipe(nums, Events, M2, M5)\n    for _, val := range res {\n        fmt.Printf(\"%d \", val)\n    }\n}\n```\n上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；\n\n### 使用channel优化\n加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：\n\n![加入chan的流程图](/images/go/pipe/pipe2.png)\n\n约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。\n```golang\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < len(input); i++ {\n            if input[i]%2 == 0 {\n                ch <- input[i]\n            }\n        }\n    }()\n    return ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 2\n        }\n    }()\n    return ch\n}\n// M5 将偶数乘以5\nfunc M5(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 5\n        }\n    }()\n    return ch\n}\n\ntype Cmd func([]int) chan int\n// PipeCmd 定义管道函数的参数类型\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 PipeCmd, f3 PipeCmd) chan int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    wg := sync.WaitGroup{}\n    res := Pipe(nums, Events, M2, M5)\n    for v := range res {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            fmt.Printf(\"%d \", v)\n        }()\n    }\n    wg.Wait()\n}\n\n```\n\n### 管道模式之多路复用\n白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：\n\n![多路复用流程图](/images/go/pipe/pipe3.png)\n\n```golang\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := 0; i < len(input); i++ {\n\t\t\tif input[i]%2 == 0 {\n\t\t\t\tch <- input[i]\n\t\t\t}\n\t\t}\n\t}()\n\treturn ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := range input {\n\t\t\ttime.Sleep(time.Second * 2)\n\t\t\tch <- i * 2\n\t\t}\n\t}()\n\treturn ch\n}\n\ntype Cmd func([]int) chan int\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, ps ...PipeCmd) chan int {\n\twg := sync.WaitGroup{}\n\tevench := f1(nums) // 找偶数\n\tout := make(chan int)\n\tfor _, p := range ps {\n\t\tgetChan := p(evench)\n\t\twg.Add(1)\n\t\tgo func(ch chan int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor c := range ch {\n\t\t\t\tout <- c\n\t\t\t}\n\t\t}(getChan)\n\t}\n\tgo func() {\n\t\tdefer close(out)\n\t\twg.Wait()\n\t}()\n\treturn out\n}\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n\tres := Pipe(nums, Events, M2, M2)\n\tfor v := range res {\n\t\tfmt.Printf(\"%d \", v)\n\t}\n}\n\n```\n\n完整代码查看：https://github.com/nhdeng/gopipe","source":"_posts/go/pipe.md","raw":"---\ntitle: go高并发模式之管道模式\ndate: 2023-03-30 07:48:00\ntags: [\"go\", \"pipe\", \"channel\"]\nexcerpt: go语言精髓之一就是高度支持并发性，以下就是结合设计模式的管道模式演绎下golang的高并发场景处理。\n---\n\n### 什么是管道模式？\n白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。\n```bash\n#Linux命令举例\ncat log.txt | grep \"hello\" | head xx\n```\n\n### go当中的管道模式形式\n举例：\n\n从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：\n\n![流程图](/images/go/pipe/pipe1.png)\n\n使用go编写类似于管道的形式的代码大概如下所示：\n```golang\nimport \"fmt\"\n\n// Events 找出偶数\nfunc Events(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        if input[i]%2 == 0 {\n        out = append(out, input[i])\n    }\n    return out\n}\n\n// M2 数字乘2\nfunc M2(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*2)\n    }\n    return out\n}\n\n// M5 数字乘5\nfunc M5(input []int) []int {\n    out := make([]int, 0)\n    for i := 0; i < len(input); i++ {\n        out = append(out, input[i]*5)\n    }\n    return out\n}\n\n// Cmd 定义管道函数的参数类型\ntype Cmd func(list []int) (ret []int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 Cmd, f3 Cmd) []int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    res := Pipe(nums, Events, M2, M5)\n    for _, val := range res {\n        fmt.Printf(\"%d \", val)\n    }\n}\n```\n上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；\n\n### 使用channel优化\n加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：\n\n![加入chan的流程图](/images/go/pipe/pipe2.png)\n\n约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。\n```golang\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < len(input); i++ {\n            if input[i]%2 == 0 {\n                ch <- input[i]\n            }\n        }\n    }()\n    return ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 2\n        }\n    }()\n    return ch\n}\n// M5 将偶数乘以5\nfunc M5(input chan int) chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := range input {\n            time.Sleep(time.Second * 2)\n            ch <- i * 5\n        }\n    }()\n    return ch\n}\n\ntype Cmd func([]int) chan int\n// PipeCmd 定义管道函数的参数类型\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, f2 PipeCmd, f3 PipeCmd) chan int {\n    return f3(f2(f1(nums)))\n}\n\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n    wg := sync.WaitGroup{}\n    res := Pipe(nums, Events, M2, M5)\n    for v := range res {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            fmt.Printf(\"%d \", v)\n        }()\n    }\n    wg.Wait()\n}\n\n```\n\n### 管道模式之多路复用\n白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：\n\n![多路复用流程图](/images/go/pipe/pipe3.png)\n\n```golang\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Events 从切片中找出偶数\nfunc Events(input []int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := 0; i < len(input); i++ {\n\t\t\tif input[i]%2 == 0 {\n\t\t\t\tch <- input[i]\n\t\t\t}\n\t\t}\n\t}()\n\treturn ch\n}\n\n// M2 将偶数乘以2\nfunc M2(input chan int) chan int {\n\tch := make(chan int)\n\tgo func() {\n\t\tdefer close(ch)\n\t\tfor i := range input {\n\t\t\ttime.Sleep(time.Second * 2)\n\t\t\tch <- i * 2\n\t\t}\n\t}()\n\treturn ch\n}\n\ntype Cmd func([]int) chan int\ntype PipeCmd func(ch chan int) (ret chan int)\n\n// Pipe 管道函数\nfunc Pipe(nums []int, f1 Cmd, ps ...PipeCmd) chan int {\n\twg := sync.WaitGroup{}\n\tevench := f1(nums) // 找偶数\n\tout := make(chan int)\n\tfor _, p := range ps {\n\t\tgetChan := p(evench)\n\t\twg.Add(1)\n\t\tgo func(ch chan int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor c := range ch {\n\t\t\t\tout <- c\n\t\t\t}\n\t\t}(getChan)\n\t}\n\tgo func() {\n\t\tdefer close(out)\n\t\twg.Wait()\n\t}()\n\treturn out\n}\n// Test 示例调用管道函数\nfunc Test() {\n    nums := []int{1, 2, 3, 4, 6, 8, 9, 11, 32}\n\tres := Pipe(nums, Events, M2, M2)\n\tfor v := range res {\n\t\tfmt.Printf(\"%d \", v)\n\t}\n}\n\n```\n\n完整代码查看：https://github.com/nhdeng/gopipe","slug":"go/pipe","published":1,"updated":"2023-03-30T05:57:17.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi4m00096ouph3gy79jw","content":"<h3 id=\"什么是管道模式？\"><a href=\"#什么是管道模式？\" class=\"headerlink\" title=\"什么是管道模式？\"></a>什么是管道模式？</h3><p>白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Linux命令举例</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> log.txt | grep <span class=\"string\">&quot;hello&quot;</span> | <span class=\"built_in\">head</span> xx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"go当中的管道模式形式\"><a href=\"#go当中的管道模式形式\" class=\"headerlink\" title=\"go当中的管道模式形式\"></a>go当中的管道模式形式</h3><p>举例：</p>\n<p>从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe1.png\" alt=\"流程图\"></p>\n<p>使用go编写类似于管道的形式的代码大概如下所示：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 数字乘2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M5 数字乘5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">5</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(list []<span class=\"type\">int</span>)</span></span> (ret []<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 Cmd, f3 Cmd)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；</p>\n<h3 id=\"使用channel优化\"><a href=\"#使用channel优化\" class=\"headerlink\" title=\"使用channel优化\"></a>使用channel优化</h3><p>加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe2.png\" alt=\"加入chan的流程图\"></p>\n<p>约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                ch &lt;- input[i]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// M5 将偶数乘以5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">5</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"comment\">// PipeCmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 PipeCmd, f3 PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管道模式之多路复用\"><a href=\"#管道模式之多路复用\" class=\"headerlink\" title=\"管道模式之多路复用\"></a>管道模式之多路复用</h3><p>白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe3.png\" alt=\"多路复用流程图\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tch &lt;- input[i]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, ps ...PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\twg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\tevench := f1(nums) <span class=\"comment\">// 找偶数</span></span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, p := <span class=\"keyword\">range</span> ps &#123;</span><br><span class=\"line\">\t\tgetChan := p(evench)</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> c := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\t\t\t\tout &lt;- c</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;(getChan)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t\twg.Wait()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">\tres := Pipe(nums, Events, M2, M2)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完整代码查看：<a href=\"https://github.com/nhdeng/gopipe\">https://github.com/nhdeng/gopipe</a></p>\n","site":{"data":{}},"more":"<h3 id=\"什么是管道模式？\"><a href=\"#什么是管道模式？\" class=\"headerlink\" title=\"什么是管道模式？\"></a>什么是管道模式？</h3><p>白话解释就是前面每一个进程的输出（stdout)直接作为下一个进程的输入（stdin）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Linux命令举例</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> log.txt | grep <span class=\"string\">&quot;hello&quot;</span> | <span class=\"built_in\">head</span> xx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"go当中的管道模式形式\"><a href=\"#go当中的管道模式形式\" class=\"headerlink\" title=\"go当中的管道模式形式\"></a>go当中的管道模式形式</h3><p>举例：</p>\n<p>从一个数字切片中选出偶数，乘以2，再乘以5，最后输出，假设这个举例分为三步操作流程如下所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe1.png\" alt=\"流程图\"></p>\n<p>使用go编写类似于管道的形式的代码大概如下所示：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 数字乘2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M5 数字乘5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    out := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">        out = <span class=\"built_in\">append</span>(out, input[i]*<span class=\"number\">5</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Cmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(list []<span class=\"type\">int</span>)</span></span> (ret []<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 Cmd, f3 Cmd)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, val)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码执行起来肯定没有问题，但是会一步一步进行执行：先找出所有偶数，再将所有偶数乘以2，最后将所有偶数乘以5；</p>\n<h3 id=\"使用channel优化\"><a href=\"#使用channel优化\" class=\"headerlink\" title=\"使用channel优化\"></a>使用channel优化</h3><p>加入golang的channel使管道”流畅“（以channel的方式进行优化，不会造成堵塞），步骤一”找出偶数“每找出一个，就进入管道进入下一步”乘以2“的流程，而无需等到找出所有的偶数之后才进入下一步，如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe2.png\" alt=\"加入chan的流程图\"></p>\n<p>约定：凡是支持管道模式的函数，其参数必须是channel，返回也是channel。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                ch &lt;- input[i]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// M5 将偶数乘以5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M5</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">            time.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">            ch &lt;- i * <span class=\"number\">5</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"comment\">// PipeCmd 定义管道函数的参数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, f2 PipeCmd, f3 PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f3(f2(f1(nums)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">    wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">    res := Pipe(nums, Events, M2, M5)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">        wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管道模式之多路复用\"><a href=\"#管道模式之多路复用\" class=\"headerlink\" title=\"管道模式之多路复用\"></a>管道模式之多路复用</h3><p>白话文解释：多个函数同时从同一个channel里读取数据，直到channel被关闭，假设”找出偶数“时间比较短，”偶数乘以2“这一步的处理流程时间比较长，可以考虑多开几个”偶数乘以2“的处理流程，则可以更好的利用多核。如下图所示：</p>\n<p><img src=\"/blog/images/go/pipe/pipe3.png\" alt=\"多路复用流程图\"></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Events 从切片中找出偶数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Events</span><span class=\"params\">(input []<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(input); i++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> input[i]%<span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tch &lt;- input[i]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// M2 将偶数乘以2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">M2</span><span class=\"params\">(input <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> input &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(time.Second * <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tch &lt;- i * <span class=\"number\">2</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ch</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">([]<span class=\"type\">int</span>)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PipeCmd <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> (ret <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Pipe 管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Pipe</span><span class=\"params\">(nums []<span class=\"type\">int</span>, f1 Cmd, ps ...PipeCmd)</span></span> <span class=\"keyword\">chan</span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\twg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">\tevench := f1(nums) <span class=\"comment\">// 找偶数</span></span><br><span class=\"line\">\tout := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, p := <span class=\"keyword\">range</span> ps &#123;</span><br><span class=\"line\">\t\tgetChan := p(evench)</span><br><span class=\"line\">\t\twg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ch <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> c := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\t\t\t\tout &lt;- c</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;(getChan)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">\t\twg.Wait()</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> out</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Test 示例调用管道函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    nums := []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">32</span>&#125;</span><br><span class=\"line\">\tres := Pipe(nums, Events, M2, M2)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> res &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%d &quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>完整代码查看：<a href=\"https://github.com/nhdeng/gopipe\">https://github.com/nhdeng/gopipe</a></p>\n"},{"title":"go仿射","date":"2023-05-17T06:16:26.000Z","excerpt":"在 Go 中，可以使用 reflect 包来实现反射。reflect 提供了一组函数和类型，可以在运行时获取对象的类型信息、字段值、调用方法等。","_content":"## reflect\n在**运行时**动态获取或设置变量的各种信息，比如变量的类型（type），类别（kind），值（value）\n\n## 典型方法\n- reflect.TypeOf(变量)：专门用来处理类型，用于获取给定值的类型信息\n- reflect.ValueOf(变量)：专门用来处理值，用于获取给定值的反射值对象\n- t.NumField()：用来获取结构体（不能是结构体指针）的属性的个数\n- t.ELem()用来获取指针指向的内容\n- t.Kind()：用来获取变量的类型是int/string/array/func/ptr/struct\n- t.Set(变量)：给仿射对象设置值\n\n## 示例\n1. 仿射实体 获取仿射struct所有属性\n```golang\ntype User struct {\n\tUserId   int  \n\tUserName string\n}\n\nu := Object.User{}\nt := reflect.TypeOf(u)\nfor i:= 0; i < t.NumField(); i ++ {\n    fmt.Println(t.Field(i).Name, t.Field(i).Type)\n} \n```\n2. 仿射指针 获取仿射struct所有属性\n```golang\ntype User struct {\n    UserId int \n    Username string\n}\nu := &User{}\nt := reflect.TypeOf(u)\n// 使用Kind()方法判断当前变量是否为指针\nif t.Kind() == reflect.Ptr {\n    // 如果是指针使用Elem()方法获取当前指针指向的内容  \n    t = t.Elem()\n}\nfor i := 0; i < t.NumField(); i++ {\n    fmt.Println(t.Field(i).Name, t.Field(i).Type)    \n}\n```\n3. 将切片映射为struct\n```golang\ntype User struct {\n    UserId int\n    Username string\n}\nvalues := []interface{}{1, \"dengnanhao\"}\nu := &User{}\nt := reflect.TypeOf(u)\nt = t.Elem()\nfor i:=0; i<t.NumField();i++ {\n    if t.Field(i).Kind() == reflect.ValueOf(values[i]).Kind() {\n        t.Field(i).Set(reflect.ValueOf(values[i]))\n    }\n}\n```\n4. 将map映射为struct\n```golang\ntype User struct {\n    UserId int \n    Username string\n    Age1 int `name:\"age\"`\n}\n\nm := map[string]interface{}{\n    Id: 1,\n    UserId: 10,\n    Username: \"dengnanhao\",\n    Age: \"20\"\n}\n// 将map转化为struct\nfunc Map2Struct(m map[string]interface{}, u interface{}) {\n    u1 := reflec.ValueOf(u)\n    // 判断u是否为指针\n    if u1.Kind() == reflect.Ptr {\n        u1 := u1.Elem()\n        // 判断u是否为结构体\n        if u1.Kind() == reflect.Struct {\n            findFromMap := func(key string, tag string) interface{} {\n                for k, v := range map {\n                    if k == key || key == tag {\n                        return v\n                    }\n                }\n                return nil\n            }\n            for i:=0; i < u1.NumField(); i ++ {\n                // 将ValueOf与TypeOf进行转换\n                // map的key匹配结构体的属性或者name标签，任意一个匹配上就进行返回，主要匹配属性\n                val := findFromMap(u1.Type().Field(i).Name, u1.Type().Field(i).Tag.Get(\"name\"))\n                if val != nil && reflect.ValueOf(val).Kind() == u1.Field(i).Kind() {\n                    u1.Field(i).Set(reflect.ValueOf(val))\n                }\n            }\n        } else {\n            panic(\"u must struce\")\n        }\n    } else {\n        panic(\"u must pointer\")\n    }\n}\n\n```","source":"_posts/go/reflect.md","raw":"---\ntitle: go仿射\ndate: 2023-05-17 14:16:26\ntags: [\"go\", \"reflect\"]\nexcerpt: 在 Go 中，可以使用 reflect 包来实现反射。reflect 提供了一组函数和类型，可以在运行时获取对象的类型信息、字段值、调用方法等。\n---\n## reflect\n在**运行时**动态获取或设置变量的各种信息，比如变量的类型（type），类别（kind），值（value）\n\n## 典型方法\n- reflect.TypeOf(变量)：专门用来处理类型，用于获取给定值的类型信息\n- reflect.ValueOf(变量)：专门用来处理值，用于获取给定值的反射值对象\n- t.NumField()：用来获取结构体（不能是结构体指针）的属性的个数\n- t.ELem()用来获取指针指向的内容\n- t.Kind()：用来获取变量的类型是int/string/array/func/ptr/struct\n- t.Set(变量)：给仿射对象设置值\n\n## 示例\n1. 仿射实体 获取仿射struct所有属性\n```golang\ntype User struct {\n\tUserId   int  \n\tUserName string\n}\n\nu := Object.User{}\nt := reflect.TypeOf(u)\nfor i:= 0; i < t.NumField(); i ++ {\n    fmt.Println(t.Field(i).Name, t.Field(i).Type)\n} \n```\n2. 仿射指针 获取仿射struct所有属性\n```golang\ntype User struct {\n    UserId int \n    Username string\n}\nu := &User{}\nt := reflect.TypeOf(u)\n// 使用Kind()方法判断当前变量是否为指针\nif t.Kind() == reflect.Ptr {\n    // 如果是指针使用Elem()方法获取当前指针指向的内容  \n    t = t.Elem()\n}\nfor i := 0; i < t.NumField(); i++ {\n    fmt.Println(t.Field(i).Name, t.Field(i).Type)    \n}\n```\n3. 将切片映射为struct\n```golang\ntype User struct {\n    UserId int\n    Username string\n}\nvalues := []interface{}{1, \"dengnanhao\"}\nu := &User{}\nt := reflect.TypeOf(u)\nt = t.Elem()\nfor i:=0; i<t.NumField();i++ {\n    if t.Field(i).Kind() == reflect.ValueOf(values[i]).Kind() {\n        t.Field(i).Set(reflect.ValueOf(values[i]))\n    }\n}\n```\n4. 将map映射为struct\n```golang\ntype User struct {\n    UserId int \n    Username string\n    Age1 int `name:\"age\"`\n}\n\nm := map[string]interface{}{\n    Id: 1,\n    UserId: 10,\n    Username: \"dengnanhao\",\n    Age: \"20\"\n}\n// 将map转化为struct\nfunc Map2Struct(m map[string]interface{}, u interface{}) {\n    u1 := reflec.ValueOf(u)\n    // 判断u是否为指针\n    if u1.Kind() == reflect.Ptr {\n        u1 := u1.Elem()\n        // 判断u是否为结构体\n        if u1.Kind() == reflect.Struct {\n            findFromMap := func(key string, tag string) interface{} {\n                for k, v := range map {\n                    if k == key || key == tag {\n                        return v\n                    }\n                }\n                return nil\n            }\n            for i:=0; i < u1.NumField(); i ++ {\n                // 将ValueOf与TypeOf进行转换\n                // map的key匹配结构体的属性或者name标签，任意一个匹配上就进行返回，主要匹配属性\n                val := findFromMap(u1.Type().Field(i).Name, u1.Type().Field(i).Tag.Get(\"name\"))\n                if val != nil && reflect.ValueOf(val).Kind() == u1.Field(i).Kind() {\n                    u1.Field(i).Set(reflect.ValueOf(val))\n                }\n            }\n        } else {\n            panic(\"u must struce\")\n        }\n    } else {\n        panic(\"u must pointer\")\n    }\n}\n\n```","slug":"go/reflect","published":1,"updated":"2023-05-17T09:04:17.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi4o000b6oup4yp3fdcf","content":"<h2 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h2><p>在<strong>运行时</strong>动态获取或设置变量的各种信息，比如变量的类型（type），类别（kind），值（value）</p>\n<h2 id=\"典型方法\"><a href=\"#典型方法\" class=\"headerlink\" title=\"典型方法\"></a>典型方法</h2><ul>\n<li>reflect.TypeOf(变量)：专门用来处理类型，用于获取给定值的类型信息</li>\n<li>reflect.ValueOf(变量)：专门用来处理值，用于获取给定值的反射值对象</li>\n<li>t.NumField()：用来获取结构体（不能是结构体指针）的属性的个数</li>\n<li>t.ELem()用来获取指针指向的内容</li>\n<li>t.Kind()：用来获取变量的类型是int&#x2F;string&#x2F;array&#x2F;func&#x2F;ptr&#x2F;struct</li>\n<li>t.Set(变量)：给仿射对象设置值</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><ol>\n<li>仿射实体 获取仿射struct所有属性<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tUserId   <span class=\"type\">int</span>  </span><br><span class=\"line\">\tUserName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">u := Object.User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; t.NumField(); i ++ &#123;</span><br><span class=\"line\">    fmt.Println(t.Field(i).Name, t.Field(i).Type)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></li>\n<li>仿射指针 获取仿射struct所有属性<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span> </span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u := &amp;User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\"><span class=\"comment\">// 使用Kind()方法判断当前变量是否为指针</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是指针使用Elem()方法获取当前指针指向的内容  </span></span><br><span class=\"line\">    t = t.Elem()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class=\"line\">    fmt.Println(t.Field(i).Name, t.Field(i).Type)    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将切片映射为struct<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span></span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">values := []<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;dengnanhao&quot;</span>&#125;</span><br><span class=\"line\">u := &amp;User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\">t = t.Elem()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;t.NumField();i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.Field(i).Kind() == reflect.ValueOf(values[i]).Kind() &#123;</span><br><span class=\"line\">        t.Field(i).Set(reflect.ValueOf(values[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将map映射为struct<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span> </span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">    Age1 <span class=\"type\">int</span> <span class=\"string\">`name:&quot;age&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    Id: <span class=\"number\">1</span>,</span><br><span class=\"line\">    UserId: <span class=\"number\">10</span>,</span><br><span class=\"line\">    Username: <span class=\"string\">&quot;dengnanhao&quot;</span>,</span><br><span class=\"line\">    Age: <span class=\"string\">&quot;20&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将map转化为struct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Map2Struct</span><span class=\"params\">(m <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;, u <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    u1 := reflec.ValueOf(u)</span><br><span class=\"line\">    <span class=\"comment\">// 判断u是否为指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> u1.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">        u1 := u1.Elem()</span><br><span class=\"line\">        <span class=\"comment\">// 判断u是否为结构体</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> u1.Kind() == reflect.Struct &#123;</span><br><span class=\"line\">            findFromMap := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"type\">string</span>, tag <span class=\"type\">string</span>)</span></span> <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> <span class=\"keyword\">map</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> k == key || key == tag &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> v</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; u1.NumField(); i ++ &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将ValueOf与TypeOf进行转换</span></span><br><span class=\"line\">                <span class=\"comment\">// map的key匹配结构体的属性或者name标签，任意一个匹配上就进行返回，主要匹配属性</span></span><br><span class=\"line\">                val := findFromMap(u1.Type().Field(i).Name, u1.Type().Field(i).Tag.Get(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val != <span class=\"literal\">nil</span> &amp;&amp; reflect.ValueOf(val).Kind() == u1.Field(i).Kind() &#123;</span><br><span class=\"line\">                    u1.Field(i).Set(reflect.ValueOf(val))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;u must struce&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;u must pointer&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"more":"<h2 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h2><p>在<strong>运行时</strong>动态获取或设置变量的各种信息，比如变量的类型（type），类别（kind），值（value）</p>\n<h2 id=\"典型方法\"><a href=\"#典型方法\" class=\"headerlink\" title=\"典型方法\"></a>典型方法</h2><ul>\n<li>reflect.TypeOf(变量)：专门用来处理类型，用于获取给定值的类型信息</li>\n<li>reflect.ValueOf(变量)：专门用来处理值，用于获取给定值的反射值对象</li>\n<li>t.NumField()：用来获取结构体（不能是结构体指针）的属性的个数</li>\n<li>t.ELem()用来获取指针指向的内容</li>\n<li>t.Kind()：用来获取变量的类型是int&#x2F;string&#x2F;array&#x2F;func&#x2F;ptr&#x2F;struct</li>\n<li>t.Set(变量)：给仿射对象设置值</li>\n</ul>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><ol>\n<li>仿射实体 获取仿射struct所有属性<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tUserId   <span class=\"type\">int</span>  </span><br><span class=\"line\">\tUserName <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">u := Object.User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; t.NumField(); i ++ &#123;</span><br><span class=\"line\">    fmt.Println(t.Field(i).Name, t.Field(i).Type)</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></li>\n<li>仿射指针 获取仿射struct所有属性<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span> </span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">u := &amp;User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\"><span class=\"comment\">// 使用Kind()方法判断当前变量是否为指针</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> t.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是指针使用Elem()方法获取当前指针指向的内容  </span></span><br><span class=\"line\">    t = t.Elem()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class=\"line\">    fmt.Println(t.Field(i).Name, t.Field(i).Type)    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将切片映射为struct<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span></span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">values := []<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;dengnanhao&quot;</span>&#125;</span><br><span class=\"line\">u := &amp;User&#123;&#125;</span><br><span class=\"line\">t := reflect.TypeOf(u)</span><br><span class=\"line\">t = t.Elem()</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;t.NumField();i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.Field(i).Kind() == reflect.ValueOf(values[i]).Kind() &#123;</span><br><span class=\"line\">        t.Field(i).Set(reflect.ValueOf(values[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将map映射为struct<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    UserId <span class=\"type\">int</span> </span><br><span class=\"line\">    Username <span class=\"type\">string</span></span><br><span class=\"line\">    Age1 <span class=\"type\">int</span> <span class=\"string\">`name:&quot;age&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    Id: <span class=\"number\">1</span>,</span><br><span class=\"line\">    UserId: <span class=\"number\">10</span>,</span><br><span class=\"line\">    Username: <span class=\"string\">&quot;dengnanhao&quot;</span>,</span><br><span class=\"line\">    Age: <span class=\"string\">&quot;20&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将map转化为struct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Map2Struct</span><span class=\"params\">(m <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;, u <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">    u1 := reflec.ValueOf(u)</span><br><span class=\"line\">    <span class=\"comment\">// 判断u是否为指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> u1.Kind() == reflect.Ptr &#123;</span><br><span class=\"line\">        u1 := u1.Elem()</span><br><span class=\"line\">        <span class=\"comment\">// 判断u是否为结构体</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> u1.Kind() == reflect.Struct &#123;</span><br><span class=\"line\">            findFromMap := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"type\">string</span>, tag <span class=\"type\">string</span>)</span></span> <span class=\"keyword\">interface</span>&#123;&#125; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> <span class=\"keyword\">map</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> k == key || key == tag &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> v</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; u1.NumField(); i ++ &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将ValueOf与TypeOf进行转换</span></span><br><span class=\"line\">                <span class=\"comment\">// map的key匹配结构体的属性或者name标签，任意一个匹配上就进行返回，主要匹配属性</span></span><br><span class=\"line\">                val := findFromMap(u1.Type().Field(i).Name, u1.Type().Field(i).Tag.Get(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\">                <span class=\"keyword\">if</span> val != <span class=\"literal\">nil</span> &amp;&amp; reflect.ValueOf(val).Kind() == u1.Field(i).Kind() &#123;</span><br><span class=\"line\">                    u1.Field(i).Set(reflect.ValueOf(val))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;u must struce&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;u must pointer&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Redis基本数据类型及语法","date":"2023-04-02T06:06:18.000Z","excerpt":"本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。","_content":"\n# Redis基础-基本数据类型及语法\n本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n\nredis官网文档：https://redis.io\n\nredis中文文档：http://www.redis.cn\n\n## 一、docker安装redis\n1. 建立宿主机redis容器目录\n```bash\nmkdir -p /app/redis\n```\n2. 拷贝redis配置文件redis.conf到/app/redis目录下（redis配置文件官网下载地址：https://redis.io/download/）\n```bash\n# 修改redis.conf默认配置\n# 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1\n# 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败\n# 3. 【可选】开启redis数据持久化 appendonly yes \n# 4. 【可选】开启redis验证 requirepass 123456\n```\n3. 创建redis容器实例\n```bash\n# 拉取redis镜像\ndocker pull redis\n\n# 运行实例并挂载容器数据卷\ndocker run -d --name=redis --network=host --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf\n\n# 进入容器实例\ndocker exec -d redis /bin/bash\n\n# 执行redis-cli\n```\n## 二、redis键（key）常用命令\n1. 查看当前库所有key\n```bash\nKeys *\n```\n2. 判断某个key是否存在\n```bash\nExists key\n```\n3. 查看key类型\n```bash\nType key\n```\n3. 删除指定key\n```bash\nDel key\n```\n4. 非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作\n```bash\nUnlink key\n```\n5. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nTTL key\n```\n6. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nExpire key\n```\n\n7. 将当前数据库的 key移动到给定的数据库 db 当中\n```bash\nMove key dbIndex # dbIndex默认取证范围0-15\n```\n7. 切换数据库\n```bash\nSelect dbIndex # dbIndex默认取证范围0-15，默认为0\n```\n8. 查看当前数据局key的数量\n```bash\nDBSize\n```\n9. 清空当前库\n```bash\nFlushDB\n```\n10. 清空所有库\n```bash\nFlushAll\n```\n```bash\n# 查看具体数据类型的命令\nhelp @string \n```\n**更多命令查看官网：https://redis.io/commands/，**\n\n\n## 三、redis常用数据类型及命令\nredis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。\n### Redis字符串（String）\nString 单值单value\n1. 设置字符串\n```bash\nSet key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]\n```\nOptions说明：\n- EX seconds:以秒为单位设置过期时间；\n- PX milliseconds:以毫秒为单位设置过期时间；\n- EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；\n- PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；\n- NX:键不存在时设置键值；\n- XX:键存在时设置键值；\n- KEEPTTL:保留设置前的指定键的生存时间；\n- GET:返回指定键原本的值，若键不存在时返回nil\n\n2. 获取字符串`Get key`\n3. 同时设置获取多个键值\n```bash\nMSet key value [key value...]\nMGet key [key...]\n# 同时设置多个键值对当且仅当所有的key都不存在时\nMSetNX key value [key value...]\n```\n4. 获取指定区间范围内的值\n```bash\n# 相当于字符串的截取相当于substr，从0到-1表示全部\nGetRange name 0 2\nSetRange name 0 hello\n```\n5. 数值增减，只能是数字才能进行加减\n```bash\n# 递增数字\nIncr key\n# 增加指定的整数\nIncrBy key increment\n# 递减数字\nDecr key\n# 减少指定的整数\nDecrBy key decrement\n```\n6. 获取字符串长度和内容增加\n```bash\nStrLen key\nAppend key value\n```\n7. getset(先get再set)\n```bash\nGetSet key value\n```\n\n### Redis 列表（List）\nList 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。\n\n1. 为列表添加值\n```bash\nLPush/RPush key value [value...]\n```\n2. 查看列表指定区间元素\n```bash\n#0到-1代表查看所有元素\nLRange key start top\n```\n3. 移出并获取列表的第一个元素\n```bash\nLPop/RPop key \n```\n4. 按照索引下标获取元素\n```bash\nLIndex key index \n```\n5. 获取列表中元素的个数\n```bash\nLLen key\n```\n6. 删除N个数值等于xx的元素\n```bash\n# N为0代表指定值全部删除\nLRem key N xx\n```\n7. 截取指定Key范围内的值再指定给key\n```bash\nLTrim key start stop\n```\n8. 移除列表的最后一个元素并将该元素添加到另一个列表并返回\n```bash\nRPopLPush 源列表 目标列表\n```\n9. 通过索引设置列表元素中的值\n```bash\nLSet key index value\n```\n10. 向列表中插入新值\n```bash\nLInsert key Before/After 已有值 新值\n```\n\n### Redis 哈希（Hash）\nKV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。\n\n1. 基本操作\n```bash\nHSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]\n```\n2. 获取某个key中的键值对数量\n```bash\nHLen key\n```\n3. 查看hash指定字段是否存在\n```bash\nHExists key field\n```\n4. 查看hash中所有field或者value\n```bash\nHKeys/HVals key\n```\n5. 为hash表中的指定字段整加/浮点加\n```bash\nHIncrBy/HIncrByFloat key field value\n```\n6. 不存在就赋值，存在就无效\n```bash\nHSetNX key field value\n```\n### Redis 集合（Set）\n单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n1. 向集合中添加一个/多个元素\n```bash\nSAdd key member [member...]\n```\n2. 遍历集合key中的所有元素\n```bash\nSMembers key \n```\n3. 判断元素是否存在于集合中\n```bash\nSISMember key value \n```\n4. 移除集合中的元素\n```bash\nSRem key value \n```\n5. 获取集合中元素的个数\n```bash\nSCard key\n```\n6. 从集合中随机展现N个元素，元素不删除\n```bash\nSRandMember key N \n```\n6. 从集合中随机弹出N个元素，元素删除\n```bash\nSPop key N \n```\n6. 将集合中A中的某个值移入B集合中\n```bash\nSMove A B Avalue \n```\n7. 集合运算\n```bash\n# A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素\nSDiff key [key...]\n\n# A、B集合的并集运算\nSUnion key [key...]\n\n# A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合\nSInter key [key...]\n\n# 给定集合的交集产生的集合的基数，N代表key的个数\nSInterCard N key [key...]\n```\n\n### Redis 有序集合（ZSet）\nRedis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。\n\n1. 添加元素\n```bash \nZAdd key score member [score member...]\n```\n2. 通过索引区间返回有序集合中指定区间内的成员\n```bash \n# 按照元素分数从小到大，[withscores]是否带上分数\nZRange key start stop [withscores]\n```\n3. 通过索引区间返回有序集合中指定区间内的成员，倒序排列\n```bash \n# 按照元素分数从大到小，[withscores]是否带上分数\nZRevRange key start stop [withscores]\n```\n4. 指定分数范围内的元素\n```bash\nZRangeByScore key min max [withScores] [limit offset count]\n```\n5. 获取元素的分数\n```bash\nZScore key member\n```\n6. 获取集合中元素的数量\n```bash\nZCard key\n```\n7. 移除元素\n```bash\nZRem key member\n```\n8. 增加某个元素的分数\n```bash\nZIncrBy key increment member\n```\n9. 获取指定分数范围内的元素个数\n```bash\nZCount key min max\n```\n10. **从键名列表中的第一个**非空排序集中弹出一个或者多个元素，它们是成员分数对\n```bash\n# 从多个有序集合中弹出2个元素\nZMPop numKeys key [key...] min/max count 2\n```\n11. 获取有序集合中的元素下标值\n```bash\nZRank key values member\n```\n12. 获取有序集合中的逆序元素下标值\n```bash\nZRevRank key values member\n```\n\n## 四、基础数据类型的基本使用场景\n\n| 数据类型   | 经典使用场景                                   |\n|--------|------------------------------------------|\n| string | 抖音视频/商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id） |\n| List   | 微信公众号消息订阅；                               |\n| Hash   | 简单的购物车；                                  |\n| Set    | 抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人           |\n| ZSet   | 根据商品销售对商品进行排名                            |\n\n\n\n\n\n","source":"_posts/redis/base.md","raw":"---\ntitle: Redis基本数据类型及语法\ndate: 2023-04-02 14:06:18\ntags: [\"redis\", \"string\", \"list\", \"hash\", \"set\", \"zset\"]\nexcerpt: 本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n---\n\n# Redis基础-基本数据类型及语法\n本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。\n\nredis官网文档：https://redis.io\n\nredis中文文档：http://www.redis.cn\n\n## 一、docker安装redis\n1. 建立宿主机redis容器目录\n```bash\nmkdir -p /app/redis\n```\n2. 拷贝redis配置文件redis.conf到/app/redis目录下（redis配置文件官网下载地址：https://redis.io/download/）\n```bash\n# 修改redis.conf默认配置\n# 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1\n# 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败\n# 3. 【可选】开启redis数据持久化 appendonly yes \n# 4. 【可选】开启redis验证 requirepass 123456\n```\n3. 创建redis容器实例\n```bash\n# 拉取redis镜像\ndocker pull redis\n\n# 运行实例并挂载容器数据卷\ndocker run -d --name=redis --network=host --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf\n\n# 进入容器实例\ndocker exec -d redis /bin/bash\n\n# 执行redis-cli\n```\n## 二、redis键（key）常用命令\n1. 查看当前库所有key\n```bash\nKeys *\n```\n2. 判断某个key是否存在\n```bash\nExists key\n```\n3. 查看key类型\n```bash\nType key\n```\n3. 删除指定key\n```bash\nDel key\n```\n4. 非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作\n```bash\nUnlink key\n```\n5. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nTTL key\n```\n6. 查看还有多少秒过期，-1表示永不过期，-2表示已过期\n```bash\nExpire key\n```\n\n7. 将当前数据库的 key移动到给定的数据库 db 当中\n```bash\nMove key dbIndex # dbIndex默认取证范围0-15\n```\n7. 切换数据库\n```bash\nSelect dbIndex # dbIndex默认取证范围0-15，默认为0\n```\n8. 查看当前数据局key的数量\n```bash\nDBSize\n```\n9. 清空当前库\n```bash\nFlushDB\n```\n10. 清空所有库\n```bash\nFlushAll\n```\n```bash\n# 查看具体数据类型的命令\nhelp @string \n```\n**更多命令查看官网：https://redis.io/commands/，**\n\n\n## 三、redis常用数据类型及命令\nredis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。\n### Redis字符串（String）\nString 单值单value\n1. 设置字符串\n```bash\nSet key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]\n```\nOptions说明：\n- EX seconds:以秒为单位设置过期时间；\n- PX milliseconds:以毫秒为单位设置过期时间；\n- EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；\n- PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；\n- NX:键不存在时设置键值；\n- XX:键存在时设置键值；\n- KEEPTTL:保留设置前的指定键的生存时间；\n- GET:返回指定键原本的值，若键不存在时返回nil\n\n2. 获取字符串`Get key`\n3. 同时设置获取多个键值\n```bash\nMSet key value [key value...]\nMGet key [key...]\n# 同时设置多个键值对当且仅当所有的key都不存在时\nMSetNX key value [key value...]\n```\n4. 获取指定区间范围内的值\n```bash\n# 相当于字符串的截取相当于substr，从0到-1表示全部\nGetRange name 0 2\nSetRange name 0 hello\n```\n5. 数值增减，只能是数字才能进行加减\n```bash\n# 递增数字\nIncr key\n# 增加指定的整数\nIncrBy key increment\n# 递减数字\nDecr key\n# 减少指定的整数\nDecrBy key decrement\n```\n6. 获取字符串长度和内容增加\n```bash\nStrLen key\nAppend key value\n```\n7. getset(先get再set)\n```bash\nGetSet key value\n```\n\n### Redis 列表（List）\nList 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。\n\n1. 为列表添加值\n```bash\nLPush/RPush key value [value...]\n```\n2. 查看列表指定区间元素\n```bash\n#0到-1代表查看所有元素\nLRange key start top\n```\n3. 移出并获取列表的第一个元素\n```bash\nLPop/RPop key \n```\n4. 按照索引下标获取元素\n```bash\nLIndex key index \n```\n5. 获取列表中元素的个数\n```bash\nLLen key\n```\n6. 删除N个数值等于xx的元素\n```bash\n# N为0代表指定值全部删除\nLRem key N xx\n```\n7. 截取指定Key范围内的值再指定给key\n```bash\nLTrim key start stop\n```\n8. 移除列表的最后一个元素并将该元素添加到另一个列表并返回\n```bash\nRPopLPush 源列表 目标列表\n```\n9. 通过索引设置列表元素中的值\n```bash\nLSet key index value\n```\n10. 向列表中插入新值\n```bash\nLInsert key Before/After 已有值 新值\n```\n\n### Redis 哈希（Hash）\nKV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。\n\n1. 基本操作\n```bash\nHSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]\n```\n2. 获取某个key中的键值对数量\n```bash\nHLen key\n```\n3. 查看hash指定字段是否存在\n```bash\nHExists key field\n```\n4. 查看hash中所有field或者value\n```bash\nHKeys/HVals key\n```\n5. 为hash表中的指定字段整加/浮点加\n```bash\nHIncrBy/HIncrByFloat key field value\n```\n6. 不存在就赋值，存在就无效\n```bash\nHSetNX key field value\n```\n### Redis 集合（Set）\n单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。\n1. 向集合中添加一个/多个元素\n```bash\nSAdd key member [member...]\n```\n2. 遍历集合key中的所有元素\n```bash\nSMembers key \n```\n3. 判断元素是否存在于集合中\n```bash\nSISMember key value \n```\n4. 移除集合中的元素\n```bash\nSRem key value \n```\n5. 获取集合中元素的个数\n```bash\nSCard key\n```\n6. 从集合中随机展现N个元素，元素不删除\n```bash\nSRandMember key N \n```\n6. 从集合中随机弹出N个元素，元素删除\n```bash\nSPop key N \n```\n6. 将集合中A中的某个值移入B集合中\n```bash\nSMove A B Avalue \n```\n7. 集合运算\n```bash\n# A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素\nSDiff key [key...]\n\n# A、B集合的并集运算\nSUnion key [key...]\n\n# A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合\nSInter key [key...]\n\n# 给定集合的交集产生的集合的基数，N代表key的个数\nSInterCard N key [key...]\n```\n\n### Redis 有序集合（ZSet）\nRedis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。\n\n1. 添加元素\n```bash \nZAdd key score member [score member...]\n```\n2. 通过索引区间返回有序集合中指定区间内的成员\n```bash \n# 按照元素分数从小到大，[withscores]是否带上分数\nZRange key start stop [withscores]\n```\n3. 通过索引区间返回有序集合中指定区间内的成员，倒序排列\n```bash \n# 按照元素分数从大到小，[withscores]是否带上分数\nZRevRange key start stop [withscores]\n```\n4. 指定分数范围内的元素\n```bash\nZRangeByScore key min max [withScores] [limit offset count]\n```\n5. 获取元素的分数\n```bash\nZScore key member\n```\n6. 获取集合中元素的数量\n```bash\nZCard key\n```\n7. 移除元素\n```bash\nZRem key member\n```\n8. 增加某个元素的分数\n```bash\nZIncrBy key increment member\n```\n9. 获取指定分数范围内的元素个数\n```bash\nZCount key min max\n```\n10. **从键名列表中的第一个**非空排序集中弹出一个或者多个元素，它们是成员分数对\n```bash\n# 从多个有序集合中弹出2个元素\nZMPop numKeys key [key...] min/max count 2\n```\n11. 获取有序集合中的元素下标值\n```bash\nZRank key values member\n```\n12. 获取有序集合中的逆序元素下标值\n```bash\nZRevRank key values member\n```\n\n## 四、基础数据类型的基本使用场景\n\n| 数据类型   | 经典使用场景                                   |\n|--------|------------------------------------------|\n| string | 抖音视频/商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id） |\n| List   | 微信公众号消息订阅；                               |\n| Hash   | 简单的购物车；                                  |\n| Set    | 抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人           |\n| ZSet   | 根据商品销售对商品进行排名                            |\n\n\n\n\n\n","slug":"redis/base","published":1,"updated":"2023-04-19T06:27:28.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhu5qi52001j6oupdzfu7k1u","content":"<h1 id=\"Redis基础-基本数据类型及语法\"><a href=\"#Redis基础-基本数据类型及语法\" class=\"headerlink\" title=\"Redis基础-基本数据类型及语法\"></a>Redis基础-基本数据类型及语法</h1><p>本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。</p>\n<p>redis官网文档：<a href=\"https://redis.io/\">https://redis.io</a></p>\n<p>redis中文文档：<a href=\"http://www.redis.cn/\">http://www.redis.cn</a></p>\n<h2 id=\"一、docker安装redis\"><a href=\"#一、docker安装redis\" class=\"headerlink\" title=\"一、docker安装redis\"></a>一、docker安装redis</h2><ol>\n<li>建立宿主机redis容器目录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /app/redis</span><br></pre></td></tr></table></figure></li>\n<li>拷贝redis配置文件redis.conf到&#x2F;app&#x2F;redis目录下（redis配置文件官网下载地址：<a href=\"https://redis.io/download/%EF%BC%89\">https://redis.io/download/）</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改redis.conf默认配置</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 【可选】开启redis数据持久化 appendonly yes </span></span><br><span class=\"line\"><span class=\"comment\"># 4. 【可选】开启redis验证 requirepass 123456</span></span><br></pre></td></tr></table></figure></li>\n<li>创建redis容器实例<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取redis镜像</span></span><br><span class=\"line\">docker pull redis</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行实例并挂载容器数据卷</span></span><br><span class=\"line\">docker run -d --name=redis --network=host --privileged=<span class=\"literal\">true</span> -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器实例</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -d redis /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行redis-cli</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"二、redis键（key）常用命令\"><a href=\"#二、redis键（key）常用命令\" class=\"headerlink\" title=\"二、redis键（key）常用命令\"></a>二、redis键（key）常用命令</h2><ol>\n<li><p>查看当前库所有key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keys *</span><br></pre></td></tr></table></figure></li>\n<li><p>判断某个key是否存在</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exists key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看key类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type key</span><br></pre></td></tr></table></figure></li>\n<li><p>删除指定key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Del key</span><br></pre></td></tr></table></figure></li>\n<li><p>非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unlink key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expire key</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将当前数据库的 key移动到给定的数据库 db 当中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move key dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15</span></span><br></pre></td></tr></table></figure></li>\n<li><p>切换数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15，默认为0</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查看当前数据局key的数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBSize</span><br></pre></td></tr></table></figure></li>\n<li><p>清空当前库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushDB</span><br></pre></td></tr></table></figure></li>\n<li><p>清空所有库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushAll</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看具体数据类型的命令</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> @string </span><br></pre></td></tr></table></figure>\n<p><strong>更多命令查看官网：<a href=\"https://redis.io/commands/%EF%BC%8C\">https://redis.io/commands/，</a></strong></p>\n</li>\n</ol>\n<h2 id=\"三、redis常用数据类型及命令\"><a href=\"#三、redis常用数据类型及命令\" class=\"headerlink\" title=\"三、redis常用数据类型及命令\"></a>三、redis常用数据类型及命令</h2><p>redis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。</p>\n<h3 id=\"Redis字符串（String）\"><a href=\"#Redis字符串（String）\" class=\"headerlink\" title=\"Redis字符串（String）\"></a>Redis字符串（String）</h3><p>String 单值单value</p>\n<ol>\n<li>设置字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>\nOptions说明：</li>\n</ol>\n<ul>\n<li>EX seconds:以秒为单位设置过期时间；</li>\n<li>PX milliseconds:以毫秒为单位设置过期时间；</li>\n<li>EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；</li>\n<li>PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；</li>\n<li>NX:键不存在时设置键值；</li>\n<li>XX:键存在时设置键值；</li>\n<li>KEEPTTL:保留设置前的指定键的生存时间；</li>\n<li>GET:返回指定键原本的值，若键不存在时返回nil</li>\n</ul>\n<ol start=\"2\">\n<li>获取字符串<code>Get key</code></li>\n<li>同时设置获取多个键值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSet key value [key value...]</span><br><span class=\"line\">MGet key [key...]</span><br><span class=\"line\"><span class=\"comment\"># 同时设置多个键值对当且仅当所有的key都不存在时</span></span><br><span class=\"line\">MSetNX key value [key value...]</span><br></pre></td></tr></table></figure></li>\n<li>获取指定区间范围内的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 相当于字符串的截取相当于substr，从0到-1表示全部</span></span><br><span class=\"line\">GetRange name 0 2</span><br><span class=\"line\">SetRange name 0 hello</span><br></pre></td></tr></table></figure></li>\n<li>数值增减，只能是数字才能进行加减<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 递增数字</span></span><br><span class=\"line\">Incr key</span><br><span class=\"line\"><span class=\"comment\"># 增加指定的整数</span></span><br><span class=\"line\">IncrBy key increment</span><br><span class=\"line\"><span class=\"comment\"># 递减数字</span></span><br><span class=\"line\">Decr key</span><br><span class=\"line\"><span class=\"comment\"># 减少指定的整数</span></span><br><span class=\"line\">DecrBy key decrement</span><br></pre></td></tr></table></figure></li>\n<li>获取字符串长度和内容增加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrLen key</span><br><span class=\"line\">Append key value</span><br></pre></td></tr></table></figure></li>\n<li>getset(先get再set)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GetSet key value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-列表（List）\"><a href=\"#Redis-列表（List）\" class=\"headerlink\" title=\"Redis 列表（List）\"></a>Redis 列表（List）</h3><p>List 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p>\n<ol>\n<li>为列表添加值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPush/RPush key value [value...]</span><br></pre></td></tr></table></figure></li>\n<li>查看列表指定区间元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#0到-1代表查看所有元素</span></span><br><span class=\"line\">LRange key start top</span><br></pre></td></tr></table></figure></li>\n<li>移出并获取列表的第一个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPop/RPop key </span><br></pre></td></tr></table></figure></li>\n<li>按照索引下标获取元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIndex key index </span><br></pre></td></tr></table></figure></li>\n<li>获取列表中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LLen key</span><br></pre></td></tr></table></figure></li>\n<li>删除N个数值等于xx的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># N为0代表指定值全部删除</span></span><br><span class=\"line\">LRem key N xx</span><br></pre></td></tr></table></figure></li>\n<li>截取指定Key范围内的值再指定给key<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LTrim key start stop</span><br></pre></td></tr></table></figure></li>\n<li>移除列表的最后一个元素并将该元素添加到另一个列表并返回<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPopLPush 源列表 目标列表</span><br></pre></td></tr></table></figure></li>\n<li>通过索引设置列表元素中的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSet key index value</span><br></pre></td></tr></table></figure></li>\n<li>向列表中插入新值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LInsert key Before/After 已有值 新值</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-哈希（Hash）\"><a href=\"#Redis-哈希（Hash）\" class=\"headerlink\" title=\"Redis 哈希（Hash）\"></a>Redis 哈希（Hash）</h3><p>KV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>\n<ol>\n<li>基本操作<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]</span><br></pre></td></tr></table></figure></li>\n<li>获取某个key中的键值对数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HLen key</span><br></pre></td></tr></table></figure></li>\n<li>查看hash指定字段是否存在<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HExists key field</span><br></pre></td></tr></table></figure></li>\n<li>查看hash中所有field或者value<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HKeys/HVals key</span><br></pre></td></tr></table></figure></li>\n<li>为hash表中的指定字段整加&#x2F;浮点加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HIncrBy/HIncrByFloat key field value</span><br></pre></td></tr></table></figure></li>\n<li>不存在就赋值，存在就无效<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSetNX key field value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-集合（Set）\"><a href=\"#Redis-集合（Set）\" class=\"headerlink\" title=\"Redis 集合（Set）\"></a>Redis 集合（Set）</h3><p>单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>\n<ol>\n<li>向集合中添加一个&#x2F;多个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAdd key member [member...]</span><br></pre></td></tr></table></figure></li>\n<li>遍历集合key中的所有元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMembers key </span><br></pre></td></tr></table></figure></li>\n<li>判断元素是否存在于集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SISMember key value </span><br></pre></td></tr></table></figure></li>\n<li>移除集合中的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRem key value </span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCard key</span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机展现N个元素，元素不删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRandMember key N </span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机弹出N个元素，元素删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SPop key N </span><br></pre></td></tr></table></figure></li>\n<li>将集合中A中的某个值移入B集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMove A B Avalue </span><br></pre></td></tr></table></figure></li>\n<li>集合运算<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素</span></span><br><span class=\"line\">SDiff key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的并集运算</span></span><br><span class=\"line\">SUnion key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合</span></span><br><span class=\"line\">SInter key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给定集合的交集产生的集合的基数，N代表key的个数</span></span><br><span class=\"line\">SInterCard N key [key...]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-有序集合（ZSet）\"><a href=\"#Redis-有序集合（ZSet）\" class=\"headerlink\" title=\"Redis 有序集合（ZSet）\"></a>Redis 有序集合（ZSet）</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>\n<ol>\n<li>添加元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZAdd key score member [score member...]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从小到大，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员，倒序排列<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从大到小，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRevRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>指定分数范围内的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRangeByScore key min max [withScores] [<span class=\"built_in\">limit</span> offset count]</span><br></pre></td></tr></table></figure></li>\n<li>获取元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZScore key member</span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCard key</span><br></pre></td></tr></table></figure></li>\n<li>移除元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRem key member</span><br></pre></td></tr></table></figure></li>\n<li>增加某个元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZIncrBy key increment member</span><br></pre></td></tr></table></figure></li>\n<li>获取指定分数范围内的元素个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCount key min max</span><br></pre></td></tr></table></figure></li>\n<li><strong>从键名列表中的第一个</strong>非空排序集中弹出一个或者多个元素，它们是成员分数对<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从多个有序集合中弹出2个元素</span></span><br><span class=\"line\">ZMPop numKeys key [key...] min/max count 2</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRank key values member</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的逆序元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRevRank key values member</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"四、基础数据类型的基本使用场景\"><a href=\"#四、基础数据类型的基本使用场景\" class=\"headerlink\" title=\"四、基础数据类型的基本使用场景\"></a>四、基础数据类型的基本使用场景</h2><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>经典使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>抖音视频&#x2F;商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id）</td>\n</tr>\n<tr>\n<td>List</td>\n<td>微信公众号消息订阅；</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>简单的购物车；</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人</td>\n</tr>\n<tr>\n<td>ZSet</td>\n<td>根据商品销售对商品进行排名</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"more":"<h1 id=\"Redis基础-基本数据类型及语法\"><a href=\"#Redis基础-基本数据类型及语法\" class=\"headerlink\" title=\"Redis基础-基本数据类型及语法\"></a>Redis基础-基本数据类型及语法</h1><p>本文主要记录自己学习redis的这个过程，包含redis的安装、基础数据类型以及语法，redis更加具体的使用方法请参考redis官网。</p>\n<p>redis官网文档：<a href=\"https://redis.io/\">https://redis.io</a></p>\n<p>redis中文文档：<a href=\"http://www.redis.cn/\">http://www.redis.cn</a></p>\n<h2 id=\"一、docker安装redis\"><a href=\"#一、docker安装redis\" class=\"headerlink\" title=\"一、docker安装redis\"></a>一、docker安装redis</h2><ol>\n<li>建立宿主机redis容器目录<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /app/redis</span><br></pre></td></tr></table></figure></li>\n<li>拷贝redis配置文件redis.conf到&#x2F;app&#x2F;redis目录下（redis配置文件官网下载地址：<a href=\"https://redis.io/download/%EF%BC%89\">https://redis.io/download/）</a><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 修改redis.conf默认配置</span></span><br><span class=\"line\"><span class=\"comment\"># 1. 【必须】允许redis外地连接, 注释掉 # bind 127.0.0.1</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 【必须】将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 【可选】开启redis数据持久化 appendonly yes </span></span><br><span class=\"line\"><span class=\"comment\"># 4. 【可选】开启redis验证 requirepass 123456</span></span><br></pre></td></tr></table></figure></li>\n<li>创建redis容器实例<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取redis镜像</span></span><br><span class=\"line\">docker pull redis</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行实例并挂载容器数据卷</span></span><br><span class=\"line\">docker run -d --name=redis --network=host --privileged=<span class=\"literal\">true</span> -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data redis redis-server /etc/redis/redis.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入容器实例</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -d redis /bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行redis-cli</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"二、redis键（key）常用命令\"><a href=\"#二、redis键（key）常用命令\" class=\"headerlink\" title=\"二、redis键（key）常用命令\"></a>二、redis键（key）常用命令</h2><ol>\n<li><p>查看当前库所有key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Keys *</span><br></pre></td></tr></table></figure></li>\n<li><p>判断某个key是否存在</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exists key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看key类型</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type key</span><br></pre></td></tr></table></figure></li>\n<li><p>删除指定key</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Del key</span><br></pre></td></tr></table></figure></li>\n<li><p>非阻塞删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unlink key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TTL key</span><br></pre></td></tr></table></figure></li>\n<li><p>查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expire key</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将当前数据库的 key移动到给定的数据库 db 当中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Move key dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15</span></span><br></pre></td></tr></table></figure></li>\n<li><p>切换数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Select dbIndex <span class=\"comment\"># dbIndex默认取证范围0-15，默认为0</span></span><br></pre></td></tr></table></figure></li>\n<li><p>查看当前数据局key的数量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DBSize</span><br></pre></td></tr></table></figure></li>\n<li><p>清空当前库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushDB</span><br></pre></td></tr></table></figure></li>\n<li><p>清空所有库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FlushAll</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看具体数据类型的命令</span></span><br><span class=\"line\"><span class=\"built_in\">help</span> @string </span><br></pre></td></tr></table></figure>\n<p><strong>更多命令查看官网：<a href=\"https://redis.io/commands/%EF%BC%8C\">https://redis.io/commands/，</a></strong></p>\n</li>\n</ol>\n<h2 id=\"三、redis常用数据类型及命令\"><a href=\"#三、redis常用数据类型及命令\" class=\"headerlink\" title=\"三、redis常用数据类型及命令\"></a>三、redis常用数据类型及命令</h2><p>redis常用的数据类型有string、list、hash、set、zset至于其他数据类型可以查看官网。</p>\n<h3 id=\"Redis字符串（String）\"><a href=\"#Redis字符串（String）\" class=\"headerlink\" title=\"Redis字符串（String）\"></a>Redis字符串（String）</h3><p>String 单值单value</p>\n<ol>\n<li>设置字符串<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>\nOptions说明：</li>\n</ol>\n<ul>\n<li>EX seconds:以秒为单位设置过期时间；</li>\n<li>PX milliseconds:以毫秒为单位设置过期时间；</li>\n<li>EXAT timestamp:设置以秒为单位的Unix时间戳所对应的时间为过期时间；</li>\n<li>PXAT millisecond-timestamp:设置以毫秒为单位的UNIX时间戳所对应的时间为过期时间；</li>\n<li>NX:键不存在时设置键值；</li>\n<li>XX:键存在时设置键值；</li>\n<li>KEEPTTL:保留设置前的指定键的生存时间；</li>\n<li>GET:返回指定键原本的值，若键不存在时返回nil</li>\n</ul>\n<ol start=\"2\">\n<li>获取字符串<code>Get key</code></li>\n<li>同时设置获取多个键值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MSet key value [key value...]</span><br><span class=\"line\">MGet key [key...]</span><br><span class=\"line\"><span class=\"comment\"># 同时设置多个键值对当且仅当所有的key都不存在时</span></span><br><span class=\"line\">MSetNX key value [key value...]</span><br></pre></td></tr></table></figure></li>\n<li>获取指定区间范围内的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 相当于字符串的截取相当于substr，从0到-1表示全部</span></span><br><span class=\"line\">GetRange name 0 2</span><br><span class=\"line\">SetRange name 0 hello</span><br></pre></td></tr></table></figure></li>\n<li>数值增减，只能是数字才能进行加减<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 递增数字</span></span><br><span class=\"line\">Incr key</span><br><span class=\"line\"><span class=\"comment\"># 增加指定的整数</span></span><br><span class=\"line\">IncrBy key increment</span><br><span class=\"line\"><span class=\"comment\"># 递减数字</span></span><br><span class=\"line\">Decr key</span><br><span class=\"line\"><span class=\"comment\"># 减少指定的整数</span></span><br><span class=\"line\">DecrBy key decrement</span><br></pre></td></tr></table></figure></li>\n<li>获取字符串长度和内容增加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StrLen key</span><br><span class=\"line\">Append key value</span><br></pre></td></tr></table></figure></li>\n<li>getset(先get再set)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GetSet key value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-列表（List）\"><a href=\"#Redis-列表（List）\" class=\"headerlink\" title=\"Redis 列表（List）\"></a>Redis 列表（List）</h3><p>List 单key多value，双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加；如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p>\n<ol>\n<li>为列表添加值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPush/RPush key value [value...]</span><br></pre></td></tr></table></figure></li>\n<li>查看列表指定区间元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#0到-1代表查看所有元素</span></span><br><span class=\"line\">LRange key start top</span><br></pre></td></tr></table></figure></li>\n<li>移出并获取列表的第一个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LPop/RPop key </span><br></pre></td></tr></table></figure></li>\n<li>按照索引下标获取元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LIndex key index </span><br></pre></td></tr></table></figure></li>\n<li>获取列表中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LLen key</span><br></pre></td></tr></table></figure></li>\n<li>删除N个数值等于xx的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># N为0代表指定值全部删除</span></span><br><span class=\"line\">LRem key N xx</span><br></pre></td></tr></table></figure></li>\n<li>截取指定Key范围内的值再指定给key<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LTrim key start stop</span><br></pre></td></tr></table></figure></li>\n<li>移除列表的最后一个元素并将该元素添加到另一个列表并返回<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RPopLPush 源列表 目标列表</span><br></pre></td></tr></table></figure></li>\n<li>通过索引设置列表元素中的值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSet key index value</span><br></pre></td></tr></table></figure></li>\n<li>向列表中插入新值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LInsert key Before/After 已有值 新值</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-哈希（Hash）\"><a href=\"#Redis-哈希（Hash）\" class=\"headerlink\" title=\"Redis 哈希（Hash）\"></a>Redis 哈希（Hash）</h3><p>KV模式，V也是一个键值对。Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>\n<ol>\n<li>基本操作<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSet/HGet/HMSet/HMGet/HGetAll/HDel key [field value]</span><br></pre></td></tr></table></figure></li>\n<li>获取某个key中的键值对数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HLen key</span><br></pre></td></tr></table></figure></li>\n<li>查看hash指定字段是否存在<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HExists key field</span><br></pre></td></tr></table></figure></li>\n<li>查看hash中所有field或者value<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HKeys/HVals key</span><br></pre></td></tr></table></figure></li>\n<li>为hash表中的指定字段整加&#x2F;浮点加<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HIncrBy/HIncrByFloat key field value</span><br></pre></td></tr></table></figure></li>\n<li>不存在就赋值，存在就无效<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HSetNX key field value</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-集合（Set）\"><a href=\"#Redis-集合（Set）\" class=\"headerlink\" title=\"Redis 集合（Set）\"></a>Redis 集合（Set）</h3><p>单值多value且value不能重复；Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。集合对象的编码可以是 intset 或者 hashtable。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>\n<ol>\n<li>向集合中添加一个&#x2F;多个元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SAdd key member [member...]</span><br></pre></td></tr></table></figure></li>\n<li>遍历集合key中的所有元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMembers key </span><br></pre></td></tr></table></figure></li>\n<li>判断元素是否存在于集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SISMember key value </span><br></pre></td></tr></table></figure></li>\n<li>移除集合中的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRem key value </span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SCard key</span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机展现N个元素，元素不删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SRandMember key N </span><br></pre></td></tr></table></figure></li>\n<li>从集合中随机弹出N个元素，元素删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SPop key N </span><br></pre></td></tr></table></figure></li>\n<li>将集合中A中的某个值移入B集合中<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SMove A B Avalue </span><br></pre></td></tr></table></figure></li>\n<li>集合运算<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># A、B集合的差集运算 A-B：只存在于A集合不存在于B集合中的元素</span></span><br><span class=\"line\">SDiff key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的并集运算</span></span><br><span class=\"line\">SUnion key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># A、B集合的交集运算 属于A、B两个集合中共有的元素组成的集合</span></span><br><span class=\"line\">SInter key [key...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给定集合的交集产生的集合的基数，N代表key的个数</span></span><br><span class=\"line\">SInterCard N key [key...]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"Redis-有序集合（ZSet）\"><a href=\"#Redis-有序集合（ZSet）\" class=\"headerlink\" title=\"Redis 有序集合（ZSet）\"></a>Redis 有序集合（ZSet）</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>\n<ol>\n<li>添加元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZAdd key score member [score member...]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从小到大，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>通过索引区间返回有序集合中指定区间内的成员，倒序排列<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按照元素分数从大到小，[withscores]是否带上分数</span></span><br><span class=\"line\">ZRevRange key start stop [withscores]</span><br></pre></td></tr></table></figure></li>\n<li>指定分数范围内的元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRangeByScore key min max [withScores] [<span class=\"built_in\">limit</span> offset count]</span><br></pre></td></tr></table></figure></li>\n<li>获取元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZScore key member</span><br></pre></td></tr></table></figure></li>\n<li>获取集合中元素的数量<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCard key</span><br></pre></td></tr></table></figure></li>\n<li>移除元素<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRem key member</span><br></pre></td></tr></table></figure></li>\n<li>增加某个元素的分数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZIncrBy key increment member</span><br></pre></td></tr></table></figure></li>\n<li>获取指定分数范围内的元素个数<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZCount key min max</span><br></pre></td></tr></table></figure></li>\n<li><strong>从键名列表中的第一个</strong>非空排序集中弹出一个或者多个元素，它们是成员分数对<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从多个有序集合中弹出2个元素</span></span><br><span class=\"line\">ZMPop numKeys key [key...] min/max count 2</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRank key values member</span><br></pre></td></tr></table></figure></li>\n<li>获取有序集合中的逆序元素下标值<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZRevRank key values member</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"四、基础数据类型的基本使用场景\"><a href=\"#四、基础数据类型的基本使用场景\" class=\"headerlink\" title=\"四、基础数据类型的基本使用场景\"></a>四、基础数据类型的基本使用场景</h2><table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>经典使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>抖音视频&#x2F;商品的无限点赞，点一下加一下；文章的阅读数量；（Intr 商品:id）</td>\n</tr>\n<tr>\n<td>List</td>\n<td>微信公众号消息订阅；</td>\n</tr>\n<tr>\n<td>Hash</td>\n<td>简单的购物车；</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>抽奖小程序；微信朋友圈点赞查看同赞好友；QQ内推可能认识的人</td>\n</tr>\n<tr>\n<td>ZSet</td>\n<td>根据商品销售对商品进行排名</td>\n</tr>\n</tbody></table>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clhu5qi4b00016oup4oeh1kot","tag_id":"clhu5qi4g00036oupdvy51ix0","_id":"clhu5qi4p000c6oup79zc7b0t"},{"post_id":"clhu5qi4b00016oup4oeh1kot","tag_id":"clhu5qi4l00076oupab804vck","_id":"clhu5qi4p000d6oup46l2ahaq"},{"post_id":"clhu5qi4d00026oupfnqb8o9w","tag_id":"clhu5qi4n000a6oup1n2cewtq","_id":"clhu5qi4q000f6oupb85accdm"},{"post_id":"clhu5qi4h00046oupcq8ccshp","tag_id":"clhu5qi4p000e6oupczxxdc6c","_id":"clhu5qi4r000k6oup0nar0fks"},{"post_id":"clhu5qi4h00046oupcq8ccshp","tag_id":"clhu5qi4q000g6ouph1jbbjw7","_id":"clhu5qi4r000l6oup543i4scj"},{"post_id":"clhu5qi4h00046oupcq8ccshp","tag_id":"clhu5qi4q000h6ouphaf860rt","_id":"clhu5qi4s000n6oupanbb21qi"},{"post_id":"clhu5qi4h00046oupcq8ccshp","tag_id":"clhu5qi4r000i6oupadgm1jjf","_id":"clhu5qi4s000o6oupatasf17i"},{"post_id":"clhu5qi4j00056oup2vnfbwb7","tag_id":"clhu5qi4r000j6oup06oddev0","_id":"clhu5qi4s000q6oupammmbroi"},{"post_id":"clhu5qi4j00056oup2vnfbwb7","tag_id":"clhu5qi4s000m6oup5x3nbrjq","_id":"clhu5qi4s000r6oupft1eevo9"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"clhu5qi4u000x6oupeqsfhtkg"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4s000s6oupajhqbr33","_id":"clhu5qi4v000y6oup6sf4g1bq"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4t000t6oupc7ndf88i","_id":"clhu5qi4v00106oupg2w7dd9f"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4t000u6oup724qawhk","_id":"clhu5qi4v00116oup2mec64cl"},{"post_id":"clhu5qi4k00066oup9rkrfugu","tag_id":"clhu5qi4t000v6oupdobdah5g","_id":"clhu5qi4v00136oupez1rgq9n"},{"post_id":"clhu5qi4l00086oup4lzp3qn0","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"clhu5qi4w00166oupbfjwbi4b"},{"post_id":"clhu5qi4l00086oup4lzp3qn0","tag_id":"clhu5qi4v000z6oupdzcdd11b","_id":"clhu5qi4w00176oupfkwshbov"},{"post_id":"clhu5qi4l00086oup4lzp3qn0","tag_id":"clhu5qi4v00126oup0ewr3gao","_id":"clhu5qi4w00196oup5kde0q47"},{"post_id":"clhu5qi4l00086oup4lzp3qn0","tag_id":"clhu5qi4v00146oup797864yh","_id":"clhu5qi4w001a6oup7ga66j6k"},{"post_id":"clhu5qi4m00096ouph3gy79jw","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"clhu5qi50001d6oup1ugsdg52"},{"post_id":"clhu5qi4m00096ouph3gy79jw","tag_id":"clhu5qi4w00186ouphn4r09ui","_id":"clhu5qi50001e6oupb0ce92v7"},{"post_id":"clhu5qi4m00096ouph3gy79jw","tag_id":"clhu5qi4w001b6oup1mn05jlb","_id":"clhu5qi50001g6oupbcnjed9i"},{"post_id":"clhu5qi4o000b6oup4yp3fdcf","tag_id":"clhu5qi4s000p6ouphv5f839w","_id":"clhu5qi51001h6oup2nmy752m"},{"post_id":"clhu5qi4o000b6oup4yp3fdcf","tag_id":"clhu5qi4t000v6oupdobdah5g","_id":"clhu5qi51001i6oup18kv0sim"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi54001k6ouphm3nbbk6","_id":"clhu5qi56001q6oupbxjt24b0"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi54001l6oupfzw93d4t","_id":"clhu5qi56001r6oupg7bthsfw"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi55001m6oup8tsiaq1x","_id":"clhu5qi56001s6oup5psdhmpz"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi55001n6oupc4n92q2a","_id":"clhu5qi56001t6oup31jzcg4f"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi55001o6oupfsxk0uye","_id":"clhu5qi56001u6oupcn9qgldi"},{"post_id":"clhu5qi52001j6oupdzfu7k1u","tag_id":"clhu5qi56001p6oup5ih6dbr8","_id":"clhu5qi56001v6ouphkmkdnm8"}],"Tag":[{"name":"web","_id":"clhu5qi4g00036oupdvy51ix0"},{"name":"docker","_id":"clhu5qi4l00076oupab804vck"},{"name":"hexo","_id":"clhu5qi4n000a6oup1n2cewtq"},{"name":"k8s","_id":"clhu5qi4p000e6oupczxxdc6c"},{"name":"架构","_id":"clhu5qi4q000g6ouph1jbbjw7"},{"name":"集群","_id":"clhu5qi4q000h6ouphaf860rt"},{"name":"运开","_id":"clhu5qi4r000i6oupadgm1jjf"},{"name":"git","_id":"clhu5qi4r000j6oup06oddev0"},{"name":"fork","_id":"clhu5qi4s000m6oup5x3nbrjq"},{"name":"go","_id":"clhu5qi4s000p6ouphv5f839w"},{"name":"ioc","_id":"clhu5qi4s000s6oupajhqbr33"},{"name":"控制反转","_id":"clhu5qi4t000t6oupc7ndf88i"},{"name":"依赖注入","_id":"clhu5qi4t000u6oup724qawhk"},{"name":"reflect","_id":"clhu5qi4t000v6oupdobdah5g"},{"name":"gorus","_id":"clhu5qi4v000z6oupdzcdd11b"},{"name":"rotatelogs","_id":"clhu5qi4v00126oup0ewr3gao"},{"name":"ifshook","_id":"clhu5qi4v00146oup797864yh"},{"name":"pipe","_id":"clhu5qi4w00186ouphn4r09ui"},{"name":"channel","_id":"clhu5qi4w001b6oup1mn05jlb"},{"name":"redis","_id":"clhu5qi54001k6ouphm3nbbk6"},{"name":"string","_id":"clhu5qi54001l6oupfzw93d4t"},{"name":"list","_id":"clhu5qi55001m6oup8tsiaq1x"},{"name":"hash","_id":"clhu5qi55001n6oupc4n92q2a"},{"name":"set","_id":"clhu5qi55001o6oupfsxk0uye"},{"name":"zset","_id":"clhu5qi56001p6oup5ih6dbr8"}]}}